/**
 * \file atmigration.c
 * \brief Processes for representing migration outside the model domain
 * \ingroup atEcology
 * \author Beth Fulton 	18/12/2016 CSIRO Marine Laboratories,  2005
 *
 *
 * 	Determines timing of migration that will execute in main biological code
 *
 * <b>Revisions:</b>
 */
/*  Open library routines */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <atecology.h>

/*
* prototypes for static functions that are only defined in this file.
*/
static void Check_For_Mature_Away(MSEBoxModel *bm, FILE *llogfp, int species, int time_away, int YearsAway, int migrationID);

/**
 *	\brief This routine resets annual or multiyear migration processes (done 1st day of the year)
 *	It is called by main() in the transport module.
 *
 *	For each active vertebrate and immigrating invert:<br>
 *	<ul>
 *	<li>Populate the MigrateAway and MigrateReturn arrays.</li>
 *	</ul>
 *	@param t  current time  (seconds)
 *	@param dt time range
 *	@param llogfp The model log file
 *
 *  Outputs :
 *  New migration times
 *
 * Calculate the migration dates of the given species, cohort and migrationID combination.
 * The resulting values are stored in the Leave_now and Return_Now arrays (used to be MigrateAway and MigrateBack).
 * If the species is the bm->which_Check species and we are debuging this code messages
 * are written to the log file.
 *
 *
 
 */

void Init_Migration(MSEBoxModel *bm, FILE *llogfp, int do_debug, int sp) {
    int startyr = 0;
    int endyr = (int) (ceil((bm->tstop - bm->tstart) / (365.0 * 86400.0)));
    double temp3, temp4, real_mig_length;
    int yr, migrationID, currentID, stage, sp_migrate, sp_Migrate_Time, sp_Migrate_Return,
        start_with_return, sp_Migrate_Years, this_YearsAway, mig_window, counter, this_currentID, potential_end_time,
        time_return, VarTime3, VarTime4, max_Return_Now, last_return, time_away, b;
    
    //if ( verbose > 0 )
    //    printf("Doing Init_Migration for %s\n", FunctGroupArray[sp].groupCode);
    
    /* Pre-plan all migrations */
    for (stage = 0; stage < FunctGroupArray[sp].numStages; stage++) {
        max_Return_Now = -1;
        for (yr = startyr; yr <= endyr; yr++) {
            sp_migrate = FALSE;
            for(migrationID = 0; migrationID < FunctGroupArray[sp].speciesParams[num_migrate_id]; migrationID++){
                currentID = (yr * FunctGroupArray[sp].speciesParams[num_migrate_id]) + migrationID;
                MIGRATION[sp].migrationID[stage][currentID] = migrationID;

                /* If the period of this migration is not positive then move on to the next migration */
                if (MIGRATION[sp].Period[stage][migrationID] > 0)
                    sp_migrate = TRUE;
                    
                /*
                if(sp == bm->which_check) {
                    fprintf(llogfp, "%s-%d migrationID: %d currentID: %d sp_migrate: %d as period: %d\n", FunctGroupArray[sp].groupCode, stage, migrationID, currentID, sp_migrate, MIGRATION[sp].Period[stage][migrationID]);
                }
                */
                fprintf(llogfp, "%s-%d migrationID: %d currentID: %d sp_migrate: %d as period: %d\n", FunctGroupArray[sp].groupCode, stage, migrationID, currentID, sp_migrate, MIGRATION[sp].Period[stage][migrationID]);

                sp_Migrate_Time = (int) (MIGRATION[sp].StartDay[stage][migrationID]);
                sp_Migrate_Return = (int) (MIGRATION[sp].EndDay[stage][migrationID]);
                        
                /* Check for zero length migrations */
                if (sp_Migrate_Time < sp_Migrate_Return) {
                    real_mig_length = sp_Migrate_Return - sp_Migrate_Time;
                    start_with_return = 0;
                } else if (sp_Migrate_Time > sp_Migrate_Return) {
                    real_mig_length = sp_Migrate_Return + 364 - sp_Migrate_Time;
                    start_with_return = 1;
                } else {
                    real_mig_length = 0;
                    start_with_return = 0;
                }
                    
                /*
                if(sp == bm->which_check) {
                    fprintf(llogfp, "%s-%d real_mig_length: %e start_with_return: %d\n", FunctGroupArray[sp].groupCode, stage, real_mig_length, start_with_return);
                }
                */
                fprintf(llogfp, "%s-%d real_mig_length: %e start_with_return: %d\n", FunctGroupArray[sp].groupCode, stage, real_mig_length, start_with_return);

                if(FunctGroupArray[sp].speciesParams[multiyr_mig_id]) {
                    sp_Migrate_Years = (int) (MIGRATION[sp].YearsAway[stage][migrationID]);
                    this_YearsAway = sp_Migrate_Years;
                    if(!this_YearsAway)
                        this_YearsAway = 1;
                } else {
                    sp_Migrate_Years = 0;
                    this_YearsAway = 1;
                            
                    /* If single year migrations and real_mig_length value is not greater than one move onto the next migration */
                    if (fabs(real_mig_length) <= 1)
                        sp_migrate = FALSE;
                }
                    
                if (sp_migrate == TRUE) {
                    mig_window = 14;

                    /* Add wobble to dates if required */
                    if (bm->flagrandom) {
                        temp3 = drandom(-mig_window, mig_window);
                        if (temp3 < 0.0)
                            VarTime3 = (int) (ceil(temp3 - 0.5));
                        else
                            VarTime3 = (int) (floor(temp3 + 0.5));
                        
                        temp4 = drandom(-mig_window, mig_window);
                        if (temp4 < 0.0)
                            VarTime4 = (int) (ceil(temp4 - 0.5));
                        else
                            VarTime4 = (int) (floor(temp4 + 0.5));
                    } else {
                        VarTime3 = 0;
                        VarTime4 = 0;
                    }
                            
                    if (start_with_return && !yr) {
                        // Start with returns so have those come in first then proceed as normal
                        for (counter = 0; counter < this_YearsAway; counter++) {
                            this_currentID = currentID + counter * ((int)(FunctGroupArray[sp].speciesParams[num_migrate_id]));
                            MIGRATION[sp].Leave_Now[stage][this_currentID] = sp_Migrate_Time - 364; // As already away
                            MIGRATION[sp].Return_Now[stage][this_currentID] = sp_Migrate_Return + VarTime4 + counter * 365; // Assume all the initial multi-yr ones come in on same day of year but with additional years
                                
                            if (MIGRATION[sp].Return_Now[stage][this_currentID] > max_Return_Now )
                                max_Return_Now = MIGRATION[sp].Return_Now[stage][this_currentID];
                                
                            fprintf(bm->logFile, "CHECK A sp: %s-%d, counter: %d yr = %d, this_currentID = %d as multiyr with num_mig: %d\n", FunctGroupArray[sp].groupCode, stage, counter, yr, this_currentID, ((int)(FunctGroupArray[sp].speciesParams[num_migrate_id])));
                            fprintf(llogfp, "CHECK A sp: %s-%d, yr: %d leave = %d, return = %d, this_currentID = %d, start_with_return = %d, multiyr_mig: %e, VarTime4: %d, sp_Migrate_Time: %d, sp_Migrate_Return: %d\n",
                                    FunctGroupArray[sp].groupCode, stage, yr, MIGRATION[sp].Leave_Now[stage][this_currentID],
                                    MIGRATION[sp].Return_Now[stage][this_currentID], this_currentID, start_with_return, FunctGroupArray[sp].speciesParams[multiyr_mig_id], VarTime4, sp_Migrate_Time, sp_Migrate_Return);
                                
                            /*
                            if ((do_debug && (sp == bm->which_check)) || (bm->debug == debug_prey_biology_process && bm->dayt >= bm->checkstart && bm->dayt < bm->checkstop)) {
                                fprintf(llogfp, "Time: %e, sp: %s-%d, MigrateAway%d: %d, MigrateBack%d: %d (sp_Migrate_Time: %d, VarTime4: %d, counter: %d)\n",
                                        bm->dayt, FunctGroupArray[sp].groupCode, stage, this_currentID,
                                        MIGRATION[sp].Leave_Now[stage][this_currentID], this_currentID,
                                        MIGRATION[sp].Return_Now[stage][this_currentID], sp_Migrate_Time, VarTime4, counter);
                            }
                            **/
                        }
                    } else {
                        //this_currentID = currentID;
                        if (start_with_return ) {
                            this_currentID = currentID + FunctGroupArray[sp].speciesParams[num_migrate_id] * (this_YearsAway - 1); // So have made room for the returns in first year (-1 to correct for 0 start index)
                        } else {
                            this_currentID = currentID;

                        }
                        //this_currentID = currentID;
                                
                        MIGRATION[sp].Leave_Now[stage][this_currentID] = sp_Migrate_Time + VarTime3 + yr * 365;  // So start day for year being dealt with

                        if( FunctGroupArray[sp].speciesParams[multiyr_mig_id] ) {
                            potential_end_time = sp_Migrate_Time + VarTime3 + yr * 365 + sp_Migrate_Years * 365;
                            time_return = (int)(365 * floor(potential_end_time/365)) + sp_Migrate_Return + VarTime4;  // So get year return and then add on the return day of year to get the final return date
                        } else {
                            //time_return = sp_Migrate_Time + VarTime3 + yr * 365 + real_mig_length; // Annual migrations so its start time + period away
                            time_return = sp_Migrate_Return + VarTime3 + yr * 365;

//                               if (start_with_return){
//                               	time_return = time_return - 366;
//                               }
                        }
                        MIGRATION[sp].Return_Now[stage][this_currentID] = time_return;

                        if (start_with_return){
                            MIGRATION[sp].Leave_Now[stage][this_currentID] = MIGRATION[sp].Leave_Now[stage][this_currentID] - 365;
                            MIGRATION[sp].Return_Now[stage][this_currentID] = MIGRATION[sp].Return_Now[stage][this_currentID] - 365;
                        }

                        if (MIGRATION[sp].Return_Now[stage][this_currentID] > max_Return_Now )
                            max_Return_Now = MIGRATION[sp].Return_Now[stage][this_currentID];
                        
                        
                        fprintf(llogfp, "CHECK B sp: %s-%d, yr: %d leave = %d, return = %d, this_currentID = %d, start_with_return = %d, multiyr_mig: %e, this_YearsAway: %d, VarTime3: %d, sp_Migrate_Time: %d, sp_Migrate_Return: %d, VarTime4: %d, return_term1: %d\n",
                                FunctGroupArray[sp].groupCode, stage, yr, MIGRATION[sp].Leave_Now[stage][this_currentID], MIGRATION[sp].Return_Now[stage][this_currentID], this_currentID, start_with_return, FunctGroupArray[sp].speciesParams[multiyr_mig_id], this_YearsAway, VarTime3, sp_Migrate_Time, sp_Migrate_Return, VarTime4, (int)(365 * floor(potential_end_time/365)));

                    }
                        
                    fprintf(llogfp, "%s stage %d migID: %d has AgeMigrationCheckDone: %d\n", FunctGroupArray[sp].groupCode, stage, migrationID, MIGRATION[sp].AgeMigrationCheckDone[stage][migrationID]);
                        
                    // Check for aging-migration interaction madness
                    if(!MIGRATION[sp].AgeMigrationCheckDone[stage][migrationID]) {
                        time_away = MIGRATION[sp].Return_Now[stage][this_currentID] - MIGRATION[sp].Leave_Now[stage][this_currentID];
                        Check_For_Mature_Away(bm, llogfp, sp, time_away, this_YearsAway, migrationID);
                        MIGRATION[sp].AgeMigrationCheckDone[stage][migrationID] = 1;
                    }
                }
            }
        }
            
        /* Final checks */
        last_return = -1;
        for (counter = 0; counter < MIGRATION[sp].num_in_queue; counter++) {
            if(MIGRATION[sp].Return_Now[stage][counter] > (MAXINT - 1))
                MIGRATION[sp].Return_Now[stage][counter] = max_Return_Now + 1;  // Needed for purposes of record keeping, never executed
            if( MIGRATION[sp].Return_Now[stage][counter] < last_return) {
                MIGRATION[sp].Return_Now[stage][counter] = max_Return_Now + 1;  // Needed for purposes of record keeping, never executed
            }
            last_return = MIGRATION[sp].Return_Now[stage][counter];
                
            /**/
            //if(sp == bm->which_check) {
                for(migrationID = 0; migrationID < FunctGroupArray[sp].speciesParams[num_migrate_id]; migrationID++){
                    fprintf(llogfp, "Counter: %d, sp: %s-%d, MigrateAway: %d, MigrateBack: %d migwindow: %d, sp_Migrate_Time: %d, sp_Migrate_Return: %d, startDay: %d, endDay: %d, num_migrate: %d\n", counter, FunctGroupArray[sp].groupCode, stage, MIGRATION[sp].Leave_Now[stage][counter], MIGRATION[sp].Return_Now[stage][counter], mig_window, sp_Migrate_Time, sp_Migrate_Return, ((int)(MIGRATION[sp].StartDay[stage][migrationID])), ((int)(MIGRATION[sp].EndDay[stage][migrationID])), ((int)FunctGroupArray[sp].speciesParams[num_migrate_id]));
                        
                    for(b = 0; b < FunctGroupArray[sp].numCohortsXnumGenes; b++){
                        fprintf(llogfp, "Counter: %d, sp: %s-%d migID: %d return_stage: %d leave_stage: %d\n", counter, FunctGroupArray[sp].groupCode, b, migrationID, ((int)MIGRATION[sp].return_stage_prm[b][migrationID]), ((int)MIGRATION[sp].leave_stage_prm[b][migrationID]));
                    }
                }
            //}
            /**/
        }
    }
    
    return;

}

/**
 *    \brief This routine updates count of how many migrations have been completed so don't have to search the whole queue each time (ignore ones already finished).
 *
 **/
void Update_Migration_Index(MSEBoxModel *bm, FILE *llogfp){
    int species, stage, counter, migID;
    int migdone = 0;
    
    for (species = 0; species < bm->K_num_tot_sp; species++) {
        for (counter = MIGRATION[species].num_in_queue_done; counter < MIGRATION[species].num_in_queue; counter++) {
            migdone = 0;
            for (stage = 0; stage < FunctGroupArray[species].numStages; stage++) {
                migID = MIGRATION[species].migrationID[stage][counter];
                if ((bm->dayt) > (MIGRATION[species].Return_Now[stage][counter] + MIGRATION[species].Period[stage][migID])) {
                    migdone++;
                    
                    //fprintf(llogfp, "Time: %e %s-%d Migdone %d as dayt: %e vs Return_Now: %d Period: %d\n", bm->dayt, FunctGroupArray[species].groupCode, stage, migdone, bm->dayt, MIGRATION[species].Return_Now[stage][counter], MIGRATION[species].Period[stage][migID]);
                }
            }
            if (migdone > (FunctGroupArray[species].numStages - 1)) {  // Checking for equality with FunctGroupArray[species].numStages - this is faster than == check
                MIGRATION[species].num_in_queue_done++;  // All stages have done with this entry so can truncate searchable list
                
                //fprintf(llogfp, "Time: %e %s-%d updated num_in_queue_done as migdone: %d and numStages: %d\n", bm->dayt, FunctGroupArray[species].groupCode, stage, migdone, FunctGroupArray[species].numStages);

            }
        }
    }
    return;
}

/**
 *    \brief This routine checks to see if will mature while away
 *
 *    Logical way woudl be to check for the number of aging events that would occur at while away and see if that sees you change stage.
 *    However the easy hack is to say that if you stay away for more than 365 days (one aging event) then default to use same stage as left for return dates.
 *    TODO: Fix this hack and make more elegant.
 *
 **/
void Check_For_Mature_Away(MSEBoxModel *bm, FILE *llogfp, int species, int time_away, int YearsAway, int migrationID){
    int cohort, cohort_return, stage, stage_return, counter;
    int age_mat = (int) (FunctGroupArray[species].speciesParams[age_mat_id]);
    double sp_num_spawns = (double)(FunctGroupArray[species].numSpawns);
    double sp_AgeCLassSize = (double)(FunctGroupArray[species].ageClassSize);
    double time_between_aging = 0.0;
    double time_in_cohort = 0.0;
    double time_mature = 0;
    double this_time_away = (double)(time_away);
    int use_leave_cohort = 0;
    int num_aging_events_away = 0;
    int age_events_mat = FunctGroupArray[species].ageClassSize * age_mat;
    
    //if(verbose > 0)
    //    printf("Doing Check_For_Mature_Away for %s\n", FunctGroupArray[species].groupCode);

    /* Initlaise values */
    for(cohort = 0; cohort < FunctGroupArray[species].numCohortsXnumGenes; cohort++){
        stage = FunctGroupArray[species].cohort_stage[cohort];
        MIGRATION[species].return_stage_prm[cohort][migrationID] = stage;
        MIGRATION[species].leave_stage_prm[cohort][migrationID] = stage;
    }

    if (!bm->flag_multiyr_migs || (YearsAway <= 1)) {  /* TODO: This may need to change if spawn more than once per year */
        // So the same way it always was so more to do
    } else {
        // Use stage left as, not based on age currently are, to look at return times etc
        use_leave_cohort = 0;
        
        // Check A - based on aging events
        time_between_aging = 365.0 / sp_num_spawns;
        num_aging_events_away = (int) ceil(this_time_away / time_between_aging);
        if (num_aging_events_away >= age_events_mat)
            use_leave_cohort = 1;
        
        // Check B - based on days away
        time_in_cohort = sp_AgeCLassSize * time_between_aging;   // Assumes if num_spawns = 1 (usual case) that ageCLassSize = a year
        time_mature = FunctGroupArray[species].speciesParams[age_mat_id] * time_in_cohort;
        if (this_time_away > time_mature)
            use_leave_cohort = 1;
        
        fprintf(llogfp, "%s time_between_aging: %f time_away: %d age_events_mat: %d num_aging_events_away: %d this_time_away: %f (vs YearsAway: %d) time_mature: %f use_leave_cohort: %d\n",
                FunctGroupArray[species].groupCode, time_between_aging, time_away, age_events_mat, num_aging_events_away, this_time_away, YearsAway, time_mature, use_leave_cohort);
        
        if (use_leave_cohort) {
            for(cohort = 0; cohort < FunctGroupArray[species].numCohortsXnumGenes; cohort++){
                stage = FunctGroupArray[species].cohort_stage[cohort];
                
                if(!MIGRATION[species].use_stage_prm_done[cohort][migrationID]) {
                    cohort_return = cohort + num_aging_events_away;
                    if (cohort_return > (FunctGroupArray[species].numCohortsXnumGenes - 1))
                        cohort_return = FunctGroupArray[species].numCohortsXnumGenes - 1;
                    
                    
                    fprintf(llogfp,"%s-%d has mig!D: %d has cohort_return: %d num_aging_events_away: %d\n", FunctGroupArray[species].groupCode, cohort, migrationID, cohort_return, num_aging_events_away);
                    
                    for (counter=cohort; counter < cohort_return; counter++) {
                        stage_return = FunctGroupArray[species].cohort_stage[counter];
                        MIGRATION[species].return_stage_prm[counter][migrationID] = stage;
                        MIGRATION[species].leave_stage_prm[counter][migrationID] = stage;
                        MIGRATION[species].use_stage_prm_done[counter][migrationID] = 1;
                        MIGRATION[species].AgeMigrationCheckDone[stage_return][migrationID] = 1;

                        fprintf(llogfp, "sp: %s stage %d (counter: %d), MigID: %d return_stage_prm: %d, leave_stage_prm: %d\n", FunctGroupArray[species].groupCode, stage_return, counter, migrationID, MIGRATION[species].return_stage_prm[counter][migrationID], MIGRATION[species].leave_stage_prm[counter][migrationID]);
                    }
                }
            }
        }
    }
    return;
}

/**
 *     Check the migration data for each group. This must be called after the cohort stages are calculated.
 *
 */
void Check_Migration(MSEBoxModel *bm){
    //int endyr = 1 + (int) (ceil((bm->tstop - bm->tstart) / (365.0 * 86400.0)));
    int sp, cohort, stage, done_it, qid, b, spmigrate, num_away, num_mig, max_years, this_num_migs, do_debug, counter,
        migID, leave_stage, leave_day, return_stage, return_day, kmig_check;
    //int flag_multiyr_type, age_mat;
    int nyears = (int) (ceil((bm->tstop - bm->tstart) / (365.0 * 86400.0))) + 1;
    double ngenes;
    
    for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        if (FunctGroupArray[sp].isVertebrate == FALSE && FunctGroupArray[sp].isMobile == TRUE)
            for (cohort = 0; cohort < FunctGroupArray[sp].numCohorts; cohort++){
                stage = FunctGroupArray[sp].cohort_stage[cohort];
                Check_Migration_Data(bm, sp, stage);
            }
    }
    
    /* Set up Migration matrices for those starting outside model domain */
    // Removed if(FunctGroupArray[sp].isVertebrate == TRUE) check as apply for all species
    for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        do_debug = 0;
        //if(sp == bm->which_check)
        //    do_debug = 1;

        MIGRATION[sp].num_in_yr = (int)FunctGroupArray[sp].speciesParams[num_migrate_id];
        this_num_migs = 0;
        if(FunctGroupArray[sp].speciesParams[num_migrate_id] > 0){
            this_num_migs = nyears * (int)FunctGroupArray[sp].speciesParams[num_migrate_id] + 1;
            
            //fprintf(logfp,"%s has this_num_migs: %d nyears: %d num_migrate: %d\n", FunctGroupArray[sp].groupCode, this_num_migs, nyears, ((int)FunctGroupArray[sp].speciesParams[num_migrate_id]));
            
            if(FunctGroupArray[sp].speciesParams[multiyr_mig_id]) {
                this_num_migs = (nyears * ((int)(FunctGroupArray[sp].speciesParams[multiyr_mig_id])) * ((int)FunctGroupArray[sp].speciesParams[num_migrate_id]) + 1);
                // fprintf(logfp,"%s has this_num_migs: %d nyears: %d multiyr_mig: %d\n", FunctGroupArray[sp].groupCode, this_num_migs, nyears, ((int)FunctGroupArray[sp].speciesParams[multiyr_mig_id]));
                
            }
        }
        MIGRATION[sp].num_in_queue = this_num_migs;
        MIGRATION[sp].num_in_queue_done = 0;
        
        //fprintf(logfp,"%s has num_in_queue = %d\n", FunctGroupArray[sp].groupCode, MIGRATION[sp].num_in_queue);
        
        done_it = 0;
        spmigrate = (int) (FunctGroupArray[sp].speciesParams[num_migrate_id]);
        ngenes = (double) (FunctGroupArray[sp].numGeneTypes);
        num_mig = (int)(FunctGroupArray[sp].speciesParams[num_migrate_id]);
        //age_mat = (int) (FunctGroupArray[sp].speciesParams[age_mat_id]);
        //flag_multiyr_type = (int) (FunctGroupArray[sp].speciesParams[flag_multiyr_type_id]);
        
        if (!spmigrate)
            continue;
        
        Init_Migration(bm, bm->logFile, do_debug, sp); // Inialise timing so can do appropriate density mapping below given potential for multiyr migrations

        for (b = 0; b < FunctGroupArray[sp].numCohortsXnumGenes; b++) {
            num_away = (int)(FunctGroupArray[sp].speciesParams[num_migrate_id]);
            stage = FunctGroupArray[sp].cohort_stage[b];
            cohort = (int)floor (b / FunctGroupArray[sp].numGeneTypes);

            /* Check to make sure that the period is 1 if kmigslow is 0 */
            if(k_migslow == 0){
                for(qid = 0; qid < FunctGroupArray[sp].speciesParams[num_migrate_id]; qid++){
                    if( MIGRATION[sp].Period[stage][qid] > 1){
                        quit("Error: You have set the k_migslow to 0 indicating you want all your groups to migrate in a single day but the migration period for %s (ID %d), stage %d migration %d, is greater than 1 day (%d)\n", FunctGroupArray[sp].groupCode, sp, stage, qid, MIGRATION[sp].Period[stage][qid]);
                    }
                }
            }
            
            if (FunctGroupArray[sp].speciesParams[multiyr_mig_id]){
                max_years = 0;
                for(qid = 0; qid < num_mig; qid++){
                    if (max_years < MIGRATION[sp].YearsAway[stage][qid])
                        max_years = MIGRATION[sp].YearsAway[stage][qid];
                }
                num_away *= max_years;
                
                if (!num_away && (MIGRATION[sp].InitDEN[b][0] > 0.0)) {
                    if (!max_years)
                        quit("Something is not right with multi yr migrations -  for %s you have MultiyrMigrate set to %d, with %d migration(s) per year, you also have %e as the KMIGa entry for age class %d, but for this life history stage (%d) for YearsAway you have 0 for all entries given\n", FunctGroupArray[sp].groupCode, (int)(FunctGroupArray[sp].speciesParams[multiyr_mig_id]), num_mig, MIGRATION[sp].InitDEN[b][0], b, stage);
                }
            }
            
            //fprintf(bm->logFile, "Doing %s-%d (stage: %d, age_mat: %d, spmigrate: %d, num_away: %d, num_mig: %d)\n", FunctGroupArray[sp].groupCode, b, stage, age_mat, spmigrate, num_away, num_mig);

            /* Deal migrations spanning years end - assume flat numbers returning per year for those outside the system */
            kmig_check = 0;
            for (counter = 0; counter < MIGRATION[sp].num_in_queue; counter++) {
                migID = MIGRATION[sp].migrationID[stage][counter];
                leave_stage = MIGRATION[sp].leave_stage_prm[b][migID];
                leave_day = MIGRATION[sp].Leave_Now[leave_stage][counter];
                return_stage = MIGRATION[sp].return_stage_prm[b][migID];
                return_day = MIGRATION[sp].Return_Now[return_stage][counter];
                
                // Load in KMIG values if (a) starting outside model as migrating in from previous migraiton events or because accidentally loaded in KMIG array instead of nc
                if ((( leave_day <= 0 ) && ( return_day > 0)) || (!kmig_check && (MIGRATION[sp].InitDEN[b][0] > 0) && bm->flag_want_all_KMIG && (leave_day < 365))){
                    
                    // TODO: Think if this is the best way of handling all the migration options - all away or only a cohort at a time
                    MIGRATION[sp].SN[b][counter] = MIGRATION[sp].InitSN[b][0] / ngenes;   // As all KMIG saved Init [0] entry on read in
                    MIGRATION[sp].RN[b][counter] = MIGRATION[sp].InitRN[b][0] / ngenes;
                    MIGRATION[sp].DEN[b][counter] = MIGRATION[sp].InitDEN[b][0] / ngenes;

                    /**/
                    //if (bm->debug && (bm->which_check == sp)) {
                        fprintf(bm->logFile, "%s-%d Migration array [counter %d] num set to %e (SN: %e RN: %e)\n", FunctGroupArray[sp].groupCode, b, counter,
                            MIGRATION[sp].DEN[b][counter], MIGRATION[sp].SN[b][counter], MIGRATION[sp].RN[b][counter]);
                    //}
                    /**/
                    
                    done_it++;
                } else {
                    kmig_check = 1;
                    for(qid = 0; qid < num_away; qid++){
                        if (!FunctGroupArray[sp].speciesParams[multiyr_mig_id] && (MIGRATION[sp].InitDEN[b][qid] > 0) && (MIGRATION[sp].StartDay[stage][qid] <= MIGRATION[sp].EndDay[stage][qid])) {
                            warn("%s-%d had %e migrants in KMIG array but its migration (%d) dates (T: %d R: %d) say that it shouldn't be away at the start of the model run\n",
                                 FunctGroupArray[sp].groupCode, b, MIGRATION[sp].InitDEN[b][qid], qid, MIGRATION[sp].StartDay[stage][qid], MIGRATION[sp].EndDay[stage][qid]);
                            fprintf(bm->logFile, "%s-%d had %e migrants in KMIG array but its migration (%d) dates (T: %d R: %d) say that it shouldn't be away at the start of the model run\n", FunctGroupArray[sp].groupCode, b, MIGRATION[sp].InitDEN[b][qid], qid, MIGRATION[sp].StartDay[stage][qid], MIGRATION[sp].EndDay[stage][qid]);
                        }
                    }
                }
            }
            
            for (counter = 0; counter < MIGRATION[sp].num_in_queue; counter++) {
                 migID = MIGRATION[sp].migrationID[stage][counter];
                 leave_stage = MIGRATION[sp].leave_stage_prm[b][migID];
                 leave_day = MIGRATION[sp].Leave_Now[leave_stage][counter];
                 return_stage = MIGRATION[sp].return_stage_prm[b][migID];
                 return_day = MIGRATION[sp].Return_Now[return_stage][counter];

                 /**/
                 //if(sp == bm->which_check) {
                 fprintf(bm->logFile, "Counter: %d, sp: %s-%d counter: %d DEN: %e SN: %e RN: %e migID: %d leave_stage: %d, leave_day: %d return_stage: %d return_day: %d\n", counter, FunctGroupArray[sp].groupCode, b, counter, MIGRATION[sp].DEN[b][counter], MIGRATION[sp].SN[b][counter], MIGRATION[sp].RN[b][counter], migID, leave_stage, leave_day, return_stage, return_day);
                 //}
                 /**/
            }
        }
    }
    
    return;
}


