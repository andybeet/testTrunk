/**
 * \ingroup atManageLib
 * \file atSS3assess.c
 * \brief Subroutines for setting up the SS input files
 *     \author    Beth Fulton 8/3/2022
 
 * Original close kin Author: Rich Little
 * Expansion and Modifications: Beth Fulton
 *
 *    <b>  Revisions</b>
 *
 *  This set of routines handles doing latest SS assessment
 *
 *  //  Functions in this file :
 *     WriteSSFiles:   write the files for input to SS
 *     WriteSSDat:     write the generated data to data file for input to SS filename.dat
 *     WriteSSCtl:     write the control file for input to SS filename.ctl
 *     WriteSSFor:     write the forecast file for input to SS
 *
 */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sjwlib.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <errno.h>
#include <unistd.h>

#include "atManage.h"

//******************************************************************************
//
// Name:  SS330Assessment
// Description: do a tier 1 assessment and get RBC for next year
//
//
// called by :
// calls :
// created  :Oct 2019 Rich Little
// Modified: Oct 2020 Maciej Golebiewski
//     new Linux implementation that runs ss3 directly, without creating a script
//
//     Beth Fulton brought it into Atantis
//
//******************************************************************************
void SS330Assessment(MSEBoxModel *bm, int sp, int year, FILE *llogfp) {

    char dirName[STRLEN];
    char fileName[STRLEN];
    int ret = 0;

    /* Create directory */
    sprintf(dirName, "%s_SS3_sim_%d_year_%d", FunctGroupArray[sp].groupCode, bm->RBCestimation.sim, year);
    ret = mkdir(dirName, S_IRWXU);

    /* Change directory into the new directory */
    //pass your path in the function
    ret = chdir(dirName);
    /*if the change of directory was successful it will print successful otherwise it will print not successful*/
    if (ret < 0)
        quit("SS330Assessment: chdir change of directory to %s not successful\n", dirName);
    else
        printf("SS330Assessment: chdir change of directory to %s successful", dirName);
    
    sprintf(fileName, "WriteSS330Files");
    WriteSS330Files(bm, sp, year, dirName, fileName);
    
    //Run_SS3(bm->ss3_Exe_Nam, dirName);  //TODO: Check this will really run SS3 or do I need to call a script?

    printf("End SS3 Assessment for %s\n", FunctGroupArray[sp].groupCode);

    // read max convergence criterion
    bm->RBCestimation.RBCspeciesParam[sp][MaxConvergCrit_id] = Read_SS3_Par_File(bm, sp, year, dirName);
    if (bm->RBCestimation.RBCspeciesParam[sp][MaxConvergCrit_id] > bm->RBCestimation.MaxCritConvergeValue){   // This was originally 0.01 but Sally had changed it to 0.1, RatPack had a value of 10.0
        bm->RBCestimation.RBCspeciesParam[sp][AssessFail_id] = 1;
        fprintf(llogfp, "yr: %d WARNING - SS assessment failed as MaxConvergCrit for %s is %e (vs %e)\n", year, FunctGroupArray[sp].groupCode, bm->RBCestimation.RBCspeciesParam[sp][MaxConvergCrit_id], bm->RBCestimation.MaxCritConvergeValue);
    } else { 
        // read next year+1 catches from report.sso
        Read_SS3_Report_File(bm, sp, year, dirName);
    }

    if (bm->RBCestimation.RBCspeciesArray[sp].RBC_by_year[year][bm->RBCestimation.RBCspeciesArray[sp].mgt_rbcYear] < 0.0 || bm->RBCestimation.RBCspeciesArray[sp].RBC_by_year[year][bm->RBCestimation.RBCspeciesArray[sp].mgt_rbcYear] > 999999.9) {
        fprintf(llogfp, "Time %e %s SS assessment failed due to RBC = %e\n ", bm->dayt, FunctGroupArray[sp].groupCode, bm->RBCestimation.RBCspeciesArray[sp].RBC_by_year[year][bm->RBCestimation.RBCspeciesArray[sp].mgt_rbcYear]);

        bm->RBCestimation.RBCspeciesParam[sp][AssessFail_id] = 1;
        for (int yy = bm->RBCestimation.RBCspeciesArray[sp].mgt_rbcYear; yy < bm->RBCestimation.RBCspeciesParam[sp][MaxYr_id]+3; yy++) {  bm->RBCestimation.RBCspeciesArray[sp].RBC_by_year[year][yy] = 0.0;              // temporary value, will be reset in DoAssessment
        }
        bm->RBCestimation.RBCspeciesParam[sp][EstB0_id] = 999.9;
        bm->RBCestimation.RBCspeciesParam[sp][EstBinit_id] = 999.9;
        bm->RBCestimation.RBCspeciesParam[sp][EstBcurr_id] = 999.9;
    }

    bm->RBCestimation.RBCspeciesParam[sp][EstDepletion_id] = bm->RBCestimation.RBCspeciesParam[sp][EstBcurr_id] / (bm->RBCestimation.RBCspeciesParam[sp][EstB0_id] + small_num);

    fprintf(llogfp, "Time %e %s dataYear: %d EstDepletion: %e RBC: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, bm->RBCestimation.RBCspeciesArray[sp].mgt_dataYear, bm->RBCestimation.RBCspeciesParam[sp][EstDepletion_id], bm->RBCestimation.RBCspeciesArray[sp].RBC_by_year[year][bm->RBCestimation.RBCspeciesArray[sp].mgt_rbcYear]);

    if (bm->RBCestimation.RBCspeciesParam[sp][AssessFail_id]) { bm->RBCestimation.RBCspeciesArray[sp].NassessFail++;
    } else {
        bm->RBCestimation.RBCspeciesArray[sp].NassessFail = 0;
    }

}

