/**
 \file atbiolmessage.c
 \brief C file for running the log writing routines for Atlantis ecosystem model
 \ingroup atEcology

 File:		atbiomessage.c
 Created:	5/10/2005
 Author:		Beth Fulton,   CSIRO Marine Laboratories,  2005
 Created from previous atbiology.c file
 Purpose:	C file for running the log writing routines for Atlantis
 ecosystem model
 Note:

 Revisions: 	5/10/2005 Added Write_VirginBiom()

 20/04/2006 Moved calculation of targetspbiom to movement.c.
 This means less knowledge lag for redistribution of effort,
 but allows use in forcing globally imposed catches. As
 effort routine that may call for targetspbiom updates per
 time step anyway then this is less of an issue perfect knowledge
 wise than it could be - may need reconsidering if move away
 from aggregate high technology level fleet model.

 26-05-2008 Bec Gorton
 Changed all references from bm->VERTind to the tracer arrays associated with
 each functional group.

 01/12/2008 Bec Gorton

 Moved all of the static output files into the atEcologyModule. These files are
 opened the first time they are used and then closed when the model run is complete.

 5-6-2008 Beth Fulton
 Added MortPerPred write outs and file creation

 5-6-2008 Bec Gorton
 Moved the MortPerPred file into the atEcologyModule

 15-01-2009 Bec Gorton
 Got rid of the group specific code so move towards generic functional groups.

 20-01-2009 Bec Gorton
 Added the code to create the DietCheck output file. New functions are OutputDietCheck,
 initDietCheckFile and writeDietCheck. OutputDietCheck is called from Check_Gape when the
 bm->dietCheckFlag is true.

 02-02-2009 Beth Fulton
 Changed the writeMortPerPred function to take the log file.

 03-04-2009 Bec Gorton
 Added a debug state check around the debugging code that prints out the BSSslope
 values to the log file in Ecology_Calculate_Total_Abundance.

 19-03-2009 Bec Gorton
 Got rid of the cover2guild array. The coverTracer is now checked.
 Added the Calculate_Box_Biomass function to calculate the biomass of each group
 in each box - this replaces code in Ecology_Calculate_Total_Abundance and initPopulations. This code was pretty much
 the same.

 17-09-2009 Bec Gorton
 Fixed a formatting issue in the mortality files. Got rid of the additional space before
 the first functional group.

 15-12-2009 Bec Gorton
 Trunk merge 1433 -  Added code to print out the summation of the prey mortality to the
 mortality per pred output file.

 29-01-2010 Bec Gorton
 Fixed the mortality code so it matches the output generated by the trunk.

 17-7-2010 Beth Fulton
 Put a check vs maxwcbotz in the totbiom calculations so that the benthos
 of oceanic only cells are not included in the total biomass estimates (as
 they are not dynamic)

 14-05-2012 Beth Fulton
 Added stuff for Savina seagrass model - including totagepop so can get age structured overall output

 06-05-2013 Bec Gorton
 Added the Check_Layer_Initial_Biomass function so we can warn people if they have biomass in layers that are not really valid.
 */

/*  Open library routines */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <atecology.h>


//#define PRINT_AGE_STRUCTURED 1
// static char *HABITAT_NAMES[] =
//	{ "WC", "SED", "EPIBENTHIC" };
/*
 * The biomass output files.
 */
static FILE *vbiomfp;
static FILE *vbiomRfp;
static FILE *SSBfp;
static FILE *yoyfp;

static FILE *vbiomSfp;
static FILE *vbiomAgefp;
static FILE *vbiomAnnAgefp;

/* The mortality array output file*/
static FILE *mortfp;
static FILE *specificmortfp;

/* The mortality per predator array file*/
static FILE *mortppfp;
static FILE *specificmortppfp;

/* The diet check output file */
static FILE *dietCheckfp;
static FILE *detaileddietCheckfp;

static FILE *migrationfp;
static FILE *sizeDataFP;

/* The sun light output file */
static FILE *boxLightFP;

/* Evolution output file */
static FILE *evolfp;


static FILE *boxBiomassfp;
/**
 *
 * Function prototypes for functions that are 'private' to this file.
 */
static FILE * Init_MortEst_File(MSEBoxModel *bm);
static FILE * Init_MortPerPredEst_File(MSEBoxModel *bm);
static FILE * Init_SpecificMortEst_File(MSEBoxModel *bm);
static FILE * Init_SpecificPredMortEst_File(MSEBoxModel *bm);
static FILE * Init_VirginBiom_File(MSEBoxModel *bm);
static FILE * Init_Regional_Biomass_File(MSEBoxModel *bm);
static FILE * Init_YOY_File(MSEBoxModel *bm);
static FILE * Init_SSB_File(MSEBoxModel *bm);
static FILE * Init_DietCheck_File(MSEBoxModel *bm);
static FILE * Init_MacrophyteBiom_File(MSEBoxModel *bm);
static FILE * Init_AgeBiom_File(MSEBoxModel *bm);
static FILE * Init_AnnualAgeBiom_File(MSEBoxModel *bm);
static FILE * Init_DetailedDietCheck_File(MSEBoxModel *bm);

static void Update_Diets_Output(MSEBoxModel *bm);

static void Write_VirginBiomass(FILE *fid, MSEBoxModel *bm);
static void Write_Regional_Biomass(FILE *fid, MSEBoxModel *bm);
static void Write_SSB(FILE *fid, MSEBoxModel *bm);
static void Write_YOY(FILE *fid, MSEBoxModel *bm);
static void Write_Mort(FILE *fid, MSEBoxModel *bm);
static void Write_MortPerPred(FILE *fid, MSEBoxModel *bm);
static void Write_SpecificMort(FILE *fid, MSEBoxModel *bm);
static void Write_SpecificPredMort(FILE *fid, MSEBoxModel *bm);
static void Write_DietCheck(FILE *fid, MSEBoxModel *bm);
static void Write_MacrophyteBiomass(FILE *fid, MSEBoxModel *bm);
static void Write_AgeBiomass(FILE *fid, MSEBoxModel *bm);
static void Write_AnnualAgeBiomass(FILE *fid, MSEBoxModel *bm);
static void Write_DetailedDietCheck(FILE *fid, MSEBoxModel *bm);

static void Write_Biomass(MSEBoxModel *bm);
static void Print_Biomass_Value(MSEBoxModel *bm, int call_type, FILE *llogfp, int sp);

static void Output_Size_Data(MSEBoxModel *bm);
static void Output_Migration_Data(MSEBoxModel *bm);
static void Output_Diet_Check(MSEBoxModel *bm);

static FILE * Init_BoxLight_File(MSEBoxModel *bm);
static void Write_BoxLight(FILE *fid, MSEBoxModel *bm);


static FILE * Init_BoxBiomass_File(MSEBoxModel *bm) ;
static void Write_BoxBiomass(FILE *fid, MSEBoxModel *bm);


/**
 *	\brief Starvation Notice
 *	when vertebrate getting insufficient food to cover maintence costs
 *	This routine totals up the numbers in each cohort for each vertebrate group.
 *
 *  Inputs:
 *   MSEBoxModel:	MSEBoxModel data structure
 *   FILE:      log file
 */
void Ecology_Starve_Notice(MSEBoxModel *bm, FILE *llogfp) {

	int ij, k, starve_now;

	if (!bm->flagstarve)
		return;

	/* Identify any starving vertebrate group */
	for (k = 0; k < bm->K_num_tot_sp; k++) {
		if (FunctGroupArray[k].isVertebrate == TRUE) {
			starve_now = 0;
			for (ij = 0; ij < bm->nbox; ij++) {
				if (starve_vert[k][ij])
					starve_now = 1;
			}
			if (starve_now) {
				fprintf(llogfp, "time: %e, species %s is starving in box", bm->dayt, FunctGroupArray[k].groupCode);
				for (ij = 0; ij < bm->nbox; ij++) {
					if (starve_vert[k][ij])
						fprintf(llogfp, " %d", ij);
					starve_vert[k][ij] = 0;
				}
				fprintf(llogfp, "\n");
			}
		}
	}

	return;
}
/**
 * \brief Calculate the biomass within the given box.
 *
 * This function will loop over each water column layer in the given box and calculate the
 * biomass of each functional group in that layer. The biomass will be added to the value in the
 * bm->totbiom array for this group. Similarly the tot_SSB value for the group is calculated as the
 * biomass * the spawning proportion and the biomass of this group is added to the species biomass in the
 * reporting region as specified by the nreg input parameter.
 * If the isInitPops flag is true then this function call was made from within initPopulations and
 * the following arrays are also updated:
 * 		bm->targetspbiom
 * 		totden
 * 		bm->calcNstart
 * 		bm->stock_struct_prop
 * 		tot_yoy
 *
 * The function then loops over each sediment layer and the epibenthic layer and updates the
 * biomass arrays.
 *
 *
 * @param bm : The pointer to the BoxModel structure
 * @param llogfp: The log file
 * @param ij: The box index
 * @param nreg: The biomass reporting region for this box
 * @param isInitPops: If TRUE then this call has been made from initPopulations so initial setps
 * 	are doen to initialise the targetspbiom and other arrays.
 */
void Calculate_Box_Biomass(MSEBoxModel *bm, FILE *llogfp, int ij, int nreg, int isInitPops, int isDiagnostic) {
	int sp, sn, rn, den, pid, n, nid, cohort;
	int k, fished_chrt, stock_id;
	double biomass, nums;

	for (k = 0; k < bm->boxes[ij].nz; k++) { // loop through each layer in this box.
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if(FunctGroupArray[sp].speciesParams[flag_id]){
				switch (FunctGroupArray[sp].groupAgeType) {
				case AGE_STRUCTURED:
					fished_chrt = (int) (FunctGroupArray[sp].speciesParams[Age95pcntV_id]);
					if (fished_chrt < ((FunctGroupArray[sp].numCohortsXnumGenes) / 2))
						fished_chrt = ((FunctGroupArray[sp].numCohortsXnumGenes) / 2);

					for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
						sn = FunctGroupArray[sp].structNTracers[n];
						rn = FunctGroupArray[sp].resNTracers[n];
						den = FunctGroupArray[sp].NumsTracers[n];
						biomass = (bm->boxes[ij].tr[k][sn] + bm->boxes[ij].tr[k][rn]) * bm->boxes[ij].tr[k][den] * FunctGroupArray[sp].habitatCoeffs[WC];

						if(isDiagnostic == TRUE){
							bm->diagnosticBiom[sp] += biomass;
						}else{
							bm->totbiom[sp] += biomass;
							bm->totagepop[sp][n] += biomass;
							bm->boxBiomass[ij][sp] += biomass;

							/**
							if((sp == bm->which_check) && (bm->checkstart <= bm->dayt) && ((bm->checkbox == ij) || (bm->checkbox > bm->nbox))){
								fprintf(llogfp, "TIme: %e in calc_box_biom %s-%d in box %d-%d totbiom[sp]: %.20e, sn = %.20e, rn = %.20e, den = %.20e\n",
									bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, bm->totbiom[sp], bm->boxes[ij].tr[k][sn],
									bm->boxes[ij].tr[k][rn], bm->boxes[ij].tr[k][den]);
							}
							**/

								if(bm->totbiom[sp] < 0){
									printf("sn = %e, rn = %e, den = %e\n", bm->boxes[ij].tr[k][sn], bm->boxes[ij].tr[k][rn], bm->boxes[ij].tr[k][den]);
									quit("Biomass of %s:%d is less than zero after adding biomass from box%d:%d\n", FunctGroupArray[sp].groupCode, n, ij, k);
								}

							/* If this is the initPopulations call then do the extra steps */
							if (isInitPops == FALSE) {
								bm->reg_prop[sp][nreg] += biomass;
							} else {
								bm->initreg_prop[sp][nreg] += biomass;

								/* Need to store target species biomass here so can be used in calculations for Dan Holland's
								 economically based effort model (movement code not executed before Economics done, so need
								 to do the first round of values here first, so don't just end up with zero values everywhere
								 and no valid effort allocation).
								 */
								bm->targetspbiom[sp][ij] += biomass;

								totden[sp][n] += bm->boxes[ij].tr[k][den];
								if (n == fished_chrt) {
									bm->calcNstart[sp][hist_id] += bm->boxes[ij].tr[k][den];
								}
								bm->calcNstartPerPred[sp][hist_id] += bm->boxes[ij].tr[k][den];

								/**/
								if (bm->debug && ((bm->debug > debug_stock) && (sp == bm->which_check))) {
									fprintf(llogfp, "%s in %d-%d contribs %.16f to totden:%d %e\n", FunctGroupArray[sp].groupCode, ij, k, bm->boxes[ij].tr[k][den], n,
											totden[sp][n]);
								}
								/**/

								/* Get initial young-of-the-year stock sizes - so can check
								 for artifical reseeding */
								stock_id = bm->group_stock[sp][ij][k];

								bm->stock_struct_prop[sp][n][stock_id] += bm->boxes[ij].tr[k][den];
								bm->calcTrackedMort[sp][n][stock_id][start_id] += bm->boxes[ij].tr[k][den];


								if (bm->debug && ((bm->debug == debug_stock) && ((sp == bm->which_check) || (sp == bm->move_check)))) {
									fprintf(llogfp, "sp: %s, adding: %e, stock-%d: %.12f, totden: %e\n", FunctGroupArray[sp].groupCode, bm->boxes[ij].tr[k][den],
											stock_id, bm->stock_struct_prop[sp][n][stock_id], totden[sp][n]);
								}

								/* Starting YOY */
								if (n < FunctGroupArray[sp].numGeneTypes)
									tot_yoy[sp][stock_id] += (FunctGroupArray[sp].boxPopRatio[ij][k][0][0] * (bm->boxes[ij].tr[k][sn] + bm->boxes[ij].tr[k][rn]) * bm->boxes[ij].tr[k][den]);
							}

						}
					}
					break;
				case BIOMASS:				/* Intentional follow through */
				case AGE_STRUCTURED_BIOMASS:

					/* Ignore detritus in the water column unless explicitly requested - move onto next group */
					if(bm->flag_report_water_detritus == FALSE && (FunctGroupArray[sp].groupType == REF_DET || FunctGroupArray[sp].groupType == LAB_DET)){
						continue;
					}

					for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {

						pid = FunctGroupArray[sp].totNTracers[n];
						biomass = bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area * FunctGroupArray[sp].habitatCoeffs[WC];
						if(isDiagnostic == TRUE){
							bm->diagnosticBiom[sp] += biomass;
						}else{
							bm->totbiom[sp] += biomass;
							bm->totagepop[sp][n] += biomass;
							bm->boxBiomass[ij][sp] += biomass;

							/**
							if(sp == bm->which_check){
								fprintf(llogfp, "Time: %e, in calc_box_biom %s-%d in box %d-%d totbiom[sp]: %e, biom = %e, area = %e, dz = %e, WC = %d\n",
									bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, bm->totbiom[sp], bm->boxes[ij].tr[k][pid], bm->boxes[ij].area, bm->boxes[ij].dz[k], FunctGroupArray[sp].habitatCoeffs[WC]);
							}
							**/

							if (isInitPops == TRUE) {
								bm->initreg_prop[sp][nreg] += biomass;
								if (FunctGroupArray[sp].isImpacted == TRUE)
									bm->targetspbiom[sp][ij] += biomass;

							} else {
								bm->reg_prop[sp][nreg] += biomass;
							}
						}
					}
					break;
				}
			}

			if(!FunctGroupArray[sp].speciesParams[flag_id]){
				if(bm->totbiom[sp] > bm->min_pool){
					quit("Non zero biomass (%e) for group %s (%s) in your initial conditions file, but this group is not turned on.\n",
							bm->totbiom[sp], FunctGroupArray[sp].name, FunctGroupArray[sp].groupCode);
				}
			}
		}

		pid = NH3_i; /* Water column DIN - use hardwired references as above and
		 beyond dynamic numbers used for prey elsewhere in the code */
		nid = bm->DIN_id;
		if(isDiagnostic == TRUE){
			bm->diagnosticBiom[sp] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
		}else{
			bm->totbiom[nid] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
			if (isInitPops == TRUE) {
				bm->initreg_prop[nid][nreg] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
			} else {
				bm->reg_prop[nid][nreg] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
			}
            
            /*
            if (nid == bm->DIN_id)
                fprintf(llogfp, "Time: %e box%d-%d totbiom_DIN: %e NH3: %e dz: %e area: %e\n", bm->dayt, ij, k, bm->totbiom[nid], bm->boxes[ij].tr[k][pid], bm->boxes[ij].dz[k], bm->boxes[ij].area);
             */

		}

		pid = NO3_i;
		nid = bm->DIN_id;
		if(isDiagnostic == TRUE){
			bm->diagnosticBiom[sp] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
		}else{
			bm->totbiom[nid] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;

			if (isInitPops == TRUE) {
				bm->initreg_prop[nid][nreg] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
			} else {
				bm->reg_prop[nid][nreg] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
			}
            
            /*
            if (nid == bm->DIN_id)
                fprintf(llogfp, "Time: %e box%d-%d totbiom_DIN: %e NO3: %e dz: %e area: %e\n", bm->dayt, ij, k, bm->totbiom[nid], bm->boxes[ij].tr[k][pid], bm->boxes[ij].dz[k], bm->boxes[ij].area);
             */
            
		}

	}

	/* Only include benthos and epibenthics if not oceanic cell - oceanic cells should not be counted as their sediments are not dynamic */
	//if (isInitPops == TRUE || bm->boxes[ij].botz >= bm->maxwcbotz) {
	if (bm->boxes[ij].botz >= bm->maxwcbotz) {
		for (k = 0; k < bm->boxes[ij].sm.nz; k++) { // Loop through each sediment layer
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if(FunctGroupArray[sp].speciesParams[flag_id]){
					if(FunctGroupArray[sp].habitatCoeffs[SED] > 0){
						switch (FunctGroupArray[sp].groupAgeType) {
						case AGE_STRUCTURED:
							/* Do nothing  - this is not yet supported.*/
							break;
						case AGE_STRUCTURED_BIOMASS: /* intentional follow through */
						case BIOMASS:
							//TODO: Fix this.
							if (FunctGroupArray[sp].groupType != LG_PHY && FunctGroupArray[sp].groupType != SM_PHY) {
								for(n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++){
									pid = FunctGroupArray[sp].totNTracers[n];
									/* Calculate the biomass of this group in this cell */
									biomass = bm->boxes[ij].sm.tr[k][pid] * bm->boxes[ij].sm.dz[k] * bm->boxes[ij].area;

									if(isDiagnostic == TRUE){
										bm->diagnosticBiom[sp] += biomass;
									}else{

										bm->totbiom[sp] += biomass;
										bm->totagepop[sp][n] += biomass;

										if (isInitPops == TRUE) {
											if (FunctGroupArray[sp].isImpacted == TRUE)
												bm->targetspbiom[sp][ij] += biomass;
											bm->initreg_prop[sp][nreg] += biomass;
										} else {
											bm->reg_prop[sp][nreg] += biomass;
										}
									}
								}

								/**
								if((sp == bm->which_check) && (bm->checkstart <= bm->dayt) && ((bm->checkbox == ij) || (bm->checkbox > bm->nbox))){
									fprintf(llogfp, "Time: %e, in SED calc_box_biom %s-%d in box %d-%d totbiom[sp]: %e, biom = %e, area = %e, sed-dz = %e\n",
										bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, bm->totbiom[sp], bm->boxes[ij].sm.tr[k][pid], bm->boxes[ij].area, bm->boxes[ij].sm.dz[k]);
								}
								**/

							}
							break;

						}
					}
				}
			}
		}

		/* The eipbenthic layer */
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if(FunctGroupArray[sp].speciesParams[flag_id]){
				if (FunctGroupArray[sp].habitatType == EPIFAUNA){
					switch (FunctGroupArray[sp].groupAgeType) {
					case AGE_STRUCTURED:
						/* Do nothing  - this is not yet supported.*/
						break;
					case AGE_STRUCTURED_BIOMASS:
					case BIOMASS:
						for(cohort = 0; cohort <  FunctGroupArray[sp].numCohortsXnumGenes; cohort++){
							pid = FunctGroupArray[sp].totNTracers[cohort];
							/* Calculate the biomass of this group in this cell */
							biomass = bm->boxes[ij].epi[pid] * bm->boxes[ij].area;
                            
							if(isDiagnostic == TRUE){
								bm->diagnosticBiom[sp] += biomass;
							}else{
								bm->totbiom[sp] += biomass;
								bm->totagepop[sp][cohort] += biomass;

								if (isInitPops == TRUE) {
									if (FunctGroupArray[sp].isImpacted == TRUE)
										bm->targetspbiom[sp][ij] += biomass;
									bm->initreg_prop[sp][nreg] += biomass;
								} else {
									bm->reg_prop[sp][nreg] += biomass;
								}
							}
						}

						/**
						if((sp == bm->which_check) && (bm->checkstart <= bm->dayt) && ((bm->checkbox == ij) || (bm->checkbox > bm->nbox))){
							fprintf(llogfp, "Time: %e, in EPI calc_box_biom %s-%d in box %d-%d totbiom[sp]: %e, biom = %e, area = %e\n",
								bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, bm->totbiom[sp], bm->boxes[ij].epi[pid], bm->boxes[ij].area);
						}
						**/
						break;
					}
				}
			}
		}


		if(bm->ice_on){

			/* Ice layers  */
			for (k = 0; k < bm->boxes[ij].ice.nz; k++) { // Loop through each ice layer
				for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
					if(FunctGroupArray[sp].speciesParams[flag_id]){
						if(FunctGroupArray[sp].habitatCoeffs[ICE_BASED] > 0){
							switch (FunctGroupArray[sp].groupAgeType) {
							case AGE_STRUCTURED:
								/* Do nothing  - this is not yet supported.*/
								break;
							case AGE_STRUCTURED_BIOMASS: /* intentional follow through */
							case BIOMASS:
								for(n = 0; n < FunctGroupArray[sp].numCohorts; n++){
									pid = FunctGroupArray[sp].totNTracers[n];
									/* Calculate the biomass of this group in this cell */
									biomass = bm->boxes[ij].ice.tr[k][pid] * bm->boxes[ij].ice.dz[k] * bm->boxes[ij].area;


									if(isDiagnostic == TRUE){
										bm->diagnosticBiom[sp] += biomass;
									}else{

										bm->totbiom[sp] += biomass;
										bm->totagepop[sp][n] += biomass;

										if (isInitPops == TRUE) {
											if (FunctGroupArray[sp].isImpacted == TRUE)
												bm->targetspbiom[sp][ij] += biomass;
											bm->initreg_prop[sp][nreg] += biomass;
										} else {
											bm->reg_prop[sp][nreg] += biomass;
										}
									}
								}
								break;

							}
						}
					}
				}

			}
		}

	}

	if(bm->terrestrial_on){
		if(bm->boxes[ij].type == LAND){
			/* The land layer */
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if(FunctGroupArray[sp].speciesParams[flag_id]){
					if (FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){
						switch (FunctGroupArray[sp].groupAgeType) {
						case AGE_STRUCTURED:
							for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
								sn = FunctGroupArray[sp].structNTracers[n];
								rn = FunctGroupArray[sp].resNTracers[n];
								den = FunctGroupArray[sp].NumsTracers[n];
								biomass = (bm->boxes[ij].tr[0][sn] + bm->boxes[ij].tr[0][rn]) * bm->boxes[ij].tr[0][den];

								nums = bm->boxes[ij].tr[0][den];

								fprintf(bm->logFile, "land box %d, biomass = %e, sn = %e, rn = %e, den = %e\n", ij, biomass,
										bm->boxes[ij].tr[0][sn], bm->boxes[ij].tr[0][rn], bm->boxes[ij].tr[0][den]);

								if(isDiagnostic == TRUE){
									bm->diagnosticBiom[sp] += biomass;
								}else{
									bm->totbiom[sp] += biomass;
									bm->totagepop[sp][n] += biomass;
									bm->boxBiomass[ij][sp] += biomass;

									/**
									if((sp == bm->which_check) && (bm->checkstart <= bm->dayt) && ((bm->checkbox == ij) || (bm->checkbox > bm->nbox))){
										fprintf(llogfp, "TIme: %e in calc_box_biom %s-%d in box %d-%d totbiom[sp]: %.20e, sn = %.20e, rn = %.20e, den = %.20e\n",
											bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, bm->totbiom[sp], bm->boxes[ij].tr[k][sn],
											bm->boxes[ij].tr[k][rn], bm->boxes[ij].tr[k][den]);
									}
									**/

										if(bm->totbiom[sp] < 0){
											printf("sn = %e, rn = %e, den = %e\n", bm->boxes[ij].tr[0][sn], bm->boxes[ij].tr[0][rn], nums);
											quit("Biomass of %s:%d is less than zero after adding biomass from box%d:%d\n", FunctGroupArray[sp].groupCode, n, ij, k);
										}

									/* If this is the initPopulations call then do the extra steps */
									if (isInitPops == FALSE) {
										bm->reg_prop[sp][nreg] += biomass;
									} else {
										bm->initreg_prop[sp][nreg] += biomass;

										/* Need to store target species biomass here so can be used in calculations for Dan Holland's
										 economically based effort model (movement code not executed before Economics done, so need
										 to do the first round of values here first, so don't just end up with zero values everywhere
										 and no valid effort allocation).
										 */
										bm->targetspbiom[sp][ij] += biomass;

										totden[sp][n] += nums;

										bm->calcNstartPerPred[sp][hist_id] += nums;
										/**/
										if (bm->debug && ((bm->debug > debug_stock) && (sp == bm->which_check))) {
											fprintf(llogfp, "%s in land box %d contribs %.16f to totden:%d %e\n", FunctGroupArray[sp].groupCode, ij, nums, n,
													totden[sp][n]);
										}
										/**/

										/* Get initial young-of-the-year stock sizes - so can check
										 for artifical reseeding */
										stock_id = bm->group_stock[sp][ij][k];

										bm->stock_struct_prop[sp][n][stock_id] += nums;
										bm->calcTrackedMort[sp][n][stock_id][start_id] += nums;


										if (bm->debug && ((bm->debug == debug_stock) && ((sp == bm->which_check) || (sp == bm->move_check)))) {
											fprintf(llogfp, "sp: %s, adding: %e, stock-%d: %.12f, totden: %e\n", FunctGroupArray[sp].groupCode, nums,
													stock_id, bm->stock_struct_prop[sp][n][stock_id], totden[sp][n]);
										}

										/* Starting YOY */
										if (n < FunctGroupArray[sp].numGeneTypes)
											tot_yoy[sp][stock_id] += (FunctGroupArray[sp].boxPopRatio[ij][k][0][0] * (bm->boxes[ij].tr[0][sn] + bm->boxes[ij].tr[0][rn]) * nums);
									}

								}
							}

							break;
						case AGE_STRUCTURED_BIOMASS:
						case BIOMASS:
							quit("no support for land based inverts\n");
							break;
						}
					}
				}
			}
		}
	}
}

/**
 * Check that the group biomass in each box layer is valid.
 *
 * Will loop over each group and check that there is no biomass outside of the box layers that are
 * valid. If biomass is found a warning will be printed to stderr with an additional \n so it stands out.
 *
 *
 */
void Check_Layer_Initial_Biomass(MSEBoxModel *bm){

	int b, k, sp, n, sn, rn, den, pid;
	double biomass;


	/* Check for each group */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if(FunctGroupArray[sp].speciesParams[flag_id]){
			switch (FunctGroupArray[sp].groupAgeType) {
			case AGE_STRUCTURED:

				for (n = 0; n < FunctGroupArray[sp].numCohorts; n++) {
					sn = FunctGroupArray[sp].structNTracers[n];
					rn = FunctGroupArray[sp].resNTracers[n];
					den = FunctGroupArray[sp].NumsTracers[n];

					for (b = 0; b < bm->nbox; b++) {

						/* Check to see if we have negative biomass */
						for (k = 0; k < bm->boxes[b].nz; k++){
							biomass = (bm->boxes[b].tr[k][sn] + bm->boxes[b].tr[k][rn]) * bm->boxes[b].tr[k][den] * FunctGroupArray[sp].habitatCoeffs[WC];

							if(biomass < 0){
								fprintf(stderr, "ERROR: Data for group %s, cohort %d in box %d, layer %d in your initial conditions file. This biomass is NEGATIVE! = %e. Please update your initial conditions and try again.\n\n",
									FunctGroupArray[sp].groupCode, n, b, k, biomass);
								quit("");
							}

						}
						/* Check to see if we have biomass in layers that are not active */
						for (k = bm->boxes[b].nz; k < bm->wcnz; k++) {
							biomass = (bm->boxes[b].tr[k][sn] + bm->boxes[b].tr[k][rn]) * bm->boxes[b].tr[k][den] * FunctGroupArray[sp].habitatCoeffs[WC];

							if(biomass != 0){
								fprintf(stderr, "WARN: Data for group %s, cohort %d in box %d, layer %d in your initial conditions file. There are only %d layers in this box. Please check and updated your initial conditions file.\n\n",
									FunctGroupArray[sp].groupCode, n, b, k, bm->boxes[b].nz);
							}
						}
					}
				}
				break;
			case AGE_STRUCTURED_BIOMASS:
				if (FunctGroupArray[sp].groupType != REF_DET && FunctGroupArray[sp].groupType != LAB_DET) {
					for (n = 0; n < FunctGroupArray[sp].numCohorts; n++) {

						pid = FunctGroupArray[sp].totNTracers[n];
						for (b = 0; b < bm->nbox; b++) {

							/* Check to see if we have negative biomass */
							for (k = 0; k < bm->boxes[b].nz; k++){
								biomass = bm->boxes[b].tr[k][pid] * bm->boxes[b].dz[k] * bm->boxes[b].area * FunctGroupArray[sp].habitatCoeffs[WC];

								if(biomass < 0){
									fprintf(stderr, "ERROR: Data for group %s, cohort %d in box %d, layer %d in your initial conditions file. This biomass is NEGATIVE! = %e. Please update your initial conditions and try again.\n\n",
										FunctGroupArray[sp].groupCode, n, b, k, biomass);
									quit("");
								}
							}
							/* Check to see if we have biomass in layers that are not active */
							for (k = bm->boxes[b].nz; k < bm->wcnz; k++) {
								biomass = bm->boxes[b].tr[k][pid] * bm->boxes[b].dz[k] * bm->boxes[b].area * FunctGroupArray[sp].habitatCoeffs[WC];

								if(biomass != 0){
									fprintf(stderr, "WARN: Data for group %s, cohort %d in box %d, layer %d in your initial conditions file. There are only %d layers in this box. Please check and updated your initial conditions file.\n\n",
										FunctGroupArray[sp].groupCode, n, b, k, bm->boxes[b].nz);
								}
							}
						}
					}
				}
				break;
			case BIOMASS:
				if (FunctGroupArray[sp].groupType != REF_DET && FunctGroupArray[sp].groupType != LAB_DET) {

					pid = FunctGroupArray[sp].totNTracers[0];
					for (b = 0; b < bm->nbox; b++) {

						if(FunctGroupArray[sp].habitatCoeffs[WC] > 0){

							/* Check to see if we have negative biomass */
							for (k = 0; k < bm->boxes[b].nz; k++){
								biomass = bm->boxes[b].tr[k][pid] * bm->boxes[b].dz[k] * bm->boxes[b].area;
								if(biomass < 0){
									fprintf(stderr, "ERROR: Data for group %s in box %d, layer %d in your initial conditions file. This biomass is NEGATIVE! = %e. Please update your initial conditions and try again.\n\n",
										FunctGroupArray[sp].groupCode, b, k, biomass);
									quit("");
								}
							}
						/* Check to see if we have biomass in layers that are not active */
							for (k = bm->boxes[b].nz; k < bm->wcnz; k++) {
								biomass = bm->boxes[b].tr[k][pid] * bm->boxes[b].dz[k] * bm->boxes[b].area;

								if(biomass != 0){
									fprintf(stderr, "WARN: Data for group %s in box %d, layer %d in your initial conditions file. There are only %d layers in this box. Please check and updated your initial conditions file.\n\n",
										FunctGroupArray[sp].groupCode,  b, k, bm->boxes[b].nz);
								}
							}
						}
						if(FunctGroupArray[sp].habitatCoeffs[SED] > 0){

							/* Check to see if we have negative biomass */
							for (k = 0; k < bm->boxes[b].sm.nz; k++){
								biomass = bm->boxes[b].sm.tr[k][pid] * bm->boxes[b].sm.dz[k] * bm->boxes[b].area;
								if(biomass < 0){
									fprintf(stderr, "ERROR: Data for group %s in box %d, sediment layer %d in your initial conditions file. This biomass is NEGATIVE! = %e. Please update your initial conditions and try again.\n\n",
										FunctGroupArray[sp].groupCode, b, k, biomass);
									quit("");
								}
							}

							for (k = bm->boxes[b].sm.nz; k < bm->sednz; k++) {
								biomass = bm->boxes[b].sm.tr[k][pid] * bm->boxes[b].sm.dz[k] * bm->boxes[b].area;

								if(biomass != 0){
									fprintf(stderr, "WARN: Data for group %s in box %d, sediment layer %d in your initial conditions file. There are only %d sediment layers in this box. Please check and updated your initial conditions file.\n\n",
										FunctGroupArray[sp].groupCode,  b, k, bm->boxes[b].nz);
								}
							}

						}
					}
				}
				break;
			}
		}
	}
	/*
	 * Check the nutrient values as well.
	 */

	for(n = 0; n < bm->K_num_physiochem; n++){
		if(PhysioChemArray[n].ROCFunction != NULL){
			pid = *PhysioChemArray[n].tracerIndex;

			if(pid == MicroNut_i)	/* ignore */
				continue;

			for (b = 0; b < bm->nbox; b++) {
				if (bm->boxes[b].type != BOUNDARY) {
					if(pid != Det_Si_i){
						/* Check to see if we have biomass in layers that are not active */
						for (k = 0; k < bm->boxes[b].nz; k++) {
							if(bm->boxes[b].tr[k][pid] < small_num){
								warn("Nutrient %s is effectively 0 in box %d, layer %d in your initial conditions file. \n", PhysioChemArray[n].name, b, k);
							}
						}
					}
					/* Now check the sediments */
					for (k = 0; k < bm->boxes[b].sm.nz; k++) {

						if(bm->boxes[b].sm.tr[k][pid] < small_num){
							warn("Nutrient %s is effectively 0 in box %d, sediment layer %d in your initial conditions file. \n", PhysioChemArray[n].name, b, k);
						}
					}
				}
			}
		}
	}
}

/**
 * \brief Routine to determine current overall biomass per group
 *
 *	Assumes that call_type of 0 wants info across the model domain, and
 *	a call_type of 1 is box specific
 *
 * 	call_type
 *		-2 - Indicated that the model is coming to an end.
 *		-1 - The annual call.
 *		0 - Non-annual call
 *		1 - Box specific information.
 */
void Ecology_Calculate_Total_Abundance(MSEBoxModel *bm, double dt, int call_type, FILE *llogfp) {

	int ij, k, n, sp, nreg, flagstockout;
	int ncells = bm->nbox;
	int totnum = bm->K_num_tot_sp + 1; // The +1 is for DIN
	double coverindx, regtot;
	int cohort;
	int isDiagnostic = call_type>0?1:0;

	flagstockout = 0;

	if (verbose > 0)
		printf("Doing Ecology_Calculate_Total_Abundance\n");


	if (call_type < -1)
		bm->coming_to_end = 1;
	else
		bm->coming_to_end = 0;

	/* Identify annual call and reset to global so correct calculations done,
	 also set flagstockout to indicate need to write out Virgin Biomass file */
	if (call_type < 0) {
		call_type = 0;
		flagstockout = 2;
	}
    
	/* Biomass info needed for effort management */
	if (bm->need_pops) {
		for (sp = 0; sp < totnum; sp++) {

			if(isDiagnostic){
				bm->diagnosticBiom[sp] = 0.0;
			}else{
				bm->totbiom[sp] = 0.0;
				bm->totfishpop[sp] = 0.0;

				for(ij = 0; ij < bm->nbox; ij++)
					bm->boxBiomass[ij][sp] = 0;

				for (nreg = 0; nreg < bm->K_num_active_reg; nreg++)
					bm->reg_prop[sp][nreg] = 0.0;

				for (ij = 0; ij < bm->K_num_max_cohort * bm->K_num_max_genetypes; ij++)
					bm->totagepop[sp][ij] = 0.0;
                
			}
		}

		/* Add in migrators if they exist - will not be run when doing a diagnostic call.*/
		if (!call_type) {

			/* Vertebrates */
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].isVertebrate == TRUE) {

					for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
						for (ij = 0; ij < MIGRATION[sp].num_in_queue; ij++) {
							bm->totbiom[sp] += (MIGRATION[sp].SN[n][ij] + MIGRATION[sp].RN[n][ij]) * MIGRATION[sp].DEN[n][ij];
							bm->totagepop[sp][n] += (MIGRATION[sp].SN[n][ij] + MIGRATION[sp].RN[n][ij]) * MIGRATION[sp].DEN[n][ij];


							/**
							if((sp == bm->which_check) && (bm->dayt >= bm->checkstart)){
								fprintf(llogfp, "%e, in calc_tot_abund %s-%d MIG%d totbiom: %e, MIGsn = %e, MIGrn = %e, MIGden = %e\n",
									bm->dayt, FunctGroupArray[sp].groupCode, n, ij, bm->totbiom[sp], MIGRATION[sp].SN[n][ij], 
									 MIGRATION[sp].RN[n][ij], MIGRATION[sp].DEN[n][ij]);
							}
							**/

							/* No regional contributions considered */
							if(bm->totbiom[sp] < 0){
								printf("migration SN = %e, RN = %e, DEN = %e\n", MIGRATION[sp].SN[n][ij], MIGRATION[sp].RN[n][ij], MIGRATION[sp].DEN[n][ij]);
								quit("Biomass of %s:%d is less than zero after adding migration\n", FunctGroupArray[sp].groupCode, n);
							}


						}
					}
				}else{
					if(FunctGroupArray[sp].sp_geo_move == TRUE){
						for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
							for (ij = 0; ij < MIGRATION[sp].num_in_queue; ij++) {
								bm->totbiom[sp] += MIGRATION[sp].DEN[cohort][ij];
								bm->totagepop[sp][cohort] += MIGRATION[sp].DEN[cohort][ij];

								/* No regional contributions - considered */

								if(bm->totbiom[sp] < 0){
									printf("migration DEN = %e\n", MIGRATION[sp].DEN[cohort][ij]);
									quit("Biomass of %s:%d is less than zero after adding migration\n", FunctGroupArray[sp].groupCode, cohort);
								}

							}
						}
					}
				}
			}
		}
        
		/** Work out the total biomass in the model domain for all groups, the biomass
		 per box for the groups targeted by fisheries and the ecological indicators **/

		/* Initialise the ecological indicators */
		bm->ecolindx[PDratio_id] = 0;
		bm->ecolindx[FPFVratio_id] = 0;
		bm->ecolindx[DivCount_id] = 0;
		bm->ecolindx[InfEpi_id] = 0;
		bm->ecolindx[coverindx_id] = 0;
		coverindx = 0;

		for (ij = 0; ij < ncells; ij++) {
			nreg = bm->regID[ij];

			if ((!call_type && bm->boxes[ij].type != BOUNDARY) || (call_type && ij == bm->current_box)) {

				/* Calculate the biomass of each functional group in this box */
				Calculate_Box_Biomass(bm, llogfp, ij, nreg, FALSE, isDiagnostic);

				if (call_type) {
					break;
				}

				//	fprintf(llogfp, "bm->diagnost[ij][DivCount_i] = %.20e\n", bm->diagnost[ij][DivCount_i]);
				/* Ecological indicators */
				bm->ecolindx[PDratio_id] += bm->diagnost[ij][PelDem_ratio_i] / (bm->nbox - bm->nboundary - bm->nland);
				bm->ecolindx[FPFVratio_id] += bm->diagnost[ij][PiscPlank_ratio_i] / (bm->nbox - bm->nboundary - bm->nland);
				bm->ecolindx[DivCount_id] += bm->diagnost[ij][DivCount_i] / (bm->nbox - bm->nboundary - bm->nland);
				//fprintf(llogfp, "bm->ecolindx[DivCount_id] = %.20e\n", bm->ecolindx[DivCount_id]);
				bm->ecolindx[InfEpi_id] += bm->diagnost[ij][InfEpi_ratio_i] / (bm->nbox - bm->nboundary - bm->nland);
				for (k = 0; k < bm->K_num_tot_sp; k++) {
					if(FunctGroupArray[k].speciesParams[flag_id] == TRUE){
						if (FunctGroupArray[k].CoverTracer != -1) {
							coverindx += bm->boxes[ij].epi[FunctGroupArray[k].CoverTracer];
						}
					}
				}
				bm->ecolindx[coverindx_id] += coverindx / (bm->nbox - bm->nboundary - bm->nland);

				/*
				 fprintf(llogfp,"PelDem_ratio_i: %d, PiscPlank_ratio_i: %d, DivCount_i: %d, InfEpi_ratio_i: %d\n",
				 PelDem_ratio_i, PiscPlank_ratio_i, DivCount_i, InfEpi_ratio_i);
				 fprintf(llogfp,"Time: %e, ij: %d, PD: %e, FPFV: %e, Div: %e, IE: %e, cover: %e, denom: %d (box: %d, boundary: %d)\n",
				 bm->dayt, ij, bm->diagnost[ij][PelDem_ratio_i], bm->diagnost[ij][PiscPlank_ratio_i], bm->diagnost[ij][DivCount_i], bm->diagnost[ij][InfEpi_ratio_i], bm->ecolindx[coverindx_id], (bm->nbox - bm->nboundary - bm->nland), bm->nbox, bm->nboundary);
				 */
			}
		}

		/* Only update the other arrays if a global call not a local debugging call */
		if (!call_type) {
			bm->ecolindx[BSSslope_id] = 0;

			/* Current total population size */
			for (sp = 0; sp < totnum; sp++) {
				bm->totfishpop[sp] = bm->totbiom[sp];

				/** Regional contributions **/
				/* As no migrators considered for the regional proportions - as yet - then
				 sum here as regtot may not equal totbiom (which includes migrators)
				 */
				regtot = 0;
				for (nreg = 0; nreg < bm->K_num_active_reg; nreg++) {
					regtot += bm->reg_prop[sp][nreg];
				}
				/* Make reg_prop trully proportions */
				for (nreg = 0; nreg < bm->K_num_active_reg; nreg++) {
					bm->reg_prop[sp][nreg] = bm->reg_prop[sp][nreg] / (regtot + small_num);
				}
			}
			if(bm->smallID != -1 && bm->largeID != -1){
				/* Find BSS - numerator and denominator to be all in kg in calculation */
				bm->ecolindx[BSSslope_id] = ((bm->totfishpop[bm->smallID] - bm->totfishpop[bm->largeID]) * bm->X_CN * mg_2_tonne) / (log(bm->smallsize) - log(
						bm->largesize) + small_num);
			}
			if ((bm->debug == debug_biology_process) && (bm->dayt >= bm->checkstart) && (bm->dayt < bm->checkstop)) {
				fprintf(llogfp,
						"BSSslope: %e, fishpop[small-%s]: %e, fishpop[large-%s]: %e, log(smallsize): %e, smallsize: %e, log(largesize): %e, largesize: %e\n",
						bm->ecolindx[BSSslope_id], FunctGroupArray[bm->smallID].groupCode, bm->totfishpop[bm->smallID], FunctGroupArray[bm->largeID].groupCode,
						bm->totfishpop[bm->largeID], (double)log(bm->smallsize), bm->smallsize, (double)log(bm->largesize), bm->largesize);
			}

			/* If not an annual call then do all other necessary checks */
			if (!flagstockout) {
				/* If need to reinitialise populations do so now */
				if (bm->flagreinitpop && bm->dayt == bm->reinit_pop_day) {
					for (sp = 0; sp < totnum; sp++)
						bm->totinitpop[sp] = bm->totfishpop[sp];
				}

				/* Determine whether stock so depressed would trigger "recovery pulse" in stock
				 recruitment model 7 - Beverton Holt with "encouraged recovery" 
				if ((bm->TofY == 0) && bm->flagday) {
					fprintf(llogfp, "\n");
				}
                */

			    if (bm->t >= bm->tsumoutnext && bm->t > 0 && bm->TofY != 0){
					 /* Added for 2-03-2011 For Gary Griffith to enable advanced analysis */
					if (flagstockout != 2){
						Write_Biomass(bm);
					}
				}

				if (bm->t >= bm->tsumoutnext || bm->t > bm->tstop - 86400.0) {
				//if (bm->t > bm->tsumoutnext || bm->t > bm->tstop - 86400.0) {
					/* Every tsumout days of the run give stock state summary */
					flagstockout = 1;
					bm->tsumoutnext = bm->t + bm->tsumout;

				}
			}
		}
        
		/* If annual call write to Biom.txt file */
		if (flagstockout == 2) {
			Write_Biomass(bm);
			return;
		}

		/* If non-annual call proceed with standard log.txt output */
		if ((flagstockout == 1) || call_type) {


			//fprintf(llogfp, "\n");

			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].isDetritus == TRUE || (FunctGroupArray[sp].isDetritus == FALSE
						&& (int) (FunctGroupArray[sp].speciesParams[flag_id]))) { /* Allow for DIN */

					Print_Biomass_Value(bm, call_type, llogfp, sp);
				}
			}

			/* Now print out DIN value */
			Print_Biomass_Value(bm, call_type, llogfp, bm->K_num_tot_sp);

			if (!bm->flagannual_Mest) {
				Ecology_Output_Mort_Per_Pred_Estimates(bm, llogfp);
			}
		}
        
		if (flagstockout)
			Check_Gape(bm, llogfp);

		if (!call_type) {
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].isVertebrate == TRUE) {
					if ((bm->TofY == 0) && bm->flagday) {
						if ((recover_trigger * bm->totinitpop[sp]) < bm->totfishpop[sp])
							recover_help[sp][0] = 0;
						else {
							if (!recover_help[sp][0]) {
								recover_help[sp][0] = 1;
								recover_help[sp][1] = 1;
								recover_help_set[sp] = bm->dayt;
							}
						}
					}
				}
			}
		}
	}
	return;
}

/**
 *	Routines to output absolute and relative biomass files to text file
 *
 */

void Open_Ecology_Output_Files(MSEBoxModel *bm) {

	/* Overall file */
	vbiomfp = Init_VirginBiom_File(bm);
	/* Regional files */
	if (bm->K_num_stocks_per_sp > 1)
		vbiomRfp = Init_Regional_Biomass_File(bm);

	/* Spawning stock biomass for vertebrates */
	SSBfp = Init_SSB_File(bm);
	/* Recruits for vertebrate stocks */
	yoyfp = Init_YOY_File(bm);
	/* Mortality estimates - simple overall estimates */
	mortfp = Init_MortEst_File(bm);
	/* Specific mortality estimates */
	specificmortfp = Init_SpecificMortEst_File(bm);
	/* Mortality estimates - per predator estimates */
	mortppfp = Init_MortPerPredEst_File(bm);
	specificmortppfp = Init_SpecificPredMortEst_File(bm);
	/* Mortality estimates - simple overall estimates */
	dietCheckfp = Init_DietCheck_File(bm);
    if(bm->flagdietcheck)
    	detaileddietCheckfp = Init_DetailedDietCheck_File(bm);

    if (bm->flag_macro_model)
		vbiomSfp = Init_MacrophyteBiom_File(bm);

	if (bm->flag_age_output) {
		vbiomAgefp = Init_AgeBiom_File(bm);
        vbiomAnnAgefp = Init_AnnualAgeBiom_File(bm);
    }

	/* If the sun light hours flag is set to true then print out sun hours info to help people */
	if(bm->lim_sun_hours){
		boxLightFP = Init_BoxLight_File(bm);
	}

	/* Initialise evolution file if necessary */
	if(bm->flag_do_evolution){
		evolfp = Init_Evol_File(bm);
	}

	boxBiomassfp  = Init_BoxBiomass_File(bm);
}

void Close_Ecology_Output_Files(MSEBoxModel *bm) {

	Util_Close_Output_File(vbiomfp);
	Util_Close_Output_File(vbiomRfp);
	Util_Close_Output_File(SSBfp);
	Util_Close_Output_File(yoyfp);
	Util_Close_Output_File(mortfp);
	Util_Close_Output_File(mortppfp);
	Util_Close_Output_File(specificmortfp);
	Util_Close_Output_File(specificmortppfp);
	Util_Close_Output_File(dietCheckfp);
	Util_Close_Output_File(migrationfp);
	Util_Close_Output_File(sizeDataFP);
	Util_Close_Output_File(boxBiomassfp);
    
    if(bm->flagdietcheck)
        Util_Close_Output_File(detaileddietCheckfp);

    if (bm->flag_macro_model)
		Util_Close_Output_File(vbiomSfp);
    if (bm->flag_age_output) {
        Util_Close_Output_File(vbiomAgefp);
        Util_Close_Output_File(vbiomAnnAgefp);
    }
	if(bm->lim_sun_hours){
		Util_Close_Output_File(boxLightFP);
	}
	if(bm->track_contaminants){
		Contaminant_Close_Contact_Record(bm);
	}
	if(bm->flag_do_evolution){
		Util_Close_Output_File(evolfp);
	}

}
/**
 *	\brief This writes out all the perfect knowledge overall biomass
 *	and indicator output
 *
 */
static void Write_Biomass(MSEBoxModel *bm) {

	if (verbose)
		fprintf(stderr, "Writing relative biomass output (instead of puting it in a logfile)\n");

	/** Check that the files have been opened already */
	if (vbiomfp == NULL)
		quit("Error Ecology:  Open_Ecology_Output_Files must be called before Write_VirginBiom\n");

	/** Write output **/
	/* Overall file */
	Write_VirginBiomass(vbiomfp, bm);

	/* Regional files */
	if (bm->K_num_stocks_per_sp > 1) {
		Write_Regional_Biomass(vbiomRfp, bm);
	}

	/* Write age structured files */
	if(bm->flag_age_output){
        Write_AgeBiomass(vbiomAgefp, bm);
        Write_AnnualAgeBiomass(vbiomAnnAgefp, bm);
	}

	/* Write macrophyte files */
	if(bm->flag_macro_model){
		Write_MacrophyteBiomass(vbiomSfp, bm);
	}

	/* Spawning stock biomass for vertebrates */
	Write_SSB(SSBfp, bm);

	/* Recruits for vertebrate stocks */
	Write_YOY(yoyfp, bm);

	Output_Size_Data(bm);
	Output_Migration_Data(bm);

	Write_BoxBiomass(boxBiomassfp, bm);

	Output_Diet_Check(bm);

	if(bm->lim_sun_hours){
		Write_BoxLight(boxLightFP, bm);
	}

	/* Write out evolution */
	if(bm->flag_do_evolution){
		Write_Evolution(evolfp, bm, bm->logFile);
	}

	if(bm->track_contaminants){
		Contaminant_Write_Contact_Record(bm);
	}

	return;
}

/**
 *	\brief Routines to initialise the v Biomass information file
 *
 */
static FILE * Init_VirginBiom_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp;
#ifdef PRINT_AGE_STRUCTURED
	int n;
#endif

	/** Create filename **/
	sprintf(fname, "%sBiomIndx.txt", bm->startfname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_VirginBiom_File: Can't open %s\n",fname);

	/** Column definitions **/
    fprintf(fid, "Time");

	/* Absolute values
	 *  The +1 is for DIN
	 */
	for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {

		if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
				|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
			if(sp < bm->K_num_tot_sp ){
#ifdef PRINT_AGE_STRUCTURED
				if(FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS){
					for(n = 0; n < FunctGroupArray[sp].numCohorts; n++){
						fprintf(fid, " %s-%d", FunctGroupArray[sp].groupCode, n);
					}
				}else{
					fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
				}
#else
					fprintf(fid, " %s", FunctGroupArray[sp].groupCode);

#endif

			}else{
				fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
			}
		}
	}
	/* Relative values */
	for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
		if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
				|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
			fprintf(fid, " Rel%s", FunctGroupArray[sp].groupCode);
		}
	}

	/* Write ecological indicators */
	for (sp = 0; sp < K_num_ecol_indx; sp++) {
		fprintf(fid, " %s", bm->ecolindxNAME[sp]);
	}

	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *	\brief Routines to write data to the V Biomass information file
 *
 */
static void Write_VirginBiomass(FILE *fid, MSEBoxModel *bm) {
	int sp;

#ifdef PRINT_AGE_STRUCTURED
	int n;
#endif


	if (verbose > 1)
		fprintf(stderr, "Write total biomass information\n");

	/* Write time */
	fprintf(fid, "%e", bm->dayt);

	//TODO: Fix - ugly but works
	/* Write absolute values
	 * The +1 is for DIN
	 * */
	for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
		if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
				|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
			if(sp < bm->K_num_tot_sp ){
#ifdef PRINT_AGE_STRUCTURED

				if(FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS){
					for(n = 0; n < FunctGroupArray[sp].numCohorts; n++){
						fprintf(fid, " %f", bm->totagepop[sp][n] * bm->X_CN * mg_2_tonne);
					}
				}else{
					fprintf(fid, " %f", bm->totfishpop[sp] * bm->X_CN * mg_2_tonne);
				}
#else
					fprintf(fid, " %f", bm->totfishpop[sp] * bm->X_CN * mg_2_tonne);

#endif

			}else{
				fprintf(fid, " %f", bm->totfishpop[sp] * bm->X_CN * mg_2_tonne);
			}
		}
	}

	/* Write relative values */
	for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
		if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
				|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
			if (!bm->totinitpop[sp]) {
				fprintf(fid, " %f", (double) 1.0);
			} else {
				fprintf(fid, " %f", bm->totfishpop[sp] / bm->totinitpop[sp]);
			}
		}
	}

	/* Write ecological indicators */
	for (sp = 0; sp < K_num_ecol_indx; sp++) {
		fprintf(fid, " %f", bm->ecolindx[sp]);
	}

	fprintf(fid, "\n");

	return;
}

/**
 *
 *	\brief Routine to initialise the regional biomass file
 *
 */
static FILE * Init_Regional_Biomass_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp;

	/** Create filename **/
	sprintf(fname, "%sBiomReg.txt", bm->startfname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_Regional_Biomass_File: Can't open %s\n",fname);

    /** Column definitions **/
	fprintf(fid, "Time Reg ");

	/* Absolute values
	 *  The +1 is for DIN
	 */
	for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
		if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
				|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
			fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
		}
	}

	/* Relative values */
	for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
		if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
				|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
			fprintf(fid, " Rel%s", FunctGroupArray[sp].groupCode);
		}
	}

	/* Write ecological indicators */
	for (sp = 0; sp < K_num_ecol_indx; sp++) {
		fprintf(fid, " %s", bm->ecolindxNAME[sp]);
	}

	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *
 *	\brief Routine to write out the data to the regional biomass file
 *
 */
static void Write_Regional_Biomass(FILE *fid, MSEBoxModel *bm) {
	int sp, nreg;

	if (verbose > 1)
		fprintf(stderr, "Write regional biomass information\n");

	for (nreg = 0; nreg < bm->K_num_active_reg; nreg++) {

		/* Write time */
		fprintf(fid, "%e", bm->dayt);

		/* Write region */
		fprintf(fid, " %d", nreg);

		/* Write absolute values
		 * The +1 is for DIN
		 */
		for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
			if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
					|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
				fprintf(fid, " %f", bm->totfishpop[sp] * bm->reg_prop[sp][nreg] * bm->X_CN * mg_2_tonne);
			}
		}

		/* Write relative values */
		for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
			if (sp == bm->K_num_tot_sp || (sp < bm->K_num_tot_sp && (FunctGroupArray[sp].isDetritus == TRUE
					|| (FunctGroupArray[sp].isDetritus == FALSE && (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
				if (!bm->totinitpop[sp] || !bm->initreg_prop[sp][nreg]) {
					fprintf(fid, " %f", (double) 1.0);
				} else {
					fprintf(fid, " %f", bm->totfishpop[sp] * bm->reg_prop[sp][nreg] / (bm->totinitpop[sp] * bm->initreg_prop[sp][nreg]));
				}
			}
		}

		/* Leave space to write ecological indicators */
		for (sp = 0; sp < K_num_ecol_indx; sp++) {
			fprintf(fid, " ");
		}

		fprintf(fid, "\n");
	}
	return;
}

/**
 *
 *	\brief Routine to initialise the recruits per year files
 *
 */
static FILE * Init_YOY_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp, flag_sp, stock;

	/** Create filename **/
	sprintf(fname, "%sYOY.txt", bm->startfname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_YOY_File: Can't open %s\n",fname);

    /** Column definitions **/
	fprintf(fid, "Time");

	/* Active group names */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
			if (flag_sp) {
				for (stock = 0; stock < FunctGroupArray[sp].numStocks; stock++) {
					/* Write stock */
					fprintf(fid, " %s-%d", FunctGroupArray[sp].groupCode, stock);
				}
			}
		}
	}
	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}
/**
 *
 *	\brief Routine to write out the data to the recruits per year files
 *
 */
static void Write_YOY(FILE *fid, MSEBoxModel *bm) {
	int sp, flag_sp, stock;

	if (verbose > 1)
		fprintf(stderr, "Write YOY information\n");

	/* Write time */
	fprintf(fid, "%e", bm->dayt);

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
			if (flag_sp) {
				for (stock = 0; stock < FunctGroupArray[sp].numStocks; stock++) {
					/* Write YOY values - biomass values.*/
					fprintf(fid, " %f", tot_yoy[sp][stock] * bm->X_CN * mg_2_tonne);
				}
			}
		}
	}
	fprintf(fid, "\n");

	return;
}

/**
 *
 *	\brief Routine to initialise the spawning stock files
 *
 */
static FILE * Init_SSB_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp, flag_sp;

	/** Create filename **/
	sprintf(fname, "%sSSB.txt", bm->startfname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_SSB_File: Can't open %s\n",fname);

    /** Column definitions **/
	fprintf(fid, "Time ");

	/* Active group names */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
			if (flag_sp) {
				fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
			}
		}
	}
	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *
 *	\brief Routine to write out the data to the spawning stock files
 *
 */
static void Write_SSB(FILE *fid, MSEBoxModel *bm) {
	int sp, flag_sp;

	if (verbose > 1)
		fprintf(stderr, "Write YOY information\n");

	/* Write time */
	fprintf(fid, "%e", bm->dayt);

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			/* Write SSB values */
			flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
			if (flag_sp) {
				fprintf(fid, " %f", bm->tot_SSB[sp] * bm->X_CN * mg_2_tonne);
			}
		}
	}
	fprintf(fid, "\n");

	return;
}

/**
 *
 *	\brief This routine calls routines to output simple mortality arrays
 *
 */
void Ecology_Output_Mort_Estimates(MSEBoxModel *bm, FILE *llogfp) {

	Write_Mort(mortfp, bm);
	Write_SpecificMort(specificmortfp, bm);

	return;

}
/**
 *
 *	\brief This routine calls routines to output mortality per predator arrays
 *
 */
void Ecology_Output_Mort_Per_Pred_Estimates(MSEBoxModel *bm, FILE *llogfp) {

	Write_MortPerPred(mortppfp, bm);
	Write_SpecificPredMort(specificmortppfp, bm);

	return;

}
/**
 *
 *	\brief Routine to initialise the simple mortality files
 *
 */
static FILE * Init_MortEst_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int totnum = bm->K_num_tot_sp;
	int sp, flag_sp;

	/** Create filename **/
	sprintf(fname, "%sMort.txt", bm->startfname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_MortEst_File: Can't open %s\n",fname);

    /** Column definitions **/
	fprintf(fid, "Time");

	/* Active group names for M and F */
	for (sp = 0; sp < totnum; sp++) {
		flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
		if (flag_sp) {
			fprintf(fid, " %s-M", FunctGroupArray[sp].groupCode);
		}
	}
	for (sp = 0; sp < totnum; sp++) {
		flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
		if (flag_sp) {
			fprintf(fid, " %s-F", FunctGroupArray[sp].groupCode);
		}
	}
	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *
 *	\brief Routine to write out the data to the simple gross mortality files
 *
 */
static void Write_Mort(FILE *fid, MSEBoxModel *bm) {
	int sp, flag_sp, update_date;
	double catch_N = 0.0, start_N = 0.0, natDead_N = 0.0, mort_scale = 0.0, Fest = 0.0, Mest = 0.0;

	if (verbose > 1)
		fprintf(stderr, "Write mortality estimates\n");

	/* Write time */
	fprintf(fid, "%e", bm->dayt);

	/* Write natural mortality values */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
		if (flag_sp) {
			update_date = (int) (FunctGroupArray[sp].speciesParams[calcupdate_date_id]);
			if ((bm->dayt > 367.0) && (update_date > 182)) {
				/* If restarted records within last 6 months use previous
				 year's records as more complete */
				start_N = bm->calcNstart[sp][hist_id];
				natDead_N = bm->calcMnum[sp][hist_id];
				mort_scale = 1.0;
			} else {
				/* If restart records early each year then current records should be sufficent
				 Or if this is the first year then have no choice! */
				start_N = bm->calcNstart[sp][expect_id];
				natDead_N = bm->calcMnum[sp][expect_id];
				mort_scale = 365.0 / (365.0 - update_date);
			}

			Mest = mort_scale * (natDead_N / (start_N + small_num));
			fprintf(fid, " %e", Mest);
		}
	}
	/* Write F values */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
		if (flag_sp) {
			update_date = (int) (FunctGroupArray[sp].speciesParams[calcupdate_date_id]);
			if ((bm->dayt > 367.0) && (update_date > 182)) {
				/* If restarted records within last 6 months use previous
				 year's records as more complete */
				start_N = bm->calcNstart[sp][hist_id];
				catch_N = bm->calcFnum[sp][hist_id];
				mort_scale = 1.0;
			} else {
				/* If restart records early each year then current records should be sufficent
				 Or if this is the first year then have no choice! */
				start_N = bm->calcNstart[sp][expect_id];
				catch_N = bm->calcFnum[sp][expect_id];
				mort_scale = 365.0 / (365.0 - update_date);
			}
			Fest = mort_scale * (catch_N / (start_N + small_num));
			fprintf(fid, " %e", Fest);
		}
	}
	fprintf(fid, "\n");

	return;
}

/**************************************************************************//**
 *
 *	\brief Routine to initialise the specific mortality files
 *
 *****************************************************************************/
FILE * Init_SpecificMortEst_File(MSEBoxModel *bm)
{
    FILE *fid;
    char fname[BMSLEN];
    int totnum = bm->K_num_tot_sp;
    int sp, flag_sp, cohort, stock;

    /** Create filename **/
    sprintf(fname,"%sSpecificMort.txt",bm->startfname);
    printf("Creating %s\n",fname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("initMortFile: Can't open %s\n",fname);

    /** Column definitions **/
    fprintf(fid,"Time");

    /* Active group names for M and F */
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
        	for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
        			fprintf(fid, " %s-%d-S%d-M1", FunctGroupArray[sp].groupCode, cohort, stock);
        		}
        	}
        }
    }
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
        	for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
        			fprintf(fid, " %s-%d-S%d-M2", FunctGroupArray[sp].groupCode, cohort, stock);
        		}
        	}
        }
    }
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
        	for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
        			fprintf(fid, " %s-%d-S%d-F", FunctGroupArray[sp].groupCode, cohort, stock);
        		}
        	}
        }
    }
    fprintf(fid,"\n");

    /* Return file pointer */
    return(fid);
}


/**************************************************************************//**
 *
 *	\brief Routine to write out the data to the simple gross mortality files
 *
 *****************************************************************************/
static void Write_SpecificMort(FILE *fid, MSEBoxModel *bm)
{
    int sp = 0, flag_sp = 0, stock = 0, cohort = 0;
    int totnum = bm->K_num_tot_sp;

    if ( verbose > 1)
        fprintf(stderr,"Write mortality estimates\n");

    /* Write time */
    fprintf(fid,"%e", bm->dayt);

	/* Write natural mortality values */
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
        	for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
        			fprintf(fid," %e", bm->calcTrackedMort[sp][cohort][stock][finalM1_id]);
        		}
        	}
        }
    }
	/* Write predation mortality values */
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
        	for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
        			fprintf(fid," %e", bm->calcTrackedMort[sp][cohort][stock][finalM2_id]);
        		}
        	}
        }
    }
	/* Write F values */
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
        	for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
        			fprintf(fid," %e", bm->calcTrackedMort[sp][cohort][stock][finalF_id]);
        		}
        	}
        }
    }
    fprintf(fid,"\n");

    return;
}

/**************************************************************************//**
 *
 *	\brief Routine to initialise the specific predation mortality files
 *
 *****************************************************************************/
static FILE * Init_SpecificPredMortEst_File(MSEBoxModel *bm)
{
    FILE *fid;
    char fname[BMSLEN];
    int totnum = bm->K_num_tot_sp;
    int sp, flag_sp;

    /** Create filename **/
    sprintf(fname,"%sSpecificPredMort.txt",bm->startfname);
    printf("Creating %s\n",fname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("initMortFile: Can't open %s\n",fname);

    /** Column definitions **/
    fprintf(fid,"Time Group Cohort Stock");

    /* Active group names for age specific M */
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
			fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
        }
    }
    fprintf(fid,"\n");

    /* Return file pointer */
    return(fid);
}


/**************************************************************************//**
 *
 *	\brief Routine to write out the data to the ahe specific mortality per predator files
 *
 *****************************************************************************/
static void Write_SpecificPredMort(FILE *fid, MSEBoxModel *bm)
{
    int sp = 0, flag_sp = 0, flag_sppred = 0, stock = 0, cohort = 0, pred = 0;
    int totnum = bm->K_num_tot_sp;

    if ( verbose > 1)
        fprintf(stderr,"Write mortality estimates\n");

    for (sp=0; sp<totnum; sp++) {
        flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
       	for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
                    /* Write time */
                    fprintf(fid,"%e %s %d %d", bm->dayt, FunctGroupArray[sp].groupCode, cohort, stock);

        			/* Write natural mortality values */
        			for (pred=0; pred<totnum; pred++) {
                        flag_sppred = (int) (FunctGroupArray[pred].speciesParams[flag_id]);
                        if (flag_sppred) {
                            fprintf(fid," %e", bm->calcTrackedPredMort[sp][cohort][stock][pred][final_id]);
                        }
        			}
        			fprintf(fid,"\n");
        		}
        	}
        }
    }

    return;
}

/**********************************************************//*****
 *
 *	\brief Routine to initialise the mortality per predator files
 *
 */
static FILE * Init_MortPerPredEst_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int totnum = bm->K_num_tot_sp;
	int sp, flag_sp;

	/** Create filename **/
	sprintf(fname, "%sMortPerPred.txt", bm->startfname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_MortPerPredEst_File: Can't open %s\n",fname);

    /** Column definitions **/
	fprintf(fid, "Note rows are prey, columns are predators - all groups printed out as predator and prey for convenience (if not a consumer)\n");
	fprintf(fid,"Time ");
	fprintf(fid, "Prey");
	fprintf(fid, " startN");
	fprintf(fid, " mL");
	fprintf(fid, " mQ");
	if(bm->external_mortality){
		fprintf(fid, " mE");
	}
	fprintf(fid, " implicitMortality");

	/* Active group names for M and F */
	for (sp = 0; sp < totnum; sp++) {
		flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
		if (flag_sp) {// && FunctGroupArray[sp].isPredator == TRUE) {
			fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
		}
	}
	fprintf(fid, " TotalPredMort");
	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *
 *	\brief Routine to write out the data to the mortality per predator files
 *
 *	The values written out should be a percentage of the groups biomass or total numbers.
 *
 *
 */
static void Write_MortPerPred(FILE *fid, MSEBoxModel *bm) {
	int sp, flag_sp, update_date, caseid, pred;
	int totnum = bm->K_num_tot_sp;
	double start_N = 0.0, natDead_N = 0.0, mort_scale = 0.0, Mest = 0.0, scale_denom, total = 0.0;
	double totalPredMort = 0;

	if (verbose > 1)
		fprintf(stderr, "Write mortality estimates\n");

	/* Write time */
	fprintf(fid, "Time: %e\n", bm->dayt);

	/* Write mortality per pred values */
	for (sp = 0; sp < totnum; sp++) {
		flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
		if (flag_sp) {
			totalPredMort = 0.0;
			fprintf(fid,"%e ", bm->dayt);
			fprintf(fid, "%s", FunctGroupArray[sp].groupCode);
			update_date = (int) (FunctGroupArray[sp].speciesParams[calcupdate_date_id]);

			mort_scale = 1.0;
			if (bm->flagannual_Mest || ((bm->dayt > 367.0) && (update_date > 182))) {
				/* If restarted records within last 6 months use previous
				 year's records as more complete */
				start_N = bm->calcNstartPerPred[sp][hist_id];
				caseid = hist_id;
				mort_scale = 1.0;
			} else {
				/*
				 If restart records early each year then current records should be sufficient,
				 or if this is the first year then have no choice (!),
				 or this is actually coming out more frequently than annually (probably during model calibration)
				 */
				if (bm->dayt < 364.0) {
					scale_denom = bm->dayt - update_date;
				} else {
					scale_denom = 365.0 - update_date;
				}

				if (scale_denom == 0)
					scale_denom = 1.0;

				start_N = bm->calcNstartPerPred[sp][expect_id];
				caseid = expect_id;
				mort_scale = 365.0 / scale_denom;
			}

			//			if(bm->flagannual_Mest || ((bm->dayt > 367.0) && (update_date > 182))){
			//				/* If restarted records within last 6 months use previous
			//				year's records as more complete */
			//				//start_N = bm->calcNstart[sp][hist_id];
			//				start_N = bm->calcNstartPerPred[sp][hist_id];
			//				caseid = hist_id;
			//				mort_scale = 1.0;
			//			} else {
			//				/* If restart records early each year then current records should be sufficent,
			//				   or if this is the first year then have no choice (!),
			//				   or this is actually coming out more frequently than annually (probably during model calibration)
			//				*/
			//				start_N = bm->calcNstart[sp][expect_id];
			//				caseid = expect_id;
			//				mort_scale = 365.0 / (365.0 - update_date);
			//			}
			fprintf(fid, " %e", start_N);
			fprintf(fid, " %e", mort_scale * bm->calcMLinearMort[sp][caseid] / (start_N + small_num));
			fprintf(fid, " %e", mort_scale * bm->calcMQuadMort[sp][caseid] / (start_N + small_num));
			if(bm->external_mortality){
				fprintf(fid, " %e", mort_scale * bm->calcELinearMort[sp][caseid] / (start_N + small_num));
			}
			fprintf(fid, " %e", mort_scale * bm->calcMPredMort[sp][caseid] / (start_N + small_num));

			for (pred = 0; pred < totnum; pred++) {
				flag_sp = (int) (FunctGroupArray[pred].speciesParams[flag_id]);
				if (flag_sp) {// && FunctGroupArray[pred].isPredator == TRUE) {
					natDead_N = bm->calcMnumPerPred[sp][pred][caseid];
					total += natDead_N;
					Mest = mort_scale * (natDead_N / (start_N + small_num));
					fprintf(fid, " %e", Mest);
					totalPredMort = totalPredMort + Mest;
				}
			}
			fprintf(fid, " %e\n", totalPredMort);
		}
	}

	return;
}


/****************************************************//**
 *
 *	\brief This routine calls routines to output the diet check arrays.
 *	If the file has not yet been opened initDietCheckFile is called to
 *	initialise the output file. Then the writeDietCheck function is called to
 *	output the values stored in the DIET_check array.
 *
 */
void Output_Diet_Check(MSEBoxModel *bm) {

    // Don't bother doing it on day 0 as nothing to print out so is a waste
    if (bm->t) {
        Update_Diets_Output(bm);

        Write_DietCheck(dietCheckfp, bm);
        if (bm->flagdietcheck) {
            Write_DetailedDietCheck(detaileddietCheckfp, bm);
        }
    }
	return;

}

/**
 *
 * \brief Routine to update the diets for output 
 * In this way it shoudl be ok regardless of frequency of output
 * Rather than just assuming updated annually
 *
 */

void Update_Diets_Output(MSEBoxModel *bm) {
    int pred, prey, cohort, stock, flag_sp;
    double tot_food = 0.0;
    
    for (pred=0; pred < bm->K_num_tot_sp; pred++) {
        flag_sp = (int) (FunctGroupArray[pred].speciesParams[flag_id]);
        if (flag_sp && FunctGroupArray[pred].isPredator == TRUE) {
            for(cohort=0; cohort<FunctGroupArray[pred].numCohortsXnumGenes; cohort++) {
                for(stock=0; stock<FunctGroupArray[pred].numStocks; stock++){
                    tot_food = 0.0;
                    for(prey=0; prey < bm->K_num_tot_sp; prey++){
                        DIET_check[pred][cohort][stock][prey][final_id] = DIET_check[pred][cohort][stock][prey][ongoing_id];  // pred is actually prey here
                        DIET_check[pred][cohort][stock][prey][ongoing_id] = 0.0;
                        tot_food += DIET_check[pred][cohort][stock][prey][final_id];
                    }
                    tot_food += small_num;  // So no divide by zero
                    for(prey=0; prey < bm->K_num_tot_sp; prey++){  // pred is actually prey here
                        DIET_check[pred][cohort][stock][prey][final_id] /= tot_food;
                    }
                }
            }
        }
    }
    
    return;
}


/**
 *
 *	\brief Routine to initialise the diet check output file.
 *
 */
static FILE * Init_DietCheck_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp, flag_sp;
    int totnum = bm->K_num_tot_sp;

	/** Create filename **/
	sprintf(fname, "%sDietCheck.txt", bm->startfname);

	/** Create file **/
	if ((fid = Util_fopen(bm, fname, "w")) == NULL)
		quit("Init_DietCheck_File: Can't open %s\n", fname);

    /** Column definitions **/
    fprintf(fid,"Time Predator Cohort Stock Updated");
    
    /* Active group names for age specific M */
    for (sp=0; sp<totnum; sp++) {
    	flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
			fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
        }
    }
    fprintf(fid,"\n");

	/* Return file pointer */
	return (fid);
}

/**
 *
 *	\brief Routine to initialise the diet check output file.
 *
 */
static FILE * Init_DetailedDietCheck_File(MSEBoxModel *bm) {
    FILE *fid;
    char fname[BMSLEN];
    int sp, flag_sp;
    int totnum = bm->K_num_tot_sp;
    
    /** Create filename **/
    sprintf(fname, "%sDetailedDietCheck.txt", bm->startfname);
    
    /** Create file **/
    if ((fid = Util_fopen(bm, fname, "w")) == NULL)
        quit("Init_DetailedDietCheck_File: Can't open %s\n", fname);
    
    /** Column definitions **/
    fprintf(fid,"Time Predator Cohort Box Layer");
    
    /* Active group names for age specific M */
    for (sp=0; sp<totnum; sp++) {
        flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp) {
            fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
        }
    }
    fprintf(fid,"\n");
    
    /* Return file pointer */
    return (fid);
}

/**
 *
 *	\brief Routine to write out the data to the diet check information.
 *
 */
static void Write_DietCheck(FILE *fid, MSEBoxModel *bm) {
	int sp, flag_sp, prey, flag_spprey, cohort, stock;
    int totnum = bm->K_num_tot_sp;

	if (verbose > 1)
		fprintf(stderr, "Write diet check output\n");

	/* Write diet values */
    for (sp=0; sp<totnum; sp++) {
        flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp && FunctGroupArray[sp].isPredator == TRUE) {
            for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
        		for(stock=0; stock<FunctGroupArray[sp].numStocks; stock++){
                    /* Write time */
                    fprintf(fid,"%e %s %d %d %d", bm->dayt, FunctGroupArray[sp].groupCode, cohort, stock, FunctGroupArray[sp].updatedDiet);
                    
        			/* Write natural mortality values */
        			for (prey=0; prey<totnum; prey++) {
                        flag_spprey = (int) (FunctGroupArray[prey].speciesParams[flag_id]);
                        if (flag_spprey) {
                            fprintf(fid," %e", DIET_check[sp][cohort][stock][prey][final_id]);
                        }
        			}
        			fprintf(fid,"\n");
        		}
        	}
        }
    }

	return;
}

/**
 *
 *	\brief Routine to write out the detailed data to the diet check information.
 *
 */
static void Write_DetailedDietCheck(FILE *fid, MSEBoxModel *bm) {
    int sp, flag_sp, prey, flag_spprey, cohort, b, k;
    int totnum = bm->K_num_tot_sp;

    if (verbose > 1)
        fprintf(stderr, "Write detailed diet check output\n");
    
    /* Write diet values */
    for (sp=0; sp<totnum; sp++) {
        flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        if (flag_sp && FunctGroupArray[sp].isPredator == TRUE) {
            for(cohort=0; cohort<FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
                for (b = 0; b < bm->nbox; b++) {
                    /* Water column layers */
                    for (k = 0; k < bm->wcnz; k++) {
                        fprintf(fid,"%e %s %d %d %d", bm->dayt, FunctGroupArray[sp].groupCode, cohort, b, k);
                        /* Write natural mortality values */
                        for (prey=0; prey<totnum; prey++) {
                            flag_spprey = (int) (FunctGroupArray[prey].speciesParams[flag_id]);
                            if (flag_spprey) {
                                fprintf(fid," %e", bm->totDiet[b][k][sp][cohort][prey] * mg_2_tonne * bm->X_CN);
                            }
                        }
                        fprintf(fid,"\n");
                    }
                    
                    /* Sediment layers */
                    for (k = 0; k < bm->sednz; k++) {
                        fprintf(fid,"%e %s %d %d %d", bm->dayt, FunctGroupArray[sp].groupCode, cohort, b, -1*(k+1));  // So sediment layers come out as -1, -2.... -n+1 etc
                        /* Write natural mortality values */
                        for (prey=0; prey<totnum; prey++) {
                            flag_spprey = (int) (FunctGroupArray[prey].speciesParams[flag_id]);
                            if (flag_spprey) {
                                fprintf(fid," %e", bm->totDiet[b][bm->wcnz+k][sp][cohort][prey] * mg_2_tonne * bm->X_CN);
                            }
                        }
                        fprintf(fid,"\n");
                    }
                }
            }
        }
    }
    
    return;
}

/***************************************************************************************************************
 * \brief Print out a species biomass value to the given log file.
 */
static void Print_Biomass_Value(MSEBoxModel *bm, int call_type, FILE *llogfp, int sp) {

	/* Add a check to make sure the biomass is not less than 0 */
	if (!call_type) {
		/* Final biomass results */
		if (!bm->totinitpop[sp]) {
			fprintf(llogfp, "Time: %e, species %s is at %f of virgin biomass (now %f t vs virgin %f t)\n", bm->dayt, FunctGroupArray[sp].groupCode,
					(double) 1.0, bm->totfishpop[sp] * bm->X_CN * mg_2_tonne, bm->totinitpop[sp] * bm->X_CN * mg_2_tonne);
		} else {
			fprintf(llogfp, "Time: %e, species %s is at %f of virgin biomass (now %f t vs virgin %f t)\n", bm->dayt, FunctGroupArray[sp].groupCode,
					bm->totfishpop[sp] / bm->totinitpop[sp], bm->totfishpop[sp] * bm->X_CN * mg_2_tonne, bm->totinitpop[sp] * bm->X_CN * mg_2_tonne);
		}
	} else {
        if (verbose)
            fprintf(llogfp, "Time: %e, box%d-%d, species %s is %f\n", bm->dayt, bm->current_box, bm->current_layer, FunctGroupArray[sp].groupCode, bm->diagnosticBiom[sp] * bm->X_CN * mg_2_tonne);
	}
}



/**************************************************************************//**
 *	\brief Routines to initialise the v Biomass information file
 *
 *****************************************************************************/
FILE * Init_Migration_File(MSEBoxModel *bm)
{
    FILE *fid;
    int spmigrate, sp, i, n;
    char fname[BMSLEN];

    /** Create filename **/
    sprintf(fname,"%sMigration.txt",bm->startfname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_Migration_File: Can't open %s\n",fname);

    /** Column definitions **/
    fprintf(fid,"Time");

    /* Absolute values */
    for (sp=0; sp<bm->K_num_tot_sp; sp++) {

        if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
        	 spmigrate = (int)(FunctGroupArray[sp].speciesParams[num_migrate_id]);
        	 if(spmigrate > 0){
				 if(FunctGroupArray[sp].isVertebrate == TRUE){
					 for(i = 0; i < spmigrate; i++){
						 fprintf(fid, " %s_juv_%d_Migrating_Biomass(tonnes)", FunctGroupArray[sp].groupCode, i);
						 fprintf(fid, " %s_juv_%d_Total_biomass(tonnes)", FunctGroupArray[sp].groupCode, i);
						 fprintf(fid, " %s_juv_%d_Prop_Migrating", FunctGroupArray[sp].groupCode, i);

						 fprintf(fid, " %s_ad_%d_Migrating_Biomass(tonnes)", FunctGroupArray[sp].groupCode, i);
						 fprintf(fid, " %s_ad_%d_Total_biomass(tonnes)", FunctGroupArray[sp].groupCode, i);
						 fprintf(fid, " %s_ad_%d_Prop_Migrating", FunctGroupArray[sp].groupCode, i);
					 }
				 }else{
					 for(n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++){
						 for(i = 0; i < spmigrate; i++){
							 fprintf(fid, " %s:%d_Migrating_Biomass_%d", FunctGroupArray[sp].groupCode, n, i);
							 fprintf(fid, " %s:%d_Total_biomass(tonnes)_%d", FunctGroupArray[sp].groupCode, n, i);
							 fprintf(fid, " %s:%d_Prop_Migrating_%d", FunctGroupArray[sp].groupCode, n, i);
						 }
					 }
				 }
        	 }
        }
    }
    fprintf(fid,"\n");

    /* Return file pointer */
    return(fid);
}


/**************************************************************************//**
 *	\brief Routines to write data to the V Biomass information file
 *
 *****************************************************************************/
void Write_Migration_File(FILE *fid, MSEBoxModel *bm){
	int sp, n, i, spmigrate, age_mat;
	double dynsn, dynrn, ad_sum, juv_sum, ad_mig_sum, juv_mig_sum;


    /* Write time */
    fprintf(fid,"%e", bm->dayt);

    for (sp=0; sp<bm->K_num_tot_sp; sp++) {

    	if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
           	 spmigrate = MIGRATION[sp].num_in_queue;

           	if(FunctGroupArray[sp].isVertebrate == TRUE){

           		age_mat = (int) (FunctGroupArray[sp].speciesParams[age_mat_id]);
           		for(i = 0; i < spmigrate; i++){
           			juv_mig_sum = juv_sum = ad_mig_sum = ad_sum = 0;
					for(n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++){

						dynsn = MIGRATION[sp].SN[n][i];
						dynrn = MIGRATION[sp].RN[n][i];

						if (n < age_mat){
							juv_mig_sum += (MIGRATION[sp].DEN[n][i] * (dynsn + dynrn));
							juv_sum += bm->totagepop[sp][n];
						}
						else{
							ad_mig_sum += (MIGRATION[sp].DEN[n][i] * (dynsn + dynrn));
							ad_sum += bm->totagepop[sp][n];
						}
					}
					fprintf(fid, " %e", juv_mig_sum * bm->X_CN * mg_2_tonne);
					fprintf(fid, " %e", juv_sum * bm->X_CN * mg_2_tonne);
					fprintf(fid, " %e",( juv_mig_sum * bm->X_CN * mg_2_tonne) / (juv_sum * bm->X_CN * mg_2_tonne));

					fprintf(fid, " %e", ad_mig_sum * bm->X_CN * mg_2_tonne);
					fprintf(fid, " %e", ad_sum * bm->X_CN * mg_2_tonne);
					fprintf(fid, " %e",( ad_mig_sum * bm->X_CN * mg_2_tonne) / (ad_sum * bm->X_CN * mg_2_tonne));

           		}
			} else {
				for(n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++){
					for(i = 0; i < spmigrate; i++){
						fprintf(fid, " %e", MIGRATION[sp].DEN[n][i] * bm->X_CN * mg_2_tonne);
						fprintf(fid, " %e", bm->totagepop[sp][n] * bm->X_CN * mg_2_tonne);
						if(FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS){
							if(bm->totagepop[sp][n] > 0){
								fprintf(fid, " %e",( MIGRATION[sp].DEN[n][i] * bm->X_CN * mg_2_tonne) / ( bm->totagepop[sp][n] * bm->X_CN * mg_2_tonne));
							}else{
								fprintf(fid, " %e", 0.0);
							}
						}else{
							if(bm->totbiom[sp] > 0){
								fprintf(fid, " %e",( MIGRATION[sp].DEN[n][i] * bm->X_CN * mg_2_tonne) / ( bm->totbiom[sp] * bm->X_CN * mg_2_tonne));
							}else{
								fprintf(fid, " %e", 0.0);
							}
						}
					}
				}
			}
        }
    }
    fprintf(fid,"\n");
    return;
}

/**************************************************************************//**
 *
 *	\brief This routine calls routines to output mortality per predator arrays
 *
 *****************************************************************************/
void Output_Migration_Data(MSEBoxModel *bm)
{
   /* migration data */
    if ( !migrationfp )
    	migrationfp = Init_Migration_File(bm);

    Write_Migration_File(migrationfp, bm);

	return;

}


FILE *Init_Size_Data_File(MSEBoxModel *bm){
	 FILE *fid;
	int sp;
	char fname[BMSLEN];

	/** Create filename **/
	sprintf(fname,"%sVertSize.txt",bm->startfname);
	printf("Creating %s\n",fname);

	/** Create file **/
	if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
		quit("Init_Size_Data_File: Can't open %s\n",fname);

	/** Column definitions **/
	fprintf(fid,"Time");


	for(sp = 0; sp < bm->K_num_tot_sp; sp++){
		if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
			if((int)(FunctGroupArray[sp].speciesParams[num_migrate_id])){
				if(FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED){
					fprintf(fid, " %s_DEN", FunctGroupArray[sp].groupCode);
					fprintf(fid, " %s_SN", FunctGroupArray[sp].groupCode);
					fprintf(fid, " %s_RN", FunctGroupArray[sp].groupCode);
					fprintf(fid, " %s_Biomass", FunctGroupArray[sp].groupCode);

				}
			}
		}
	}
	fprintf(fid,"\n");
	return fid;

}
void Write_Size_Data_File(FILE *fid, MSEBoxModel *bm){

	int b, k, sp, n;
	double DENsum, RNsum, SNsum, biomassSum;
	int den, sn, rn;

	/* Write time */
	fprintf(fid,"%e", bm->dayt);

	for(sp = 0; sp < bm->K_num_tot_sp; sp++){
		if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){

			if((int)(FunctGroupArray[sp].speciesParams[num_migrate_id])){

				if(FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED){
					DENsum = 0;
					RNsum = 0;
					SNsum = 0;

					for(n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++){
						sn = FunctGroupArray[sp].structNTracers[n];
						rn = FunctGroupArray[sp].resNTracers[n];
						den = FunctGroupArray[sp].NumsTracers[n];
						for (b=0; b<bm->nbox; b++) {
							if (bm->boxes[b].type != BOUNDARY) {
								for (k=0; k<bm->boxes[b].nz; k++) {

									DENsum += bm->boxes[b].tr[k][den];
									SNsum = SNsum + (bm->boxes[b].tr[k][sn] * bm->boxes[b].tr[k][den]);
									RNsum = RNsum + (bm->boxes[b].tr[k][rn] * bm->boxes[b].tr[k][den]);
								}
							}
						}
					}
					if(DENsum > 0){
						/* Normalise the Sn and Rn values*/
						SNsum = SNsum / DENsum;
						RNsum = RNsum / DENsum;
					}else{
						SNsum = 0;
						RNsum= 0;
					}
					biomassSum = DENsum * (SNsum + RNsum)* bm->X_CN * mg_2_tonne;
					fprintf(fid, " %e", DENsum);
					fprintf(fid, " %e", SNsum);
					fprintf(fid, " %e", RNsum);
					fprintf(fid, " %e", biomassSum);
				}
			}
		}
	}
	fprintf(fid,"\n");
}
void Output_Size_Data(MSEBoxModel *bm)
{
	/* migration data */
	if ( !sizeDataFP )
		sizeDataFP = Init_Size_Data_File(bm);

	Write_Size_Data_File(sizeDataFP, bm);

	return;
}

/****************************************************************************************************************
 *	\brief Routines to initialise the seagrass biomass information file - from Savina model
 */
static FILE * Init_MacrophyteBiom_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp, cohort;

	/** Create filename **/
	sprintf(fname, "%sSeagrassBiomIndx.txt", bm->startfname);
	printf("Creating %s\n", fname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_MacrophyteBiom_File: Can't open %s\n",fname);

    /** Column definitions **/
	fprintf(fid, "Time ");

	/* Absolute values */
	for(sp = 0; sp < bm->K_num_tot_sp; sp++){
		if(FunctGroupArray[sp].groupType == SEAGRASS){
			for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
				fprintf(fid, " %s-%d", FunctGroupArray[sp].groupCode, cohort);
			}
		}
	}
	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *	\brief Routines to write data to the seagrass biomass information file
 *
 */
static void Write_MacrophyteBiomass(FILE *fid, MSEBoxModel *bm) {
	int sp, cohort;

	if (verbose > 1)
		fprintf(stderr, "Write total age structured biomass information\n");

	/* Write time */
	fprintf(fid, "%e", bm->dayt);

	/* Write absolute values */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if(FunctGroupArray[sp].groupType == SEAGRASS){
			for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
				fprintf(fid, " %e", bm->totagepop[sp][cohort] * bm->X_CN * mg_2_tonne);
			}
		}
	}

	fprintf(fid, "\n");

	return;
}


/****************************************************************************************************************
 *	\brief Routines to initialise the age structured biomass information file - from Savina model
 */
static FILE * Init_AgeBiom_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp, cohort;

	/** Create filename **/
	sprintf(fname, "%sAgeBiomIndx.txt", bm->startfname);
	printf("Creating %s\n", fname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_AgeBiom_File: Can't open %s\n",fname);

    /** Column definitions **/
	fprintf(fid, "Time");

	/* Absolute values */
	for(sp = 0; sp < bm->K_num_tot_sp; sp++){
		if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
			for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
				fprintf(fid, " %s-%d", FunctGroupArray[sp].groupCode, cohort);
			}
		}
	}
	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *	\brief Routines to write data to the Age structrured Biomass information file - now in t, used to be in mg N
 *
 */
static void Write_AgeBiomass(FILE *fid, MSEBoxModel *bm) {
	int sp, cohort;

	if (verbose > 1)
		fprintf(stderr, "Write total age structured biomass information\n");

	/* Write time */
	fprintf(fid, "%e", bm->dayt);

	/* Write absolute values */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
			for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
				fprintf(fid, " %e", bm->totagepop[sp][cohort] * bm->X_CN * mg_2_tonne);
			}
		}
	}

	fprintf(fid, "\n");

	return;
}

/****************************************************************************************************************
 *	\brief Routines to initialise the age structured biomass information file - from Savina model
 */
static FILE * Init_AnnualAgeBiom_File(MSEBoxModel *bm) {
    FILE *fid;
    char fname[BMSLEN];
    int sp, cohort, this_cohort, i;
    
    /** Create filename **/
    sprintf(fname, "%sAnnualAgeBiomIndx.txt", bm->startfname);
    printf("Creating %s\n", fname);
    
    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_AnnualAgeBiom_File: Can't open %s\n",fname);
    
    /** Column definitions **/
    fprintf(fid, "Time");
    
    /* Absolute values */
    for(sp = 0; sp < bm->K_num_tot_sp; sp++){
        if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
            for (i = 0; i < FunctGroupArray[sp].numStocks; i++) {
                this_cohort = 0;
                for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes * FunctGroupArray[sp].ageClassSize; cohort++) {
                    fprintf(fid, " %d-%s-%d", i, FunctGroupArray[sp].groupCode, this_cohort);
                    this_cohort++;
                }
            }
        }
    }
    fprintf(fid, "\n");
    
    /* Return file pointer */
    return (fid);
}

/**
 *	\brief Routines to write data to the Age structrured Biomass information file - now in t, used to be in mg N
 *
 */
static void Write_AnnualAgeBiomass(FILE *fid, MSEBoxModel *bm) {
    int sp, cohort, this_cohort, i, k;
    
    if (verbose > 1)
        fprintf(stderr, "Write total age structured biomass information\n");
    
    /* Write time */
    fprintf(fid, "%e", bm->dayt);
    
    /* Write absolute values */
    for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
            for (i = 0; i < FunctGroupArray[sp].numStocks; i++) {
                this_cohort = 0;
                for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
                    for (k = 0; k < FunctGroupArray[sp].ageClassSize; k++) {
                        fprintf(fid, " %e", bm->totagepop[sp][cohort] * bm->X_CN * mg_2_tonne * bm->tempPopRatio[i][sp][cohort][k]);
                    }
                    this_cohort++;
                }
            }
        }
    }
    
    fprintf(fid, "\n");
    
    return;
}


/****************************************************************************************************************
 *	\brief Routines to initialise the sun light information file.
 */
static FILE * Init_BoxLight_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int b;

	/** Create filename **/
	sprintf(fname, "%sBoxLight.txt", bm->startfname);
	printf("Creating %s\n", fname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_BoxLight_File: Can't open %s\n",fname);

    fprintf(fid, "Proportion of sun hours per timestep.\n");

	/** Column definitions **/
	fprintf(fid, "Time");

	/* Value per box. */
	for(b = 0; b < bm->nbox; b++){
		fprintf(fid, " %d", b);
	}
	fprintf(fid, "\n");

	/* Return file pointer */
	return (fid);
}

/**
 *	\brief Routines to write sun light data output file.
 *
 */
static void Write_BoxLight(FILE *fid, MSEBoxModel *bm) {
	int b;

	if (verbose > 1)
		fprintf(stderr, "Write box light information\n");

	/* Write time */
	fprintf(fid, "%e", bm->dayt);

	/* Write data per box */
	for (b = 0; b < bm->nbox; b++){
		fprintf(fid, " %f", bm->boxes[b].prop_light_time);
	}

	fprintf(fid, "\n");

	return;
}


/****************************************************************************************************************
 *	\brief Routines to initialise the sun light information file.
 */
static FILE * Init_BoxBiomass_File(MSEBoxModel *bm) {
	FILE *fid;
	char fname[BMSLEN];
	int sp;

	/** Create filename **/
	sprintf(fname, "%sBoxBiomass.txt", bm->startfname);
	printf("Creating %s\n", fname);

    /** Create file **/
    if ( (fid=Util_fopen(bm, fname, "w")) == NULL )
        quit("Init_BoxBiomass_File: Can't open %s\n",fname);


    /** Column definitions **/
	fprintf(fid, "Time Box");

	/* Value per box. */

	for(sp = 0; sp < bm->K_num_tot_sp; sp++){
		if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
			fprintf(fid, " %s", FunctGroupArray[sp].groupCode);
		}
	}
	fprintf(fid, "\n");


	/* Return file pointer */
	return (fid);
}

/**
 *	\brief Routines to write sun light data output file.
 *
 */
static void Write_BoxBiomass(FILE *fid, MSEBoxModel *bm) {
	int b, sp;

	if (verbose > 1)
		fprintf(stderr, "Write box biomass information\n");

	/* Write time */
	//fprintf(fid, "%e", bm->dayt);

	/* Value per box. */
	for(b = 0; b < bm->nbox; b++){
		fprintf(fid, "%e %d", bm->dayt, b);

		for(sp = 0; sp < bm->K_num_tot_sp; sp++){
			if ( (int)(FunctGroupArray[sp].speciesParams[flag_id])){
				fprintf(fid, " %e", bm->boxBiomass[b][sp] * bm->X_CN * mg_2_tonne);
			}

		}
		fprintf(fid, "\n");
	}


	return;
}

