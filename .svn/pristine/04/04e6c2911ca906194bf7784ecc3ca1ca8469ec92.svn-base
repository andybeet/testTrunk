/* Revisions:
 * Beth Fulton - 8/7/2014
 * Converted all MALE to FEMALE as not likely to have stored MALE data as single sex usually used in Atlantis and FEMALE = 0 be definition
 */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <math.h>
#include <ctype.h>
#include <time.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#include <direct.h>
#else
#include <unistd.h>
#endif

#include <sjwlib.h>
#include <atlantisboxmodel.h>
#include <atUtilLib.h>

/* Assessment and fisheries data storage */
#define commerical_id 0
#define survey_id 1

#define sample_id 0

#define EstBcurrIndex 5
#define depletionIndex 8
#define maxConvergCritIndex 16
#define startOfFleetData 10

/**
 *	Read in the output from the SS3 run. Will read in the RBC (recommended biological catch) and B estimate values.
 *
 *
 */
double Read_SS3_Report_File(MSEBoxModel *bm, int species, char *folderName) {

	char outputFileName[] = "Forecast-report.sso";

	FILE *fid;
	int buflen = STRLEN;
	char buf[STRLEN];
	char seps[] = " ";
	int n;
	char *varStr;
	int fleetIndex;
	double catch;
	double RBC;

	_getcwd(buf, (int)STRLEN);
	printf("getcwd = %s\n", buf);

	if ((fid = fopen(outputFileName, "r")) == NULL)
		quit("Read_SS3_Report_File: Can't open %s\n", outputFileName);

	/* Need to read in the RBC and total catch*/
	RBC = 0;

	/* Find line that starts with 'FORECAST:_With_F_to_match_adjusted_catch' */
	while (fgets(buf, buflen, fid) != NULL) {

		if (strstr(buf, "FORECAST:_With_F_to_match_adjusted_catch") != NULL) {

			/* ignore the next line */
			fgets(buf, buflen, fid);

			/* grab the data from the next line */
			fgets(buf, buflen, fid);

			varStr = strtok(buf, seps);
			n = 0;

			while (varStr != NULL) {

				varStr = strtok(NULL, seps);
				n++;

				/* The 'bio-all' column */
				if (n == EstBcurrIndex) {
					bm->RBCestimation.RBCspeciesParam[species][EstBcurr_id] = atof(varStr);
				}

				/* The 'Depletion' column */
				if (n == depletionIndex) {
					bm->RBCestimation.RBCspeciesParam[species][EstDepletion_id] = atof(varStr);
				}

				if (n >= startOfFleetData)
					break;
			}

			bm->RBCestimation.RBCspeciesParam[species][EstB0_id] = bm->RBCestimation.RBCspeciesParam[species][EstBcurr_id] / bm->RBCestimation.RBCspeciesParam[species][EstDepletion_id];


			fleetIndex = 0;
			n = 0;
			RBC = 0;
			/* Now deal with the fleets */
			while (varStr != NULL) {

				/* Want the 'Retain_B-1' column */
				if (n == 2) {
					catch = atof(varStr);
					RBC += catch;
				}

				varStr = strtok(NULL, seps);
				n++;

				if (n >= 8) {
					fleetIndex++;
					n = 0;
				}
			}
			break;
		}
	}

	printf("EstB0 = %e, RBC = %e\n", bm->RBCestimation.RBCspeciesParam[species][EstB0_id], RBC);
	printf("Read_SS3_Report_File\n");

	return RBC;
}

/**
 *	Read in the output par from the SS3 run, to check for convergence
 *
 *
 */
double Read_SS3_Par_File(MSEBoxModel *bm, char *folderName) {
    
	char outputFileName[] = "ss3.par";
    
	FILE *fid;
	int buflen = STRLEN;
	char buf[STRLEN];
    char str[STRLEN];
	char seps[] = " ";
	char *varStr;
	double ans = 0.0;
    
	_getcwd(buf, STRLEN);
	printf("getcwd = %s\n", buf);
    
	if ((fid = fopen(outputFileName, "r")) == NULL)
		quit("Read_SS3_Report_File: Can't open %s\n", outputFileName);
    
    sprintf(str, "MGparm[%d]", maxConvergCritIndex);
    
	/* Find line that starts with 'MGparm[16]' - as that marks the convergence result */
	while (fgets(buf, buflen, fid) != NULL) {
        
		if (strstr(buf, str) != NULL) {
            
			/* ignore the next line */
			fgets(buf, buflen, fid);
            
			/* grab the data from the next line */
			fgets(buf, buflen, fid);
            
			varStr = strtok(buf, seps);
			ans = atof(varStr);
		}
	}
    
	printf("MaxConvergCrit = %e\n", ans);
	printf("Read_SS3_Par_File\n");
    
	return ans;
}

/**
 *	Create the SS3 run. starter file
 *
 *
 */

void Create_Starter_File(MSEBoxModel *bm, char *dirName, int groupIndex, int versionID) {

	FILE *fid;
	char fileName[STRLEN];

	sprintf(fileName, "%s%sstarter.ss", dirName, FOLDER_SEP);

	printf("fileName = %s\n", fileName);

	if ((fid = fopen(fileName, "w")) == NULL)
		quit("Create_Starter_File: Can't open %s\n", fileName);

	printf("versionID = %d\n", versionID);
	/* Now start writing out the data */

	fprintf(fid, "# SS starter file for %s.\n", FunctGroupArray[groupIndex].groupCode);
	//fprintf(fid, "atlantisSS3_%d.dat\n", versionID);
	//fprintf(fid, "atlantisSS3_%d.ctl\n", versionID);

	fprintf(fid, "%sDatFile.dat\n", FunctGroupArray[groupIndex].groupCode);
	fprintf(fid, "%sControlFile.ctl\n", FunctGroupArray[groupIndex].groupCode);

	fprintf(fid, "0 # 0=use init values in control file; 1=use ss3.par\n");
	fprintf(fid, "2 # run display detail (0,1,2)\n");
	fprintf(fid, "0 # detailed age-structured reports in REPORT.SSO (0,1)\n");
	fprintf(fid, "1 # write detailed checkup.sso file (0,1)\n");
	fprintf(fid, "4 # write parm values to ParmTrace.sso (0=no,1=good,active; 2=good,all; 3=every_iter,all_parms; 4=every,active)\n");
	fprintf(fid, "0 # write to cumreport.sso (0=no,1=like&timeseries; 2=add survey fits)\n");
	fprintf(fid, "1 # Include prior_like for non-estimated parameters (0,1)\n");
	fprintf(fid, "1 # Use Soft Boundaries to aid convergence (0,1) (recommended)\n");
	fprintf(fid, "1 # Number of bootstrap datafiles to produce\n");
	fprintf(fid, "6 # Turn off estimation for parameters entering after this phase\n");
	fprintf(fid, "10 # MCMC burn interval\n");
	fprintf(fid, "2 # MCMC thin interval\n");
	fprintf(fid, "0 # jitter initial parm value by this fraction\n");
	fprintf(fid, "-1 # min yr for sdreport outputs (-1 for styr)\n");
	fprintf(fid, "-2 # max yr for sdreport outputs (-1 for endyr; -2 for endyr+Nforecastyrs\n");
	fprintf(fid, "0 # N individual STD years\n");
	fprintf(fid, "%e # final convergence criteria (e.g. 1.0e-04)\n", bm->RBCestimation.SSTol);  // 0.0001
	fprintf(fid, "0 # retrospective year relative to end year (e.g. -4)\n");
	fprintf(fid, "1 # min age for calc of summary biomass\n");
	fprintf(fid, "%d # Depletion basis:  denom is: 0=skip; 1=rel X*B0; 2=rel X*Bmsy; 3=rel X*B_styr\n", bm->RBCestimation.SSDepletionBasis); //1
	fprintf(fid, "%e # Fraction (X) for Depletion denominator (e.g. 0.4)\n", bm->RBCestimation.SSFractX); // 1.0  neil had 0.41 here
	fprintf(fid, "%d # (1-SPR)_reporting:  0=skip; 1=rel(1-SPR); 2=rel(1-SPR_MSY); 3=rel(1-SPR_Btarget); 4=notrel\n", bm->RBCestimation.SS_SPRreport); //4
	fprintf(fid, "%d # F_std reporting: 0=skip; 1=exploit(Bio); 2=exploit(Num); 3=sum(frates)\n", bm->RBCestimation.SS_Freport); //1
	fprintf(fid, "%d # F_report_basis: 0=raw; 1=rel Fspr; 2=rel Fmsy ; 3=rel Fbtgt\n", bm->RBCestimation.SSFreportBasis);
	fprintf(fid, "999 # check value for end of file\n");

	fclose(fid);
}

void Write_Forecast_File(MSEBoxModel *bm, char *dirName, int maxyr, int groupIndex, int versionID) {

	//	int f,allregion;
	//	double last_catch;
	FILE *fid;
	char fileName[STRLEN];
	double catch, last_catch;
	int f;
	int sumregion = 0; /* This isn't going to work - needs to be numRegions + 1 */

	sprintf(fileName, "%s%sforecast.ss", dirName, FOLDER_SEP);

	printf("fileName = %s\n", fileName);

	if ((fid = fopen(fileName, "w")) == NULL)
		quit("Create_Starter_File: Can't open %s\n", fileName);

	printf("versionID = %d\n", versionID);
	/* Now start writing out the data */

	fprintf(fid, "#V3.24f\n");
	fprintf(fid, "#C  generic forecast file\n");
	fprintf(fid, "# for all year entries except rebuilder; enter either: actual year, -999 for styr, 0 for endyr, neg number for rel. endyr\n");
	fprintf(fid, "1 # Benchmarks: 0=skip; 1=calc F_spr,F_btgt,F_msy \n");
	fprintf(fid, "2 # MSY: 1= set to F(SPR); 2=calc F(MSY); 3=set to F(Btgt); 4=set to F(endyr) \n");
	fprintf(fid, "%e # SPR target (e.g. 0.40)\n", bm->targ_refA);
	fprintf(fid, "%e # Biomass target (e.g. 0.40)\n", bm->targ_refA);
	fprintf(fid, "#_Bmark_years: beg_bio, end_bio, beg_selex, end_selex, beg_relF, end_relF (enter actual year, or values of 0 or -integer to be rel. endyr)\n");
	fprintf(fid, " 0 0 0 0 0 0\n");
	fprintf(fid, "#  2001 2001 2001 2001 2001 2001 # after processing \n");
	fprintf(fid, "\n");
	fprintf(fid, "1 #Bmark_relF_Basis: 1 = use year range; 2 = set relF same as forecast below#\n");

	fprintf(fid, "%d # Forecast: 0=none; 1=F(SPR); 2=F(MSY) 3=F(Btgt); 4=Ave F (uses first-last relF yrs); 5=input annual F scalar\n", bm->RBCestimation.SSForecastType);  //3
	fprintf(fid, "%d # N forecast years \n", bm->RBCestimation.nFuture);  //2
	fprintf(fid, "%e # F scalar (only used for Do_Forecast==5)\n", bm->RBCestimation.SSFscalar);  //0.2

	fprintf(fid, "#_Fcast_years:  beg_selex, end_selex, beg_relF, end_relF  (enter actual year, or values of 0 or -integer to be rel. endyr)\n");
	fprintf(fid, " 0 0 -1 0\n");
	fprintf(fid, "#  2001 2001 1991 2001 # after processing \n");

	fprintf(fid, "%d # Control rule method (1=catch=f(SSB) west coast; 2=F=f(SSB) ) \n", bm->RBCestimation.SSControlRule); //2
	fprintf(fid, "%e # Control rule Biomass level for constant F (as frac of Bzero, e.g. 0.40); (Must be > the no F level below) \n", bm->RBCestimation.SSControlRuleB); //0.35
	fprintf(fid, "%e # Control rule Biomass level for no F (as frac of Bzero, e.g. 0.10) \n", bm->lim_ref);  // 0.2
	fprintf(fid, "%e # Control rule target as fraction of Flimit (e.g. 0.75) \n", bm->RBCestimation.SSControlRuleTargF);  // 1
	fprintf(fid, "%d #_N forecast loops (1=OFL only; 2=ABC; 3=get F from forecast ABC catch with allocations applied)\n", bm->RBCestimation.SSLoop); //3
	fprintf(fid, "%d #_First forecast loop with stochastic recruitment\n", bm->RBCestimation.SSLoopWithRandRec);  //3
	fprintf(fid, "0 #_Forecast loop control #3 (reserved for future bells&whistles) \n");
	fprintf(fid, "0 #_Forecast loop control #4 (reserved for future bells&whistles) \n");
	fprintf(fid, "0 #_Forecast loop control #5 (reserved for future bells&whistles) \n");
	fprintf(fid, "%d  #FirstYear for caps and allocations (should be after years with fixed inputs) \n", (int)(bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMax_id] + 1));  // 2010
	fprintf(fid, "0 # stddev of log(realized catch/target catch) in forecast (set value>0.0 to cause active impl_error)\n");
	fprintf(fid, "0 # Do West Coast gfish rebuilder output (0/1) \n");
	fprintf(fid, "%d # Rebuilder:  first year catch could have been set to zero (Ydecl)(-1 to set to 1999)\n", (int)(bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMax_id] + 1));  // 1999
	fprintf(fid, "-1 # Rebuilder:  year for current age structure (Yinit) (-1 to set to endyear+1)\n");
	fprintf(fid, "1 # fleet relative F:  1=use first-last alloc year; 2=read seas(row) x fleet(col) below\n");

	fprintf(fid, "\n");

	fprintf(fid, "# Note that fleet allocation is used directly as average F if Do_Forecast=4 \n");
	fprintf(fid, "1 # basis for fcast catch tuning and for fcast catch caps and allocation  (2=deadbio; 3=retainbio; 5=deadnum; 6=retainnum)\n");
	fprintf(fid, "# Conditional input if relative F choice = 2\n");
	fprintf(fid, "# Fleet relative F:  rows are seasons, columns are fleets\n");
	fprintf(fid, "#_Fleet:  FISHERY1\n");
	fprintf(fid, "#  1\n");
	fprintf(fid, "# max totalcatch by fleet (-1 to have no max) must enter value for each fleet\n");
	fprintf(fid, " -1\n");
	fprintf(fid, "# max totalcatch by area (-1 to have no max); must enter value for each fleet \n");
	fprintf(fid, " -1\n");
	fprintf(fid, "# fleet assignment to allocation group (enter group ID# for each fleet, 0 for not included in an alloc group)\n");
	fprintf(fid, " 0\n");
	fprintf(fid, "#_Conditional on >1 allocation group\n");
	fprintf(fid, "# allocation fraction for each of: 0 allocation groups\n");
	fprintf(fid, "# no allocation groups\n");
	fprintf(fid, "0 # Number of forecast catch levels to input (else calc catch from forecast F) \n");
	fprintf(fid, "2 # basis for input Fcast catch:  2=dead catch; 3=retained catch; 99=input Hrate(F) (units are from fleetunits; note new codes in SSV3.20)\n");
	fprintf(fid, "# Input fixed catch values\n");
	fprintf(fid, "#Year Seas Fleet Catch(or_F) \n");

	last_catch = 0;
	for (f = 0; f < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; f++)
		last_catch = last_catch + bm->RBCestimation.RBCspeciesArray[groupIndex].CatchData[f][sumregion][maxyr];

	for (f = 0; f < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; f++) {
		catch = bm->RBCestimation.RBCspeciesArray[groupIndex].CatchData[f][sumregion][maxyr] * bm->RBCestimation.RBCspeciesParam[groupIndex][TAC_old_id]
				/ last_catch;
		fprintf(fid, " %d 1 %d %f\n", (int) bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id] + maxyr + 1, f, catch);
	}

	fprintf(fid, "\n#\n");
	fprintf(fid, "999 # verify end of input \n");

	fclose(fid);

}

//******************************************************************************
//
// Name:  WriteSSDat
// Description: write the generated data to data file for input to SS filename.dat
//              Have data up to maxyr, need TAC for maxyr+2, so estimate catch for maxyr+1
//              This is for an assessment in maxyr+1
//
//
// called by : WriteSSFiles
// calls :
// created  : Nov 2007 Sally
// updated:   Feb 2011 Sally
//
//******************************************************************************
void Write_SS_Data_File(MSEBoxModel *bm, char *dirName, char *fileName, int maxyr, int groupIndex, int versionID) {
	FILE *fid;
	char str[STRLEN];
	char line1[STRLEN], line2[STRLEN], line3[STRLEN];
	int seasonIndex, yearIndex, fleetIndex;
	int index;
	double value;
	int nseas = 1;
	int nAgeBins;
	int Nsexes = bm->K_num_sexes;
	int AccumAge = (int)FunctGroupArray[groupIndex].speciesParams[AccumAge_id];  // TODO: Or should this be bm->RBCestimation.RBCspeciesParam[groupIndex][AccumAge_id] ?
	int HistYrMin;
	int numYears, allregion, nf, num, it, s, part = 0, gender, l, ageIndex;
	double cpcv, disccv;
	char *emptySex;
	double Nsex_samp = 1;

	if (bm->RBCestimation.RBCspeciesArray[groupIndex].CurrentYear == (bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMax_id] - 1))
		HistYrMin = (int)bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id];
        //HistYrMin = 0;
	else
		HistYrMin = (int)bm->RBCestimation.RBCspeciesArray[groupIndex].CurrentYear + 1 - (int)bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id];

	printf("maxyr = %d\n", maxyr);
	numYears = maxyr + 1;	// - HistYrMin + 1;

	printf("bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMax_id] = %d\n", (int) bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMax_id]);
	printf("bm->RBCestimation.RBCspeciesArray[groupIndex].CurrentYear = %d\n", bm->RBCestimation.RBCspeciesArray[groupIndex].CurrentYear);
	printf("numYears = %d\n", numYears);

	//sscanf(bm->t_units, "seconds since %d-%s", &startYear, str);

	sprintf(str, "%s%s%s", dirName, FOLDER_SEP, fileName);

	if ((fid = fopen(str, "w")) == NULL)
		quit("Create_Starter_File: Can't open %s\n", str);

	/* Need the following data:
	 *
	 * bm->CatchRecord[Yr][sp][age][dataid]
	 *
	 */

	fprintf(fid, "#V3.24f\n#_SS-V3.24f-safe-Win64;_08/03/2012;_Stock_Synthesis_by_Richard_Methot_(NOAA)_using_ADMB_11\n");
	fprintf(fid, "#_Start_time: Fri Aug 03 16:47:29 2012\n#_Number_of_datafiles: 3\n#C data file for simple example\n#_observed data: \n");
	fprintf(fid, "%d #_styr\n", HistYrMin);    // This has to have an AD year value (e.g. 1980)
	fprintf(fid, "%d #_endyr\n", maxyr);
	fprintf(fid, "%d #_nseas\n", nseas);
	fprintf(fid, "12 #_months/season\n");
	fprintf(fid, "1 #_spawn_seas\n");
	fprintf(fid, "%d #_Nfleet\n", (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]);
	fprintf(fid, "0 #_Nsurveys\n");
	fprintf(fid, "1 #_N_areas\n");

	strcpy(line1, "");
	strcpy(line2, "");
	strcpy(line3, "");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		sprintf(line1, "%sFISHERY%d", line1, fleetIndex + 1);
		sprintf(line2, "%s0.5 ", line2);
		sprintf(line3, "%s1 ", line3);

		if (fleetIndex < (bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id] - 1))
			sprintf(line1, "%s%%", line1);
	}

	fprintf(fid, "%s\n", line1);
	fprintf(fid, "%s #_surveytiming_in_season\n", line2);
	fprintf(fid, "%s #_area_assignments_for_each_fishery_and_survey\n", line3);

	strcpy(line1, "");
	strcpy(line2, "");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		sprintf(line1, "%s 1", line1);
		sprintf(line2, "%s 1", line2);
	}
	fprintf(fid, "%s #_units of catch: 1=bio; 2=num\n", line1);
	fprintf(fid, "%s #_se of log(catch) only used for init_eq_catch and for Fmethod 2 and 3; use -1 for discard only fleets\n", line2);

	fprintf(fid, "%d #_Ngenders\n", Nsexes);
	fprintf(fid, "%d #_Nages\n", AccumAge);
    
	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		sprintf(line1, "0 ");
    }
	fprintf(fid, "#_init_equil_catch_for_each_fishery\n");

	fprintf(fid, "%d #_N_lines_of_catch_to_read\n", numYears);

	fprintf(fid, "#_catch_biomass(mtons):_columns_are_fisheries,year,season\n");

	seasonIndex = 1;
	allregion = 0;    // uses weighted sum over regions, assume assessment doesn't know about regions

	/* Biomass data
	 bm->CatchRecord[Yr][sp][chrt][survey_id]

	 Catch data
	 bm->CatchRecord[Yr][sp][chrt][commerical_id]
	 */

	//bm->CatchRecord[Yr][sp][age][dataid]
	for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
		for (nf = 0; nf < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; nf++) {

			fprintf(fid, " %.1f", bm->RBCestimation.RBCspeciesArray[groupIndex].CatchData[nf][allregion][yearIndex]);
		}

		fprintf(fid, " %d %d\n", ((int) bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id] + yearIndex), seasonIndex);
	}

	fprintf(fid, "\n#\n");

	num = 0;
	for (nf = 0; nf < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; nf++)
		for (yearIndex = 0; yearIndex < numYears; yearIndex++)
			if (bm->RBCestimation.RBCspeciesArray[groupIndex].CPUEgen[nf][allregion][yearIndex] > 0.0)
				num = num + 1;

	fprintf(fid, "%d #_N_cpue_and_surveyabundance_observations\n", num);
	fprintf(fid, "#_Units: 0=numbers; 1=biomass; 2=F\n");
	fprintf(fid, "#_Errtype: -1=normal; 0=lognormal; >0=T\n");

	fprintf(fid, "#_Fleet Units Errtype\n");

	index = 1;

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " %d %d %d # FISHERY%d\n", index, 1, 0, fleetIndex + 1);
		index++;
	}

	fprintf(fid, "##_year seas index obs err\n");

	/*
	 * #_year seas index obs err
	 1977 1 2 339689 0.3 # SURVEY1
	 1980 1 2 193353 0.3 # SURVEY1
	 1983 1 2 151984 0.3 # SURVEY1

	 bm->CatchRecord[Yr][sp][age][dataid]
	 */

	index = 1;
	for (nf = 0; nf < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; nf++) {
		for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
			if (bm->RBCestimation.RBCspeciesArray[groupIndex].CPUEgen[nf][allregion][yearIndex] > 0.0) {
				if (bm->RBCestimation.RBCspeciesArray[groupIndex].CPUEcv[nf] == 0.0) // generate cpue with no error, but still want cv in SS
					cpcv = 0.2;
				else
					cpcv = bm->RBCestimation.RBCspeciesArray[groupIndex].CPUEcv[nf];

				fprintf(fid, " %d %d %d %.2f %.2f #FISHERY%d\n", ((int) bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id] + yearIndex), seasonIndex,
						index, bm->RBCestimation.RBCspeciesArray[groupIndex].CPUEgen[nf][allregion][yearIndex], cpcv, (fleetIndex + 1));

			}
		}
		index++;
	}
	fprintf(fid, "\n");

	num = 0;
	for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
		for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
			if (bm->RBCestimation.RBCspeciesArray[groupIndex].DiscData[fleetIndex][allregion][yearIndex] > 0)
				num = num + 1;
		}
	}

	fprintf(fid, "%d #_N_fleets_with_discard\n", (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]);
	fprintf(fid, "#_discard_units (1=same_as_catchunits(bio/num); 2=fraction; 3=numbers)\n");
	fprintf(fid, "#_discard_errtype: >0 for DF of T-dist(read CV below); 0 for normal with CV; -1 for normal with se; -2 for lognormal\n");

	fprintf(fid, "#Fleet Disc_units err_type\n");
	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
 		fprintf(fid, " %d %d %d # FISHERY%d\n", index, 1, 0, fleetIndex + 1);
		index++;
    }
    
	fprintf(fid, "%d #N discard obs\n", num);
	fprintf(fid, "#_year seas index obs err\n");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
			if (bm->RBCestimation.RBCspeciesArray[groupIndex].DiscData[fleetIndex][allregion][yearIndex] > 0) {

				if (bm->RBCestimation.RBCspeciesArray[groupIndex].DiscCV[fleetIndex] == 0.0) // generate discards with no error, but still want cv in SS
					disccv = 0.1;
				else
					disccv = bm->RBCestimation.RBCspeciesArray[groupIndex].DiscCV[fleetIndex];

				fprintf(fid, " %d %d %d %.5f %.2f #FISHERY%d\n", ((int) bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id] + yearIndex), seasonIndex,
						index, bm->RBCestimation.RBCspeciesArray[groupIndex].DiscData[fleetIndex][allregion][yearIndex], disccv, (fleetIndex + 1));

			}
		}
	}
	fprintf(fid, "#\n");

	fprintf(fid, "0 #_N_meanbodywt_obs\n");
	fprintf(fid, "30 #_DF_for_meanbodywt_T-distribution_like\n");

	emptySex = (char *) malloc(sizeof(char) * 2 * (size_t) bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]);
	//strcpy(emptySex, "");

	for (index = 0; index < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]; index++) {
		if (index == 0)
			sprintf(emptySex, "0");
		else
			sprintf(emptySex, "%s 0", emptySex);
	}

	fprintf(fid, "\n");
	fprintf(fid, "1 # length bin method: 1=use databins; 2=generate from binwidth,min,max below; 3=read vector\n");
	fprintf(fid, "%d # binwidth for population size comp \n", (int) FunctGroupArray[groupIndex].speciesParams[allometic_bin_size_id]);

    // May not be required - not in flathead example file from Wayte
	fprintf(fid, "%d # minimum size in the population (lower edge of first bin and size at age 0.00) \n",
			(int) bm->RBCestimation.RBCspeciesArray[groupIndex].LoLenBin[0]);
    // May not be required - not in flathead example file from Wayte
	fprintf(fid, "%d # maximum size in the population (lower edge of last bin) \n",
			(int) (bm->RBCestimation.RBCspeciesArray[groupIndex].LoLenBin[(int) bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id] - 1]));

	fprintf(fid, "\n");
	fprintf(fid, "0 #_comp_tail_compression\n");
	fprintf(fid, "0.0001 #_add_to_comp\n");
	fprintf(fid, "0 #_combine males into females at or below this bin number\n");
	fprintf(fid, "%d #_N_LengthBins\n", (int) (bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]));

    index = 0;
	for (index = 0; index < bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]; index++) {
		fprintf(fid, " %d", (int) bm->RBCestimation.RBCspeciesArray[groupIndex].LoLenBin[index]);
	}
	fprintf(fid, " \n");

	it = 0;
	printf("retained\n");
	for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
		printf("%d ", ((int) bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id] + yearIndex));
		for (fleetIndex = 0; fleetIndex < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
			printf(" %d", bm->RBCestimation.RBCspeciesArray[groupIndex].LengthFltYr[it][fleetIndex][yearIndex]);
		}
		printf("\n");
	}

	it = 2;
	printf("discarded\n");
	for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
		printf("%d ", ((int) bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id] + yearIndex));
		for (fleetIndex = 0; fleetIndex < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
			printf(" %d", bm->RBCestimation.RBCspeciesArray[groupIndex].LengthFltYr[it][fleetIndex][yearIndex]);
		}
		printf("\n");

	}

	for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
		for (fleetIndex = 0; fleetIndex < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
			for (it = 0; it < 3; it++) {
				for (s = 0; s < Nsex_samp; s++) {
					if (bm->RBCestimation.RBCspeciesArray[groupIndex].LengthFltYr[it][fleetIndex][yearIndex] > 0
							&& bm->RBCestimation.RBCspeciesArray[groupIndex].LFss[fleetIndex][s][yearIndex][it] > 10) {
						num = num + 1;
					}
				}
			}
		}
	}

	fprintf(fid, "%d #_N_Length_obs\n", num);
	fprintf(fid, "#Yr Seas Flt/Svy Gender Part Nsamp datavector(female-male)\n");

	for (fleetIndex = 0; fleetIndex < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
			for (it = 0; it < 3; it++) {
				for (s = 0; s < Nsex_samp; s++) {
					if (bm->RBCestimation.RBCspeciesArray[groupIndex].LengthFltYr[it][fleetIndex][yearIndex] > 0
							&& bm->RBCestimation.RBCspeciesArray[groupIndex].LFss[fleetIndex][s][yearIndex][it] > 10) {
						if (it == 0)
							part = 2;   // retained
						else if (it == 1)
							part = 0;   // whole
						else if (it == 2)
							part = 1;   // discarded
						if (Nsex_samp == 1)
							gender = 0;   //combined
						else
							gender = s;

						fprintf(fid, " %d 1 %d %d %d %d", (HistYrMin + yearIndex), fleetIndex + 1, gender, part,
								bm->RBCestimation.RBCspeciesArray[groupIndex].LFss[fleetIndex][s][yearIndex][it]);

						if (s == 1) {   // females or combined - write female LFs then male (ignored)

							for (l = 0; l < bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]; l++)
								fprintf(fid, " %d", bm->RBCestimation.RBCspeciesArray[groupIndex].LenComp[fleetIndex][s][yearIndex][it][l]);

							//for (l = 0; l < bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]; l++)
							fprintf(fid, " %s", emptySex);
						} else if (s == 2) {    // males - write female lfs (ignored) then male

							//for (l = 0; l < bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]; l++)
							fprintf(fid, " %s", emptySex);
							for (l = 0; l < bm->RBCestimation.RBCspeciesParam[groupIndex][Nlen_id]; l++)
								fprintf(fid, " %d", bm->RBCestimation.RBCspeciesArray[groupIndex].LenComp[fleetIndex][s][yearIndex][it][l]);
						}
						fprintf(fid, " \n");
					}
				}
			}

		}
	}

	fprintf(fid, "\n");

	free(emptySex);
	emptySex = (char *) malloc(sizeof(char) * 2 * (size_t) bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id]);
	strcpy(emptySex, "");

	for (index = 0; index < (int) bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id]; index++) {
		if (index == 0)
			sprintf(emptySex, "0");
		else
			sprintf(emptySex, "%s 0", emptySex);
	}

	/* Need high resolution age sampling data */
	nAgeBins = (int)bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id];

	fprintf(fid, "%d #_N_age_bins\n", (int) (bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id]));

	for (ageIndex = 0; ageIndex < nAgeBins; ageIndex++) {
		fprintf(fid, " %d", ageIndex + 1);
	}
	fprintf(fid, "\n");

	fprintf(fid, "1 #_N_ageerror_definitions\n");
	for (index = 0; index < bm->RBCestimation.RBCspeciesParam[groupIndex][AccumAge_id]; index++) {
		value = index + 0.5;
		fprintf(fid, " %2.1f", value);

	}
	fprintf(fid, "\n");

	//fprintf(fid, "1 #_N_ageerror_definitions\n");
	for (index = 0; index < bm->RBCestimation.RBCspeciesParam[groupIndex][AccumAge_id]; index++) {
		fprintf(fid, " %2.1f", bm->RBCestimation.RBCspeciesArray[groupIndex].Ageing_error[index]);

	}
	fprintf(fid, "\n");

	for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
		for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
			for (it = 0; it < 3; it++) {
				for (s = 0; s < Nsex_samp; s++) {
					if (bm->RBCestimation.RBCspeciesArray[groupIndex].AgeFltYr[it][fleetIndex][yearIndex] > 0
							&& bm->RBCestimation.RBCspeciesArray[groupIndex].AFss[fleetIndex][s][yearIndex][it] > 10)
						num = num + 1;
				}
			}
		}
	}

	fprintf(fid, "\n%d #_N_Agecomp_obs\n", num);

	fprintf(fid, "1 #_Lbin_method: 1=poplenbins; 2=datalenbins; 3=lengths\n");
	fprintf(fid, "1 #_combine males into females at or below this bin number\n");
	fprintf(fid, "#Yr Seas Flt/Svy Gender Part Ageerr Lbin_lo Lbin_hi Nsamp datavector(female-male)\n");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
			for (it = 0; it < 3; it++) {
				for (s = 0; s < Nsex_samp; s++) {
					if (bm->RBCestimation.RBCspeciesArray[groupIndex].AgeFltYr[it][fleetIndex][yearIndex] > 0
							&& bm->RBCestimation.RBCspeciesArray[groupIndex].AFss[fleetIndex][s][yearIndex][it] > 10) {
						if (it == 1)
							part = 2;   // retained
						else if (it == 2)
							part = 0;   // whole
						else if (it == 3)
							part = 1;   // discarded
						if (Nsex_samp == 1)
							gender = 0;   //combined
						else
							gender = s;

						fprintf(fid, " %d 1 %d %d %d 1 -1 1 %d", (HistYrMin + yearIndex), fleetIndex + 1, gender, part,
								bm->RBCestimation.RBCspeciesArray[groupIndex].AFss[fleetIndex][s][yearIndex][it]);

						if (s == 1) {    // combined or females - write female LFs then male (ignored)

							for (ageIndex = 0; ageIndex <= bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id]; ageIndex++)
								fprintf(fid, " %d", bm->RBCestimation.RBCspeciesArray[groupIndex].AgeComp[fleetIndex][s][yearIndex][it][ageIndex]);

							//for (ageIndex = 0; ageIndex <= bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id]; ageIndex++)
							fprintf(fid, " %s", emptySex);
						} else if (s == 2) {
							// males - write female lfs (ignored) then male

							//for (ageIndex = 0; ageIndex <= bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id]; ageIndex++)
							fprintf(fid, " %s", emptySex);
							for (ageIndex = 0; ageIndex <= bm->RBCestimation.RBCspeciesParam[groupIndex][MaxAge_id]; ageIndex++)
								fprintf(fid, " %d", bm->RBCestimation.RBCspeciesArray[groupIndex].AgeComp[fleetIndex][s][yearIndex][it][ageIndex]);
						}
						fprintf(fid, "\n");
					}
				}
			}
		}
	}

	fprintf(fid, "\n");

	fprintf(fid, "0 #_N_MeanSize-at-Age_obs\n");
    /*
     
     TODO: Create SizeRecord if N_MeanSize-at-Age_obs is ever non-zero
     
	fprintf(fid, "#Yr Seas Flt/Svy Gender Part Ageerr Ignore datavector(female-male)\n");
	fprintf(fid, "#                                          samplesize(female-male)\n");
	for (yearIndex = 0; yearIndex < numYears; yearIndex++) {
		fprintf(fid, " %d", (HistYrMin + yearIndex));
		fprintf(fid, " 1 1 0 0 1 999");
		for (index = 0; index < nAges; index++) {
			fprintf(fid, " %f", bm->SizeRecord[yearIndex][groupIndex][index]);
		}
		for (index = 0; index < nAges; index++) {
			fprintf(fid, " %d"bm->age_sample_size);
		}
		fprintf(fid, "\n");
	}
	fprintf(fid, "\n\n");
    */

	if (bm->RBCestimation.RBCspeciesParam[groupIndex][Regime_shift_assess_id] == 1)  //  for morwong regime shift
			{
		fprintf(fid, "1 #_N_environ_variables\n");

		fprintf(fid, "%d #_N_environ_obs\n", (int)(bm->RBCestimation.RBCspeciesParam[groupIndex][num_enviro_obs_id]));   // was 74
		for (index = 0; index < bm->RBCestimation.RBCspeciesParam[groupIndex][num_enviro_obs_id]; index++)
			fprintf(fid, " %d %e", index + 1, bm->RBCestimation.RBCspeciesArray[groupIndex].EnviroData[0][index]);  // was 1913 + ....  but now set relative to start of model and report only for the first region

	} else {
		fprintf(fid, "0 #_N_environ_variables\n");
		fprintf(fid, "0 #_N_environ_obs\n");
	}

	fprintf(fid, "0 #_N_environ_variables\n");
	fprintf(fid, "0 #_N_environ_obs\n");
	fprintf(fid, "0 # N sizefreq methods to read\n");   // If need this to be non-zero look to 3fish_3seas.dat for layout

	fprintf(fid, "0 # no tag data\n");

	fprintf(fid, "0 # no morphcomp data\n");

	fprintf(fid, "999\n");

	fclose(fid);

}
void Write_SS_Control_File(MSEBoxModel *bm, char *dirName, char *fileName, int maxyr, int groupIndex, int versionID) {

	FILE *fid;
	int disc, phase;
	int _Nblock_Patterns = 0;
	int fleetIndex, yearIndex;
	double mortality, lminf, lmaxf, vbk, cvest, hi, lo, mval, lminm, lmaxm, sv;
	char str[STRLEN];
	int startYear, fisheryIndex;
	int HistYrMin;
    //int Growthage_L1 = (int)(bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L1_id]);
	double Nsexes = (double) (bm->K_num_sexes);
	int *dflt = malloc(sizeof(int) * (size_t)bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]);
	int allregion = 0;    // uses weighted sum over regions, assume assessment doesn't know about regions
	int recruit_sp;

	if (bm->RBCestimation.RBCspeciesArray[groupIndex].CurrentYear == (bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMax_id] - 1))
		HistYrMin = (int)bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id];
        //HistYrMin = 0;
	else
		HistYrMin = (int)bm->RBCestimation.RBCspeciesArray[groupIndex].CurrentYear + 1 - (int)bm->RBCestimation.RBCspeciesParam[groupIndex][HistYrMin_id];

	sscanf(bm->t_units, "seconds since %d-%s", &startYear, str);

	recruit_sp = (int) (FunctGroupArray[groupIndex].speciesParams[flagrecruit_id]);

	sprintf(str, "%s%s%s", dirName, FOLDER_SEP, fileName);

	printf("fileName = %s\n", str);

	if ((fid = fopen(str, "w")) == NULL)
		quit("Create_Control_File: Can't open %s\n", str);

	printf("versionID = %d\n", versionID);

	fprintf(fid, "#V3.24f\n");
	fprintf(fid, "#C growth parameters are estimated\n");
	fprintf(fid, "#C spawner-recruitment bias adjustment Not tuned For optimality\n");
	fprintf(fid, "#_data_and_control_files: simple.dat // simple.ctl\n");
	fprintf(fid, "#_SS-V3.24f-safe-Win64;_08/03/2012;_Stock_Synthesis_by_Richard_Methot_(NOAA)_using_ADMB_11\n");
	fprintf(fid, "%d #_N_Growth_Patterns\n", bm->RBCestimation.SSnumGrowthPatterns);
	fprintf(fid, "%d #_N_Morphs_Within_GrowthPattern\n", (int) (bm->RBCestimation.RBCspeciesParam[groupIndex][num_growth_morphs_id]));

	fprintf(fid, "#_Cond 1 #_Morph_between/within_stdev_ratio (no read if N_morphs=1)\n");
	fprintf(fid, "#_Cond  1 #vector_Morphdist_(-1_in_first_val_gives_normal_approx)\n");
	fprintf(fid, "#\n");

	fprintf(fid, "#_Cond 0  #  N recruitment designs goes here if N_GP*nseas*area>1\n");
	fprintf(fid, "#_Cond 0  #  placeholder for recruitment interaction request\n");
	fprintf(fid, "#_Cond 1 1 1  # example recruitment design element for GP=1, seas=1, area=1\n");
	fprintf(fid, "#\n");
	fprintf(fid, "#_Cond 0 # N_movement_definitions goes here if N_areas > 1\n");
	fprintf(fid, "#_Cond 1.0 # first age that moves (real age at begin of season, not integer) also cond on do_migration>0\n");
	fprintf(fid, "#_Cond 1 1 1 2 4 10 # example move definition for seas=1, morph=1, source=1 dest=2, age1=4, age2=10\n");
	fprintf(fid, "#\n");

	fprintf(fid, "%d #_Nblock_Patterns \n", _Nblock_Patterns);

	fprintf(fid, "#_Cond 0 #_blocks_per_pattern\n");
	fprintf(fid, "# begin and end years of blocks\n");
	fprintf(fid, "#\n");
	fprintf(fid, "%e #_fracfemale \n", (double)(1.0 / bm->K_num_sexes));

	fprintf(fid, "0 #_natM_type:_0=1Parm;1=N_breakpoints;_2=Lorenzen;_3=agespecific;_4=agespec_withseasinterpolate\n");
	fprintf(fid, "  #_no additional input for selected M option; read 1P per morph\n");
	fprintf(fid, "1 # GrowthModel: 1=vonBert with L1&L2; 2=Richards with L1&L2; 3=age_speciific_K; 4=not implemented\n");

	/* These should perhaps be read in from an input file */
	fprintf(fid, "%d #_Growth_Age_for_L1\n", (int) (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L1_id]));
	fprintf(fid, "%d #_Growth_Age_for_L2 (999 to use as Linf)\n", (int) (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L2_id]));
	fprintf(fid, "0 #_SD_add_to_LAA (set to 0.1 for SS2 V1.x compatibility)\n");
	fprintf(fid, "0 #_CV_Growth_Pattern:  0 CV=f(LAA); 1 CV=F(A); 2 SD=F(LAA); 3 SD=F(A); 4 logSD=F(A)\n");
	fprintf(fid, "1 #_maturity_option:  1=length logistic; 2=age logistic; 3=read age-maturity matrix by growth_pattern; 4=read age-fecundity; 5=read fec and wt from wtatage.ss\n");
	fprintf(fid, "#_placeholder for empirical age-maturity by growth pattern\n");
	fprintf(fid, "%d #_First_Mature_Age\n",(int)(FunctGroupArray[groupIndex].speciesParams[age_mat_id] * FunctGroupArray[groupIndex].ageClassSize));
	fprintf(fid, "1 #_fecundity option:(1)eggs=Wt*(a+b*Wt);(2)eggs=a*L^b;(3)eggs=a*Wt^b; (4)eggs=a+b*L; (5)eggs=a+b*W\n");
	fprintf(fid, "0 #_hermaphroditism option:  0=none; 1=age-specific fxn\n");
	fprintf(fid, "%d #_parameter_offset_approach (1=none, 2= M, G, CV_G as offset from female-GP1, 3=like SS2 V1.x)\n",
			(int) (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id]));
	fprintf(fid, "1 #_env/block/dev_adjust_method (1=standard; 2=logistic transform keeps in base parm bounds; 3=standard w/ no bound check)\n");

	fprintf(fid, "#\n");
	fprintf(fid, "#_growth_parms\n");
	fprintf(fid, "#_LO HI INIT PRIOR PR_type SD PHASE env-var use_dev dev_minyr dev_maxyr dev_stddev Block Block_Fxn\n");

	mortality = bm->RBCestimation.RBCspeciesArray[groupIndex].SSMort[0][FEMALE];

	printf("HistYrMin = %d\n", HistYrMin);

	fprintf(fid, " %f %f %f %f 0 0.8 -3 0 0 0 0 0.5 0 0 # NatM_p_1_Fem_GP_1\n", mortality / 2.0, mortality * 2.0, mortality, mortality);

	lminf = bm->RBCestimation.RBCspeciesArray->VBLinf[0][FEMALE]
                * (1.0 - exp( -1.0 * bm->RBCestimation.RBCspeciesArray->VBk[0][FEMALE]
                                * (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L1_id]
                                - bm->RBCestimation.RBCspeciesArray->VBt0[0][FEMALE])));

	fprintf(fid, " %f %f %f %f 0 10 -3 0 0 0 0 0.5 0 0 # L_at_Amin_Fem_GP_1\n", lminf / 2.0, lminf * 2.0, lminf, lminf);

	if (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L2_id] < 999)
		lmaxf = bm->RBCestimation.RBCspeciesArray->VBLinf[0][FEMALE]
				* (1.0 - exp( -1.0 * bm->RBCestimation.RBCspeciesArray->VBk[0][FEMALE]
                                * (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L2_id]
                                    - bm->RBCestimation.RBCspeciesArray->VBt0[0][FEMALE])));
	else
		lmaxf = bm->RBCestimation.RBCspeciesArray->VBLinf[0][FEMALE];     // use Linf

	fprintf(fid, " %f %f %f %f 0 10 -3 0 0 0 0 0.5 0 0 # L_at_Amax_Fem_GP_1\n", lmaxf / 2.0, lmaxf * 2.0, lmaxf, lmaxf);

	vbk = bm->RBCestimation.RBCspeciesArray->VBk[0][FEMALE];
	fprintf(fid, " %f %f %f %f 0 0.8 -3 0 0 0 0 0.5 0 0 # VonBert_K_Fem_GP_1\n", vbk / 3.0, vbk * 3.0, vbk, vbk);

	cvest = bm->RBCestimation.RBCspeciesArray->CvLA0[0][0];
	fprintf(fid, " %f %f %f %f 0 0.8 -2 0 0 0 0 0.5 0 0 # CV_young_Fem_GP_1\n", cvest / 3.0, cvest * 3.0, cvest, cvest);

	if (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id] == 3) {
		cvest = log(fabs(bm->RBCestimation.RBCspeciesArray->CvLAmax[0][0]) / fabs(bm->RBCestimation.RBCspeciesArray->CvLA0[0][0]));
		lo = -1.0;
		hi = 1.0;
	} else {
		cvest = fabs(bm->RBCestimation.RBCspeciesArray->CvLAmax[0][0]);
		lo = cvest / 3.0;
		hi = cvest * 3.0;
	}

	fprintf(fid, " %f %f %f %f 0 0.8 -3 0 0 0 0 0.5 0 0 #CV_old_Fem_GP_1\n", lo, hi, cvest, cvest);

	if (Nsexes == 2) {
		if (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id] == 3) {
			mval = log(fabs(bm->RBCestimation.RBCspeciesArray[groupIndex].SSMort[0][FEMALE]) / fabs(bm->RBCestimation.RBCspeciesArray[groupIndex].SSMort[0][FEMALE]));
			lo = -1.0;
			hi = 1.0;
		} else {
			mval = fabs(bm->RBCestimation.RBCspeciesArray[groupIndex].SSMort[0][FEMALE]);
			lo = mval / 2.0;
			hi = mval * 2.0;
		}

		fprintf(fid, " %f %f %f %f 0 0.8 -3 0 0 0 0 0.5 0 0 # NatM_p_1_Male_GP_1\n", lo, hi, mval, mval);

		if (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id] == 3) {
			lminm = bm->RBCestimation.RBCspeciesArray[groupIndex].VBLinf[0][FEMALE]
					* (1.0 - exp( -1.0 * bm->RBCestimation.RBCspeciesArray[groupIndex].VBk[0][FEMALE]
                                    * (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L1_id]
                                    - bm->RBCestimation.RBCspeciesArray[groupIndex].VBt0[0][FEMALE])));
			lminm = log(lminm / lminf);
			//lmin = log(MeanLenAge[0][FEMALE][Growthage_L1])/MeanLenAge[0][FEMALE][Growthage_L1]);
			lo = -1.0;
			hi = 1.0;
		} else {
			lminm = bm->RBCestimation.RBCspeciesArray[groupIndex].VBLinf[0][FEMALE]
					* (1.0 - exp( -1.0 * bm->RBCestimation.RBCspeciesArray[groupIndex].VBk[0][FEMALE]
                                    * (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L1_id]
                                    - bm->RBCestimation.RBCspeciesArray[groupIndex].VBt0[0][FEMALE])));
			//lmin = MeanLenAge[0][FEMALE][Growthage_L1];
			lo = lminm / 2.0;
			hi = lminm * 2.0;
		}
		fprintf(fid, " %f %f %f %f 0 10 -3 0 0 0 0 0.5 0 0 # L_at_Amin_Male_GP_1\n", lo, hi, lminm, lminm);

		if (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L2_id] < 999)
			lmaxm = bm->RBCestimation.RBCspeciesArray[groupIndex].VBLinf[0][FEMALE]
					* (1.0 - exp(-1.0 * bm->RBCestimation.RBCspeciesArray[groupIndex].VBk[0][FEMALE]
                                    * (bm->RBCestimation.RBCspeciesParam[groupIndex][Growthage_L2_id]
                                    - bm->RBCestimation.RBCspeciesArray[groupIndex].VBt0[0][FEMALE])));
		else
			lmaxm = bm->RBCestimation.RBCspeciesArray[groupIndex].VBLinf[0][FEMALE];

		if (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id] == 3) {
			lmaxm = log(lmaxm / lmaxf);
			//lmaxm = log(MeanLenAge[0][FEMALE][MaxAge][HistYrMin]/MeanLenAge[0][FEMALE][MaxAge][HistYrMin]);
			lo = -1.0;
			hi = 1.0;
		} else {
			//lmax = MeanLenAge[0][FEMALE][MaxAge][HistYrMin];
			lo = lmaxm / 2.0;
			hi = lmaxm * 2.0;
		}
		fprintf(fid, " %f %f %f %f 0 10 -3 0 0 0 0 0.5 0 0 # L_at_Amax_Male_GP_1\n", lo, hi, lmaxm, lmaxm);

		if (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id] == 3) {
			vbk = log(bm->RBCestimation.RBCspeciesArray[groupIndex].VBk[0][FEMALE] / bm->RBCestimation.RBCspeciesArray[groupIndex].VBk[0][FEMALE]);
			lo = -1.0;
			hi = 1.0;
		} else {
			vbk = bm->RBCestimation.RBCspeciesArray[groupIndex].VBk[0][FEMALE];
			lo = vbk / 2.0;
			hi = vbk * 2.0;
		}

		fprintf(fid, " %f %f %f %f 0 0.8 -3 0 0 0 0 0.5 0 0 # VonBert_K_Male_GP_1\n", lo, hi, vbk, vbk);

		if (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id] == 3) {
			cvest = log(bm->RBCestimation.RBCspeciesArray[groupIndex].CvLA0[0][1] / bm->RBCestimation.RBCspeciesArray[groupIndex].CvLA0[0][0]);
			lo = -1.0;
			hi = 1.0;
		} else {
			cvest = bm->RBCestimation.RBCspeciesArray[groupIndex].CvLA0[0][1];
			lo = cvest / 3.0;
			hi = cvest * 3.0;
		}

		fprintf(fid, " %f %f %f %f 0 0.8 -3 0 0 0 0 0.5 0 0 # CV_young_Male_GP_1\n", lo, hi, cvest, cvest);

		if (bm->RBCestimation.RBCspeciesParam[groupIndex][MG_offset_id] == 3) {
			cvest = log(bm->RBCestimation.RBCspeciesArray[groupIndex].CvLAmax[0][0] / bm->RBCestimation.RBCspeciesArray[groupIndex].CvLA0[0][0]);
			lo = -1.0;
			hi = 1.0;
		} else {
			cvest = bm->RBCestimation.RBCspeciesArray[groupIndex].CvLAmax[0][0];
			lo = cvest / 3.0;
			hi = cvest * 3.0;
		}
		fprintf(fid, " %f %f %f %f 0 0.8 -3 0 0 0 0 0.5 0 0 # CV_old_Male_GP_1\n", lo, hi, cvest, cvest);

	}

	fprintf(fid, "# wt-len and mat-len parameters\n");

	fprintf(fid, "#   LO HI INIT PRIOR PR_TYPE SD PHASE env-var use-dev dev_minyr dev_maxyr dev_stddev block block_fxn\n");

	fprintf(fid, " -3 3 %f %f 0 10 -3 0 0 0 0 0.5 0 0 # Wtlen_1_Fem\n", bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_a[1][FEMALE],
			bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_a[1][FEMALE]);

	fprintf(fid, " 0 6 %f %f 0 10 -3 0 0 0 0 0.5 0 0 # Wtlen_2_Fem\n", bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_b[1][FEMALE],
			bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_b[1][FEMALE]);

	fprintf(fid, " 0 6 %f %f 0 10 -3 0 0 0 0 0.5 0 0 # Wtlen_2_Fem\n", bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_b[1][FEMALE],
			bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_b[1][FEMALE]);

	fprintf(fid, " %f %f %f %f 0 10 -3 0 0 0 0 0.5 0 0 # Mat50_Fem\n", bm->RBCestimation.RBCspeciesParam[groupIndex][Maturity_Inflect_id] / 3.0,
			bm->RBCestimation.RBCspeciesParam[groupIndex][Maturity_Inflect_id] * 3.0, bm->RBCestimation.RBCspeciesParam[groupIndex][Maturity_Inflect_id],
			bm->RBCestimation.RBCspeciesParam[groupIndex][Maturity_Inflect_id]);

	fprintf(fid, " -3 3 %f %f 0 10 -3 0 0 0 0 0.5 0 0 # Mat_slope_Fem\n", bm->RBCestimation.RBCspeciesParam[groupIndex][Maturity_Slope_id],
			bm->RBCestimation.RBCspeciesParam[groupIndex][Maturity_Slope_id]);

	fprintf(fid, " -3 3 1 1 0 10 -3 0 0 0 0 0.5 0 0 # Eggs/kg_inter_Fem\n");
	fprintf(fid, " -3 3 0 0 0 10 -3 0 0 0 0 0.5 0 0 # Eggs/kg_slope_wt_Fem\n");

	if (Nsexes > 1) {
		fprintf(fid, " -3 3 %f %f  0 10 -3 0 0 0 0 0.5 0 0 # Wtlen_1_Fem\n", bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_a[1][FEMALE],
				bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_a[1][FEMALE]);

		fprintf(fid, " 0 6 %f %f  0 10 -3 0 0 0 0 0.5 0 0 # Wtlen_2_Fem\n", bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_b[1][FEMALE],
				bm->RBCestimation.RBCspeciesArray[groupIndex].Wtlen_b[1][FEMALE]);

	}

	fprintf(fid, " 0 0 0 0 -1 0 -3 0 0 0 0 0 0 0 # RecrDist_GP_1\n");
	fprintf(fid, " 0 0 0 0 -1 0 -3 0 0 0 0 0 0 0 # RecrDist_Area_1\n");
	fprintf(fid, " 0 0 0 0 -1 0 -3 0 0 0 0 0 0 0 # RecrDist_Seas_1\n");
	fprintf(fid, " 1 1 1 1 -1 0 -3 0 0 0 0 0 0 0 # CohortGrowDev\n");

	fprintf(fid, "#\n");
	fprintf(fid, "#_Cond 0  #custom_MG-env_setup (0/1)\n");
	fprintf(fid, "#_Cond -2 2 0 0 -1 99 -2 #_placeholder when no MG-environ parameters\n");

	fprintf(fid, "#\n");
	fprintf(fid, "#_Cond 0  #custom_MG-block_setup (0/1)\n");
	fprintf(fid, "#_Cond -2 2 0 0 -1 99 -2 #_placeholder when no MG-block parameters\n");
	fprintf(fid, "#_Cond No MG parm trends \n");
	fprintf(fid, "#\n");
	fprintf(fid, "#_seasonal_effects_on_biology_parms\n");
	fprintf(fid, " 0 0 0 0 0 0 0 0 0 0 #_femwtlen1,femwtlen2,mat1,mat2,fec1,fec2,Malewtlen1,malewtlen2,L1,K\n");
	fprintf(fid, "#_Cond -2 2 0 0 -1 99 -2 #_placeholder when no seasonal MG parameters\n");
	fprintf(fid, "#\n");
	fprintf(fid, "#_Cond -4 #_MGparm_Dev_Phase\n");
	fprintf(fid, "#\n");

	fprintf(fid, "#_Spawner-Recruitment\n");
	if (recruit_sp == BevHolt_recruit) {

		fprintf(fid, "3 #_SR_function: 2=Ricker; 3=std_B-H; 4=SCAA; 5=Hockey; 6=B-H_flattop; 7=survival_3Parm\n");
		fprintf(fid, "#_LO HI INIT PRIOR PR_type SD PHASE\n");
		fprintf(fid, " 3 31 9.5 9.3 0 10 1 # SR_LN(R0)\n");

		fprintf(fid, " 0.2 1 %f 0.7 0 0.2 %f  1 # SR_BH_steep\n", bm->RBCestimation.RBCspeciesParam[groupIndex][Hsteep_id],
				bm->RBCestimation.RBCspeciesParam[groupIndex][T1_steep_phase_id]);

		fprintf(fid, " 0 2 %f %f 0 0.8 -2 # SR_sigmaR\n", bm->RBCestimation.RBCspeciesParam[groupIndex][SigmaR1_id],
				bm->RBCestimation.RBCspeciesParam[groupIndex][SigmaR1_id]);

		fprintf(fid, " -5 5 0.1 0 -1 1 -3 # SR_envlink\n");
		fprintf(fid, " -5 5 0 0 -1 1 -4 # SR_R1_offset\n");
		fprintf(fid, " 0 0 0 0 -1 0 -99 # SR_autocorr\n");

	} else {
		quit("recruit option not supported \n");
	}

	if (bm->RBCestimation.RBCspeciesParam[groupIndex][Regime_shift_assess_id])  //  for morwong regime shift
	{
		fprintf(fid, "1    # index of environmental variable");
		fprintf(fid, "2    # SR env target 0=1,1=devs,2=R0,3=steepness");
	} else {
		fprintf(fid, "0    # index of environmental variable");
		fprintf(fid, "0    # SR env target 0=1,1=devs,2=R0,3=steepness");
	}

	fprintf(fid, "0 #_SR_env_link\n");
	fprintf(fid, "0 #_SR_env_target_0=none;1=devs;_2=R0;_3=steepness\n");

	fprintf(fid, "1 #do_recdev:  0=none; 1=devvector; 2=simple deviations\n");

	fprintf(fid, "%d # first year of main recr_devs; early devs can preceed this era\n", (int) (bm->RBCestimation.RBCspeciesParam[groupIndex][RecDevMinYr_id]));
	fprintf(fid, "%d # last year of main recr_devs; forecast devs start in following year\n",
			maxyr - (int) bm->RBCestimation.RBCspeciesParam[groupIndex][RecDevBack_id]);

	fprintf(fid, "3 #_recdev phase \n");
	fprintf(fid, "1 # (0/1) to read 13 advanced options\n");
	fprintf(fid, " 0 #_recdev_early_start (0=none; neg value makes relative to recdev_start)\n");
	fprintf(fid, " -4 #_recdev_early_phase\n");
	fprintf(fid, " 0 #_forecast_recruitment phase (incl. late recr) (0 value resets to maxphase+1)\n");
	fprintf(fid, " 1000 #_lambda for Fcast_recr_like occurring before endyr+1\n");
	fprintf(fid, " %d #_last_early_yr_nobias_adj_in_MPD\n", HistYrMin - bm->RBCestimation.SSnoBiasAdj);
	fprintf(fid, " %d #_first_yr_fullbias_adj_in_MPD\n", (int) bm->RBCestimation.RBCspeciesParam[groupIndex][RecDevMinYr_id]);

	fprintf(fid, " %d #last_yr_fullbias_adj_in_MPD\n", maxyr - (int) bm->RBCestimation.RBCspeciesParam[groupIndex][RecDevBack_id]);

	fprintf(fid, " %d #_first_recent_yr_nobias_adj_in_MPD\n", maxyr - (int) bm->RBCestimation.RBCspeciesParam[groupIndex][RecDevBack_id] + 1);
	fprintf(fid, " 1 #_max_bias_adj_in_MPD (-1 to override ramp and set biasadj=1.0 for all estimated recdevs)\n");
	fprintf(fid, " 0 #_period of cycles in recruitment (N parms read below)\n");

	fprintf(fid, " -5 #min rec_dev\n");
	fprintf(fid, " 5 #max rec_dev\n");
	fprintf(fid, " 0 #_read_recdevs\n");
	fprintf(fid, "#_end of advanced SR options\n");
	fprintf(fid, "#\n");

// Done/

	fprintf(fid, "#\n");
	fprintf(fid, "#Fishing Mortality info \n");
	fprintf(fid, "%e # F ballpark for tuning early phases\n", bm->RBCestimation.RBCspeciesParam[groupIndex][BallParkF_id]); //0.2
	fprintf(fid, "%d # F ballpark year (neg value to disable)\n", (int)(bm->RBCestimation.RBCspeciesParam[groupIndex][BallParkYr_id]));
	fprintf(fid, "3 # F_Method:  1=Pope; 2=instan. F; 3=hybrid (hybrid is recommended)\n");
	fprintf(fid, "4 # max F or harvest rate, depends on F_Method\n");
	fprintf(fid, "# no additional F input needed for Fmethod 1\n");

	fprintf(fid, "# if Fmethod=2; read overall start F value; overall phase; N detailed inputs to read\n");
	fprintf(fid, "# if Fmethod=3; read N iterations for tuning for Fmethod 3\n");
	fprintf(fid, "5  # N iterations for tuning F in hybrid method (recommend 3 to 7)\n");
	fprintf(fid, "#\n");
	fprintf(fid, "#_initial_F_parms\n");
	fprintf(fid, "#_LO HI INIT PRIOR PR_type SD PHASE\n");
	for (fisheryIndex = 0; fisheryIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fisheryIndex++) {
		fprintf(fid, " 0 1 0 0.01 0 99 -1 # InitF_1FISHERY%d\n", fisheryIndex + 1);
	}
	fprintf(fid, "#\n");

	fprintf(fid, "#_Q_setup\n");
	fprintf(fid,
			" # Q_type options:  <0=mirror, 0=float_nobiasadj, 1=float_biasadj, 2=parm_nobiasadj, 3=parm_w_random_dev, 4=parm_w_randwalk, 5=mean_unbiased_float_assign_to_parm\n");
	fprintf(fid, "#_for_env-var:_enter_index_of_the_env-var_to_be_linked\n");
	fprintf(fid, "#_Den-dep  env-var  extra_se  Q_type\n");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " 0 0 0 0 # 1 FISHERY%d\n", fleetIndex + 1);
	}

	fprintf(fid, "\n#\n");

	//done.
//
//	fprintf(fid, "#_Cond 0 #_If q has random component, then 0=read one parm for each fleet with random q; 1=read a parm for each year of index\n");
//	fprintf(fid, "#_Q_parms(if_any)\n");
//	fprintf(fid, "# LO HI INIT PRIOR PR_type SD PHASE\n");
//	fprintf(fid, " 0 0.5 0 0.05 1 0 -4 # Q_extraSD_2_SURVEY1\n");
//	fprintf(fid, " -7 5 0.515263 0 -1 1 1 # Q_base_2_SURVEY1\n");
//	fprintf(fid, "\n\n");

	fprintf(fid, "#\n");
	fprintf(fid, "#_size_selex_types\n");

	fprintf(fid, "#discard_options:_0=none;_1=define_retention;_2=retention&mortality;_3=all_discarded_dead\n");
	fprintf(fid, "#_Pattern Discard Male Special\n");

	for (yearIndex = HistYrMin; yearIndex <= maxyr; yearIndex++)
		for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++)
			if (bm->RBCestimation.RBCspeciesArray[groupIndex].DiscData[fleetIndex][allregion][yearIndex] > 0)
				dflt[fleetIndex] = 1;
			else
				dflt[fleetIndex] = 0;
	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		if (dflt[fleetIndex] > 0)
			disc = 1;
		else
			disc = 0;

		fprintf(fid, " 1 %d 0 0 # FISHERY%d\n", disc, fleetIndex + 1);

	}
//
//	for (fleetIndex = 0; fleetIndex < numfleets; fleetIndex++) {
//		fprintf(fid, " 1 0 0 0 # 1 FISHERY%d\n", fleetIndex + 1);
//	}
//	for (surveyIndex = 0; surveyIndex < numsurveys; surveyIndex++) {
//		fprintf(fid, " 1 0 0 0 # 2 SURVEY%d\n", surveyIndex + 1);
//	}

	fprintf(fid, "\n");
	fprintf(fid, "#\n");
	fprintf(fid, "#_age_selex_types\n");
	fprintf(fid, "#_Pattern ___ Male Special\n");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " %d 0 0 0 # FISHERY %d\n", (int) (bm->RBCestimation.RBCspeciesParam[groupIndex][Agesel_Pattern_id]), fleetIndex + 1);
	}

	//Done
	fprintf(fid, "#Selectivity parameters\n");
	fprintf(fid, "#_LO HI INIT PRIOR PR_type SD PHASE env-var use_dev dev_minyr dev_maxyr dev_stddev Block Block_Fxn\n");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {

		fprintf(fid, " Fleet %d", fleetIndex + 1);

		sv = bm->RBCestimation.RBCspeciesArray[groupIndex].Start_SelInflect[fleetIndex];
		phase = 2;
		if (sv < 0) {
			sv = -sv;
			phase = -2;
		}
		fprintf(fid, " %f %f %f %f 0 99 %d 0 0 0 0 0 0 0 # inflection for logistic", sv / 2.0, sv * 2.0, sv, sv, phase);

		sv = bm->RBCestimation.RBCspeciesArray[groupIndex].Start_SelWidth[fleetIndex];
		phase = 3;
		if (sv < 0) {
			sv = -sv;
			phase = -3;
		}

		fprintf(fid, " %f %f %f %f 0 99 %d 0 0 0 0 0 0 0 # width for logistic", sv / 2.0, sv * 2.0, sv, sv, phase);

		if (dflt[fleetIndex] > 0) { // if discard data

			sv = bm->RBCestimation.RBCspeciesArray[groupIndex].Start_RetInflect[fleetIndex];
			phase = 3;
			if (sv < 0) {
				sv = -sv;
				phase = -3;
			}

			fprintf(fid, " %f %f %f %f 0 99 %d 0 0 0 0 0 0 0 #  inflection for logistic retention", sv / 2.0, sv * 2.0, sv, sv, phase);

			sv = bm->RBCestimation.RBCspeciesArray[groupIndex].Start_RetSlope[fleetIndex];
			phase = 4;
			if (sv < 0) {
				sv = -sv;
				phase = -4;
			}

			fprintf(fid, " 0.2 %f %f %f 0 99 %d 0 0 0 0 0 0 0 #  slope for logistic retention", sv * 2.0, sv, sv, phase);

			fprintf(fid, " 0.001 1 1.0 0.1 0 99 -3 0 0 0 0 0 0 0\n");

			fprintf(fid, " -10 10 0 1 0 99 -3 0 0 0 0 0 0 0\n");

		}
	}

	if (bm->RBCestimation.RBCspeciesParam[groupIndex][Agesel_Pattern_id] == 11) {

		fprintf(fid, "# Age parameters");

		for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {

			fprintf(fid, "# Fleet %d\n", fleetIndex + 1);

			fprintf(fid, " 0 %d 0.1 0.1 0 99 -3 0 0 0 0 0 0 0 #min age", (int) bm->RBCestimation.RBCspeciesParam[groupIndex][AccumAge_id]);

			fprintf(fid, " 0 %d %d %d 0 99 -3 0 0 0 0 0 0 0 #max age", (int) bm->RBCestimation.RBCspeciesParam[groupIndex][AccumAge_id],
					(int) bm->RBCestimation.RBCspeciesParam[groupIndex][AccumAge_id], (int) bm->RBCestimation.RBCspeciesParam[groupIndex][AccumAge_id]);

		}
		fprintf(fid, "\n");
	}

	fprintf(fid, "#_Cond 0 #_custom_sel-env_setup (0/1) \n");
	fprintf(fid, "#_Cond -2 2 0 0 -1 99 -2 #_placeholder when no enviro fxns\n");
	fprintf(fid, "#_Cond 0 #_custom_sel-blk_setup (0/1) \n");
	fprintf(fid, "#_Cond -2 2 0 0 -1 99 -2 #_placeholder when no block usage\n");
	fprintf(fid, "#_Cond No selex parm trends \n");
	fprintf(fid, "#_Cond -4 # placeholder for selparm_Dev_Phase\n");
	fprintf(fid, "#_Cond 0 #_env/block/dev_adjust_method (1=standard; 2=logistic trans to keep in base parm bounds; 3=standard w/ no bound check)\n");
	fprintf(fid, "#\n");
	fprintf(fid, "# Tag loss and Tag reporting parameters go next\n");
	fprintf(fid, "0  # TG_custom:  0=no read; 1=read if tags exist\n");
	fprintf(fid, "#_Cond -6 6 1 1 2 0.01 -4 0 0 0 0 0 0 0  #_placeholder if no parameters\n");
	fprintf(fid, "#\n");
	fprintf(fid, "1 #_Variance_adjustments_to_input_values\n");

	// done.

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " %f", bm->RBCestimation.RBCspeciesArray[groupIndex].Varadj_CPUE[fleetIndex]);
	}
	fprintf(fid, "      # add to CPUE CV\n");

	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " %f", bm->RBCestimation.RBCspeciesArray[groupIndex].Varadj_discard[fleetIndex]);
	}
	fprintf(fid, "      # add to discard stdev\n");
	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " 0");
	}
	fprintf(fid, "      # add to mean bodywt CV\n");
	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " %f", bm->RBCestimation.RBCspeciesArray[groupIndex].Varadj_length[fleetIndex]);
	}
	fprintf(fid, "      # mult by length comp\n");
	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " %f", bm->RBCestimation.RBCspeciesArray[groupIndex].Varadj_age[fleetIndex]);
	}
	fprintf(fid, "      # mult by age comp\n");
	for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
		fprintf(fid, " 1");
	}
	fprintf(fid, "     # mult by mean size at age\n");

	fprintf(fid, "#\n");
	fprintf(fid, "4 #_maxlambdaphase\n");
	fprintf(fid, "1 #_sd_offset\n");
	fprintf(fid, "#\n");

   if (bm->RBCestimation.RBCspeciesParam[groupIndex][NumChangeLambda_id] > 0) {

		fprintf(fid, "#Lambdas\n");
		fprintf(fid, "%d      #  number of changes to make to default lambdas\n", (int)(bm->RBCestimation.RBCspeciesParam[groupIndex][NumChangeLambda_id]));
        fprintf(fid,"# Like_comp codes:  1=surv; 2=disc; 3=mnwt; 4=length; 5=age; 6=SizeFreq; 7=sizeage; 8=catch;\n");
        fprintf(fid, "# 9=init_equ_catch; 10=recrdev; 11=parm_prior; 12=parm_dev; 13=CrashPen; 14=Morphcomp; 15=Tag-comp; 16=Tag-negbin\n");

		fprintf(fid, "#component  fleet phase lambda sizefreq_meth\n");
		for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
			fprintf(fid, " 4 %d 1 0.1 1\n", fleetIndex + 1);
		}
		for (fleetIndex = 0; fleetIndex < bm->RBCestimation.RBCspeciesParam[groupIndex][NumFisheries_id]; fleetIndex++) {
			fprintf(fid, " 5 %d 1 0.1 1\n", fleetIndex + 1);
		}
	} else {
		fprintf(fid, "0   #  number of changes to make to default lambdas\n");
	}

	fprintf(fid, "# lambdas (for info only; columns are phases)\n");
	fprintf(fid, "#  0 0 0 0 #_CPUE/survey:_1\n");
	fprintf(fid, "#  1 1 1 1 #_CPUE/survey:_2\n");
	fprintf(fid, "#  1 1 1 1 #_lencomp:_1\n");
	fprintf(fid, "#  1 1 1 1 #_lencomp:_2\n");
	fprintf(fid, "#  1 1 1 1 #_agecomp:_1\n");
	fprintf(fid, "#  1 1 1 1 #_agecomp:_2\n");
	fprintf(fid, "#  1 1 1 1 #_size-age:_1\n");
	fprintf(fid, "#  1 1 1 1 #_size-age:_2\n");
	fprintf(fid, "#  1 1 1 1 #_init_equ_catch\n");
	fprintf(fid, "#  1 1 1 1 #_recruitments\n");
	fprintf(fid, "#  1 1 1 1 #_parameter-priors\n");
	fprintf(fid, "#  1 1 1 1 #_parameter-dev-vectors\n");
	fprintf(fid, "#  1 1 1 1 #_crashPenLambda\n");
	fprintf(fid, "0 # (0/1) read specs for more stddev reporting \n");

	fprintf(fid, "\n");

	fprintf(fid, "999\n");
	free(dflt);

	fclose(fid);

}
