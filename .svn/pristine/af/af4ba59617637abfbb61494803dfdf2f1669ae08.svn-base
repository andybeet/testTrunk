/**
 \file
 \brief C file for running the setup of ecological models
 \ingroup atEcology

 File:		atbiolsetup.c
 Created:	21/9/2004
 Author:		Beth Fulton,   CSIRO Marine Laboratories,  2004
 Based on work by Ouyang and Fulton for Port Phillip Bay
 Purpose:	C file for running the setup of ecological models
 in south east.

 Note:
 1. Some names of variables or subroutines are self-explaining.
 2. In the names or comments, WC means Water Column, Sm Sediment.

 Revisions: 8/8/2004 Created msebiolsetup.c from the sebiolsetup.c file

 15/8/2004 Cut-back to only contain parameters and arrays relevant
 to biological and ecological processes (except for general
 arrays now stored in MSEBoxModel structure, which are created
 and initialised in msebm.c)

 17/8/2004 Many species specific parameter arrays (especially for
 vertebrate groups) moved to bm->SP_prms

 21/9/2004 Created atbiolsetup.c from msebiolsetup.c. And renamed
 FSL, FSO, FSF, FST and FSG to generic names so apply to
 other models/generic case.
 FSL -> FDC  (Ling -> Demersal_DC_Fish)
 FSO -> FDO  (Orange_Roughy -> Demersal_O_Fish)
 FSF -> FDB  (Flathead -> Demersal_B_Fish)
 FST -> FVO  (Bluefin_Tuna -> Pisciv_O_Fish)
 FSG -> SHB  (Gummy_Shark -> Shark_B)

 22/9/2004 Replaced numbers in switch statements with id
 guild numbers. Also added age parameter calls for
 aging and reproduction of invertebrates

 30/9/2004 Added read-in of extra trophic link parameters for exiting
 groups so they match the generic diet matrix (see comments
 in atprocess.c)

 15/10/2004 Added BML and BFF.

 19/10/2004 Added Prawns

 24/10/2004 Added soft sediments

 26/10/2004 Added FBP, FVB, SP, FDE, FDF, SHR, SSK, REP, WDG. Also
 removed juvenileCEP as now handled explicitly via cephalopod
 aging and migration

 14/11/2004 Put all feeding preferences into arrays rather than
 individual parameters

 15/11/2004 Put in flagseperate so CEP and PWN can be individual
 groups without size structure

 6/12/2004 Mapped KMIGa to Migration so same call can always be used

 6/12/2004 Corrected typo in getVertIndex (assigning WHB values to WHT)

 19/1/2005 Added Microphytobenthos (MB) and corrected feeding id
 match-up so differentiates between detritus in water column ans
 sediments.

 2/2/2005 Added Microphytobenthos as cover type and took out limit on number
 of groups that can migrate out.

 28/3/2005 Added bm->do_availflag, BioFlag[] and ActiveFlag[] so that
 can check if only want active groups advected (so rounding errors
 don't add up to non-negligible flows in backwaters).

 29/3/2005 Added bm->DIN_id so can track "stock size" of DIN. Increased
 totbiom, totfishpop, totinitpop from bm->K_num_vert_sp + K_num_prey
 entries to bm->K_num_tot_sp to allow for the DIN entry.

 9/4/2005 Added parameters needed for new generalised form of invertebrate
 equations (using Invert_Activities())

 13/7/2005 Added readkeyprm_darray_checked() and extended readValue() so
 that knows what data is expected so that can check on readin for
 obvious parameter errors

 16/8/2005 Replaced numbers in readValue() and readkeyprm_darray_checked()
 calls with read-in type id numbers (no_checking, binary_check,
 proportion_check, probability_check, integer_check). Also put
 in default case for all switch statements

 1/9/2005 Added multiple stock structure (horizontal and vertical)

 2/9/2005 Moved KDENR to array to accomodate recruitment to multiple stocks

 4/10/2005 Added boundary_check() routine and recruit_hdistrib check in
 initPopulations() routine to avoid some of the typical movement model
 errors associated with mistakes in configuration and parameter files

 1/12/2005 Corrected omission of Kcov_SHB parameters.

 24/2/2006 Added flagrandom read-in so can turn off stochastic components

 3/4/2006 Moved handling of first year carry over recruits from
 initBiology() to AnnualBiology()
 29/01/2008 Bec Gorton
 Changed the file input code to use the new file io algorithm. Files are first
 parsed to put start and end tags around parameter groups. The file is then
 parsed a second time. Each start tag is associated with a function that is
 used to load the data from the input files into the arrays.

 26-05-2008 Bec Gorton
 Changed all references from bm->VERTind to the tracer arrays associated with
 each functional group.
 The trnamelist is now automatically generated by the name in the functional group
 input file. This also means the original tracer values

 14-06-2008 Bec Gorton
 Updated code to dynamically build the bm->dinfo array instead of
 reading in a blank diagnostic file on start up.

 16/7/2008 Bec Gorton
 Changed the Box_Bio_Process code to store the resulting tracer values straigh into
 newwctr and newsedtr instead of Yp. This means Yp is no longer needed.
 This also means that the values of Yp do not need to be copied back to newwctr and
 newsedtr in the main loop.

 12/08/2008 Bec Gorton
 Moved some of the invert properties into the new invertProps structure in the
 FunctGroup structure. Tyring to get a more OO approach to functional group properties.

 01/10/2008 Bec Gorton
 Moved the bm->pSPEat values into the funct group structure so that they
 could easily be changed to cohort dependant.

 02/10/2008 Bec Gorton
 bm->pSPVERTeat values for jPWN and jCEP are now set to the CEP and PWN values.

 24/10/2008 Bec Gorton
 Removed the spPREYid array as no longer needed.

 03/11/2008 Bec Gorton
 Moved the BBthresh and BBdamp values into the speciesParam arrays so that
 we can make this a generic feature.

 05/11/2008 Bec Gorton
 Moved the KDEP values into the speciesParams. This is now read in via the atbiolSpeciesParamIO.c functions.
 The KUP and KLP values are also set in the ecol_readSpeciesParam function.

 16/01/2009 Bec Gorton
 Changed bm->targetspbiom to store values for each species - then we just check the isImpacted flag
 for each functional group.

 30-01-2009 Bec Gorton
 Added a check on Schange_max_num value before freeing the SChange array.

 20-01-2009 Bec Gorton
 Added the age_structure_prey species param. If this is true then the prey availability
 value in the bm->pSPageeat array is used instead of the more generic pSPEat value.
 Resized the following arrays:
 totden
 leftden
 currentden
 newden
 VERTinfo
 init_stock_struct_prop
 bm->stock_struct_prop
 These all had dimensions of bm->K_num_vert_sp and thats been changed to bm_>K_num_tot_sp.

 Moved the spMinMax array into the FunctGroup structure.

 21-01-2009 Bec Gorton
 Moving the KTUR and KIIR values into the species parameters. Also moved the following
 parameters that were stored in the invertProps into the species params:
 vl, ht, KN, KS, KF, KI_T15, KI, KLYS, SP_IRR, mD, mO, mS, KDEP. KO2, KO2LIM, max, low, thresh
 and sat.

 02-20-2009 Beth Fulton
 Added the new HomeRange code. Also change the small variable to be called small_num.

 19-03-2009 Bec Gorton
 Got rid of the cover2guild array - the coverTrace values in the FunctGroupArray is now used.
 Got rid of the epiPREYid and epiSPnid2guild arrays. We can now just use the habitat type to pick
 up epibenthic prey.
 Removed MOVEid - no longer used.
 Removed InvertMOVEID - just use the tracer values in the FunctGroupArray.

 06-04-2009 Bec Gorton
 Added code to free up the homerange data structures at the end of the model run.

 14-04-2009 Bec Gorton
 Added code to check that the projection has been set in the bgm file is the
 lim_sun_flag is set to true. If there is no projection in the bgm file
 then the model will quit with an error message.

 16-04-2009 Bec Gorton
 Moved the mS_SG_T15 and mS_MA_T15 values into the species params array.

 22-04-2009 Bec Gorton
 Moved many of the IO functions into the atBiologyXMLParamIO file.

 10-06-2009 Bec Gorton
 Added the SEAGRASS invertbrate type.

 15-06-2009 Bec Gorton
 Resize the readinpopratio array to tot_num_species.

 16-06-2009 Bec Gorton
 Removed the distribINVERT_VERTICAL array - its no longer used. All the invert values are stored
 in the same array as the vertebrates.

 23-06-2009 Bec Gorton
 Removed all references to FunctGroupArray[guild].groupCode in atecology.
 Removed the readValue function.

 06-07-2009 Bec Gorton
 Moved the code that sets up the species param strings into the atlantisUtil lib.

 23-07-2009 Bec Gorton
 Added support for the light attenuation due to sediment in the water column. Changes
 to input files are required and documented on the wiki.

 02-11-2009 Bec Gorton
 Fixed a bug in the diet matrix setup code.

 15-12-2009 Bec Gorton
 Trunk merge 1428 - Added the calcMLinearMort, calcMQuadMort and calcMPredMort arrays to store different mortality values.
 Also fixed a bug in the code that added the biomass of species out of the model - for vertebrates it
 was calculating the biomass when it should have been using the numbers tracer.

 29-01-2010 Bec Gorton
 Removed the setBiologyIDMatches and setFisheriesStatIndex functions.
 Also removed the code that set the preyID array values as this is no longer used.
 Update the mortality calculation code.

 10-02-2010 Bec Gorton
 Change the preyamt array to be local to the Total_Verts_And_Migration function instead
 of in the atEcologyModule.
 Deleted the distribVERT_VERTICAL arrays as it no longer required. All the species data is
 read into a single array.
 Removed a number of functions that were never called and started renaming functions to
 conform to the name convention.

 21-02-2010 Bec Gorton
 Removed the COVERid and the spName arrays.

 22-02-2010 Bec Gorton
 Removed the getInvertIndex function.

 01-03-2010 Bec Gorton
 Added the bm->K_num_max_cohort value. This is used to store the max possible number of cohorts
 in the model and thus used to allocate arrays.

 Added new larval dispersion code for Isaac.
 new functionality is documented on the wiki under Atlantis Documentation.

 25-03-2010 Bec Gorton
 Added the isBacteria flag to the FunctGroupArray.

 07-04-2010 Bec Gorton
 Trunk merge #1553.

 04-05-2010 Bec Gorton
 Added new arrays to store the linear mortality scaling information.

 10-05-2010 Bec Gorton
 Added code to read in a setup a new linear mortality time series.

 23-11-2010 Bec Gorton
 Removed the pFCPINi type arrays. These are now read straight into the pSPFCeat arrays.
 The catch grazing code has now been generalised and values will be read in for each functional
 group where the isCatchGrazer value is set to 1 in the functional group input file. This is now used to set the
 catcheater_id species param instead of reading it in from the biology file.

 14-07-2010 Beth Fulton
 Put in a trap in SetupInvade() so don't initialise these arrays unless needed

 14-05-2012 Beth Fulton
 Added stuff for Savina seagrass model - including totagepop so can get age structured overall output

 05-07-2012 Bec Gorton
 Removed the linkage arrays into the atbrokerlink library. These are no longer allocated and freed in this file.

 17-04-2013 Bec Gorton
 ATL-346 - Added support of tracking P:N:C ratios in groups.
 ************************************************************************************

 Table 1. Summary of Model State Variables.

 Description	Symbol					Units
 ------------------              ------------
 Large phytoplankton				PL	mg N m-3
 Small phytoplankton	(pico)		PS	mg N m-3
 Dinoflagellates					DF	mg N m-3
 Seagrass						SG	mg N m-2
 Macroalgae						MA	mg N m-2
 Microphytobenthos				MB	mg N m-2
 Small planktivorous fish        FPS special
 Large planktivorous fish        FPL special
 Other planktivorous fish        FPO special
 Deep piscivorous fish           FVD special
 Vulnerable piscivorous fish     FVV special
 Shallow piscivorous fish        FVS special
 Other piscivorous fish          FVB special
 Large piscivorous fish (tuna)   FVT special
 Other tuna                      FVO special
 Migratory mesopelagics fish     FMM special
 Non-migratory mesopelagics fish FMN special
 Benthopelagics                  FBP special
 Herbivorous demersal fish       FDE special
 Shallow demersal fish           FDS special
 Other shallow demersal fish     FDB special
 Deep demersal fish              FDD special
 Other deep demersal fish        FDC special
 Longlived deep demersal fish    FDO special
 Flat deep demersal fish         FDF special
 Protected demersal fish         FDP special
 Miscellaneous demersal fish     FDM special
 Demersal sharks                 SHD special
 Dogfish                         SHC special
 Other demersal sharks           SHB special
 Pelagic sharks                  SHP special
 Reef sharks                     SHR special
 Skates and rays                 SSK special
 Seabirds                        SB  special
 Penguins                        SP  special
 Pinnipeds                       PIN special
 Reptiles						REP special
 Baleen whales                   WHB special
 Small toothed whales            WHS special
 Toothed whales                  WHT special
 Dugongs                         WDG special
 Prawns                          PWN mg N m-3
 Cephalopods                     CEP mg N m-3
 Gelatinous zooplankton			ZG	mg N m-3
 Large carnivorous zooplankton	ZL	mg N m-3
 Mesozooplankton					ZM	mg N m-3
 Small zooplankton				ZS	mg N m-3
 Pelagic associated bacteria		PB	mg N m-2
 Sedimentary bacteria			BB	mg N m-2
 Meiobenthos						BO	mg N m-2
 Deposit feeders					BD	mg N m-2
 Benthic infaunal carnivores		BC	mg N m-2
 Benthic grazers					BG	mg N m-2
 Benthic filter feeders shallow	BFS	mg N m-2
 Benthic filter feeders deep		BFD	mg N m-2
 Other benthic filter feeders	BFF	mg N m-2
 Macrozoobenthos	shallow			BMS	mg N m-2
 Macrozoobenthos	deep			BMD	mg N m-2
 Megazoobenthos      			BML	mg N m-2
 Labile detritus					DL	mg N m-3
 Refractory detritus				DR	mg N m-3
 Carrion							DC	mg N m-3
 Dissolved organic nitrogen		DON	mg N m-3
 Ammonia							NH	mg N m-3
 Nitrate							NO	mg N m-3
 Dissolved silica				Si	mg Si m-3
 Biogenic silica					DSi	mg Si m-3
 Dissolved oxygen				O2	mg O m-3
 Light							IRR	W m-2

 Those marked with a + also have Si pool too.
 Those marked special have three pools, a sructural N (mg N individual-1),
 reserve N (mg N individual-1) and numbers (per box)
 *************/

/*  Open library routines */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sjwlib.h>
#include "atecology.h"
#include "atnamelist.h"
#include <netcdf.h>
#include <atExternalScalar.h>

/**
 * Function prototypes for functions that are 'private' to this file.
 */

static void Allocate_Arrays_Pre_Load(MSEBoxModel *bm, FILE *llogfp);
static void Allocate_Arrays_Post_Load(MSEBoxModel *bm, FILE *llogfp);
static void Set_Default_Species_Values(MSEBoxModel *bm, FILE *llogfp);
static void Set_Tracer_Index(MSEBoxModel *pbm, FILE *llogfp);
static void Set_Epiben_Index(MSEBoxModel *pbm, FILE *llogfp);
static void Set_Land_Index(MSEBoxModel* bm, FILE *llogfp);
static void Set_Active_Flag(MSEBoxModel *bm, FILE *llogfp);
static void Free_Biol_Param_Arrays(MSEBoxModel *bm);
static void Check_Input_Data(MSEBoxModel *bm, FILE *llogfp);
static void Init_Population_Ratios(MSEBoxModel *bm);
static void Initialise_Arrays(MSEBoxModel *bm);
static void Setup_PreyAvail(MSEBoxModel *bm, FILE *llogfp);
static void Setup_Invade(MSEBoxModel *bm);
static void Set_spMinMax_Values(MSEBoxModel *bm);

/* Home range functions */
static void Setup_HomeRanges(MSEBoxModel *bm, FILE *llogfp);
static void Free_HomeRange_Structures(MSEBoxModel *bm);

/* Larval dispersion functions */
static int Ecology_Read_Larval_Matrix(MSEBoxModel *bm);
static void Ecology_Setup_Reproduction(MSEBoxModel *bm);
static void Ecology_Setup_Evolution(MSEBoxModel *bm, FILE *llogfp);
static void Coral_Setup(MSEBoxModel *bm, FILE *llogfp);

/* Eolution related routines */
static void Create_Evolution_Parameters(MSEBoxModel *bm);

/**
 * Initialisation.
 * \brief This routine is to initialise biological global data, and is called by main() in transport module.
 * The routine initBiology() is called once at the beginning of
 * the run. It carries out the following steps.
 *
 * 1. It checks the model time units and start time. However, currently it does
 * no more than this. It should allow us to convert model elapsed time to
 * calendar time, to drive seasonally varying fields.
 *
 * 2. It sets up the indices of the biological variables in the transport model
 * tracer arrays. In principle, the order of tracers can vary arbitrarily in
 * the transport model: the routines setTracerIndex(bm) and setEpibenIndex(bm)
 * check the names of tracers in the transport arrays, and match these to
 * biological variables. These routines need to be extended to produce flag
 * arrays to distinguish different types of tracers and variables for
 * subsequent model integration (see below).
 *
 * 3. It reads the parameter files by calling Read_Biology_Parameters() and readModelFCParameter().
 *
 * 4. It allocates space for local vectors used in model integration.
 */

void Ecology_Init(MSEBoxModel *bm, FILE *llogfp) {
	char biologyfile[120];
	int nstock = bm->K_num_stocks_per_sp;
	int cohort, chrt, pid;
	int sp, b, sp_active, i, spage, k, pred, prey, chrtstage, preyage, check_for_ts, checkspot, hab, stage, qid, check_rugosity_done;
	double sum = 0.0;
	char convertedXMLFileName[STRLEN];
	double totavail = 0.0;
	int ncohort;
	int max_stock;

	/* Get and test number of tracers */
	idum = -1;
	first_year = 1;
	numwcvar = bm->ntracer;

	if (numwcvar <= 0)
		quit("No ecological variables %d ?! \n", numwcvar);

	numepivar = bm->nepi;
	numdiagvar = bm->ndiag;
	numfstatvar = bm->nfstat;
	numicevar = bm->nicetracer;
	numlandvar = bm->nland;
	//bm->external_mortality = TRUE;

	if(bm->track_contaminants){
		Allocate_Contaiminants(bm);
	}
	printf("Initialise biology\n");

	Set_Default_Species_Values(bm, llogfp);

	/** Allocate the preload arrays */
	Allocate_Arrays_Pre_Load(bm, llogfp);

	/* Read biological parameters ***************************************************/
	strcpy(biologyfile, bm->bioprmIfname);


	/* Check to see if we are reading in an XML file or a prm file */
	if(strstr(biologyfile, ".xml") == NULL){
		/* Build the converted filename */
		sprintf(convertedXMLFileName, "%s", biologyfile);
		*(strstr(convertedXMLFileName, ".prm")) = '\0';
		strcat(convertedXMLFileName, ".xml");

		/* Convert the input file to XML */
		Convert_Biol_To_XML(bm, biologyfile, convertedXMLFileName);
	}else{
		sprintf(convertedXMLFileName, "%s", biologyfile);
	}

	printf("Start reading biological parameters from %s.\n", biologyfile);

	if (Read_Biology_Parameters(bm, convertedXMLFileName, llogfp) == FALSE) {
		fprintf(llogfp, "Error in biological parameter file !! \n");
		quit("Error in biological parameter file !! \n");
	}
    
 	/* Check the data read in was valid */
	Check_Input_Data(bm, llogfp);

	if (verbose > 1)
		printf("Determine maximum biological settings\n");

	/* set the population tracking flag*/
	bm->need_pops = 0;
	if (bm->flagtrackpops) // Set in readParams
		bm->need_pops = 1;

	/* Determine maximum vertebrate ageclass size */
	bm->maxspage = 0;
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			spage = (int) (FunctGroupArray[sp].ageClassSize);
			if (spage > bm->maxspage)
				bm->maxspage = spage;

			/* Check recruitment matches assumptions behind reproduction model */
			if (FunctGroupArray[sp].speciesParams[Recruit_Time_id] < 2)
				FunctGroupArray[sp].speciesParams[Recruit_Time_id] = 2;

		}
	/* Also set up age of maturity of each stage - TODO: Make this a read-in value */
		for (b = 0; b < FunctGroupArray[sp].numStages; b++) {
			FunctGroupArray[sp].age_mat[b] = b * FunctGroupArray[sp].speciesParams[age_mat_id];
		}
	}

    /* Set up cohort stages */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		for(cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++){
			chrt = (int)floor(cohort / FunctGroupArray[sp].numGeneTypes);

			if ((FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED)
					|| (FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS)){

				chrtstage = 0;
				for (pid = 0; pid < FunctGroupArray[sp].numStages; pid++) {
					if (chrt >= FunctGroupArray[sp].age_mat[pid]){
						chrtstage = pid;
					}
				}
			} else {
				chrtstage = chrt;
			}
			FunctGroupArray[sp].cohort_stage[cohort] = chrtstage;
            
            if (FunctGroupArray[sp].cohort_stage[cohort] > FunctGroupArray[sp].numStages){
                printf("%s has cohort_stage %d which is > numStages: %d\n", FunctGroupArray[sp].groupCode, FunctGroupArray[sp].cohort_stage[cohort], FunctGroupArray[sp].numStages);
                quit("%s has cohort_stage %d which is > numStages: %d\n", FunctGroupArray[sp].groupCode, FunctGroupArray[sp].cohort_stage[cohort], FunctGroupArray[sp].numStages);
            }
		}
	}
   
	/* Check the migration data and set things up */
    Check_Migration(bm);
    
	/* Find number of biomass reporting regions */
	// K_num_reg = Number of biomass reporting regions
	// K_num_stocks_per_sp = Maximum number of stocks per vertebrate group in the model
	// manage_reg = Whether using management region or stocks as defining regional TACs
	bm->K_num_active_reg = 0;
	for (b = 0; b < bm->nbox; b++) {
		if (regIDi[b] >= bm->K_num_active_reg) {
			bm->K_num_active_reg = (int) (regIDi[b] + 1);
		}
	}

	if (bm->K_num_active_reg > bm->K_num_reg) {
		fprintf(
				stderr,
				"initBiology, The max value in your regID array (%d) is greater than the number of regions you have specified in the K_num_reg (%d) value in your run.prm file\n",
				bm->K_num_active_reg, bm->K_num_reg);
		quit("");
	}

	if ((bm->K_num_reg <= 1) && ((bm->K_num_stocks_per_sp > 1) || bm->manage_reg)) {
		if (bm->manage_reg) {
			for (b = 0; b < bm->nbox; b++) {
				if (regIDi[b] >= bm->K_num_reg) {
					bm->K_num_reg = (int) (regIDi[b]) + 1;
				}
			}
        } else if (bm->K_num_stocks_per_sp > 5) {
            bm->K_num_reg = totalreg_id;
        } else
			bm->K_num_reg = bm->K_num_stocks_per_sp;
	}

    /* Setup memory for arrays ***********************************************************/
	printf("Create biological arrays\n");

	/* Allocate the rest of the biology arrays */
	Allocate_Arrays_Post_Load(bm, llogfp);

	/* Set indices of all tracers and variables */
	Initialise_Arrays(bm);

	/*
	 *	Build the tracer array
	 *	This will build the trnamelist tracer array.
	 */
	Build_TrName_NameList(bm);
	Build_EPI_NameList(bm);

	if(bm->terrestrial_on)
		Build_LAND_NameList(bm);

	/* Now set the index of each tracer based on the position in the initial condition netcdf file */
	Set_Tracer_Index(bm, llogfp);
	Set_Epiben_Index(bm, llogfp);

	if(bm->terrestrial_on)
		Set_Land_Index(bm, llogfp);

	/* Build the diagnostic bm->diag array */
	Build_Diagnostic_NameList(bm);

	/* Set up the spMinMax values for the vertebrates */
	Set_spMinMax_Values(bm);

	Set_Active_Flag(bm, llogfp);
    
	printf("Populate biological arrays\n");
	if (verbose > 1)
		printf("Checking settings\n");

    /* Check to see if feeding and movement schemes match assumptions, if don't
	 send out a warning */
	if ((k_migslow != 0.0) && (k_migslow != 1.0)) {
		fprintf(llogfp,
				"k_migslow: This scalar must be set to zero (all migrators leave at once) or one (migrators leave slowly) for migration to work properly\n");
		quit("k_migslow: This scalar must be set to zero (all migrators leave at once) or one (migrators leave slowly) for migration to work properly\n");
	}
	for (b = 0; b < bm->K_num_tot_sp; b++) {
		if (FunctGroupArray[b].isVertebrate == TRUE) {
			if ((FunctGroupArray[b].speciesParams[ddepend_move_id] > 1) && (FunctGroupArray[b].speciesParams[predcase_id] > 0)) {
				fprintf(llogfp,
						"Ecology_Init: Density- and food-based movement assumes Holling II feeding, but a different pred_case has been selected for %s\n",
						FunctGroupArray[b].groupCode);
				warn("Ecology_Init: Density- and food-based movement assumes Holling II feeding, but a different pred_case has been selected for %s\n",
						FunctGroupArray[b].groupCode);
			}

			if (FunctGroupArray[b].speciesParams[ddepend_move_id] == no_move){
				warn("You have selected no movement for a vertebrate group (%s). This is not recommended. Better to select sedentary movement instead as this will still take into account environmental factors", FunctGroupArray[b].groupCode);
				quit("'");
			}
		}
	}

	for (b = 0; b < bm->K_num_tot_sp; b++) {
		if (FunctGroupArray[b].isVertebrate == TRUE) {
			if ((FunctGroupArray[b].speciesParams[ddepend_move_id] > 1) && (FunctGroupArray[b].habitatCoeffs[LAND_BASED] > 0)){
				fprintf(bm->logFile, "Ecology_Init: Land based group %s must use prescribed movement only.\n",
											FunctGroupArray[b].groupCode);
				quit("Ecology_Init: Land based group %s must use prescribed movement only.  %s\n",
						FunctGroupArray[b].groupCode);
			}
		}
	}

	/* Populate arrays ***********************************************************/

    if (bm->flag_dynamicXRS) {
        Create_Update_XRS(bm, llogfp); //Populate the X_RS array
    } else {
        for (b = 0; b < bm->K_num_tot_sp; b++) {
            if(FunctGroupArray[b].groupAgeType == AGE_STRUCTURED_BIOMASS || FunctGroupArray[b].groupAgeType == AGE_STRUCTURED){
                for (k = 0; k < FunctGroupArray[b].numCohortsXnumGenes; k++) {
                    FunctGroupArray[b].X_RS[k] = bm->XRS_static;
                }
            }
        }
    }
    
	/* Set biomass reporting region IDs */
	if (bm->K_num_stocks_per_sp > 1) {
		for (b = 0; b < bm->nbox; b++) {
			bm->regID[b] = (int) (regIDi[b]);
		}
	}

	/* Set up vertical differentials in effect of changing temperature and salinity */
	for (b = 0; b < Tchange_max_num; b++) {
		for (k = 0; k < bm->wcnz; k++) {
			checkspot = b * bm->wcnz + k;
			Vchange[b][k][tempscale_id] = vertTchange_multi[checkspot];
		}
	}
	for (b = Tchange_max_num; b < Vchange_max_num; b++) {
		for (k = 0; k < bm->wcnz; k++) {
			Vchange[b][k][tempscale_id] = 1.0;
		}
	}
	for (b = 0; b < Schange_max_num; b++) {
		for (k = 0; k < bm->wcnz; k++) {
			checkspot = b * bm->wcnz + k;
			Vchange[b][k][saltscale_id] = vertSchange_multi[checkspot];
		}
	}
	for (b = Schange_max_num; b < Vchange_max_num; b++) {
		for (k = 0; k < bm->wcnz; k++) {
			Vchange[b][k][saltscale_id] = 1.0;
		}
	}
	for (b = 0; b < PHchange_max_num; b++) {
		for (k = 0; k < bm->wcnz; k++) {
			checkspot = b * bm->wcnz + k;
			Vchange[b][k][pHscale_id] = vertPHchange_multi[checkspot];
		}
	}
	for (b = PHchange_max_num; b < Vchange_max_num; b++) {
		for (k = 0; k < bm->wcnz; k++) {
			Vchange[b][k][pHscale_id] = 1.0;
		}
	}
    
	/* Set up the diet matrix */
	for (pred = 0; pred < bm->K_num_tot_sp; pred++) {
		if (FunctGroupArray[pred].isVertebrate == FALSE) {
			for (prey = 0; prey < bm->K_num_tot_sp; prey++) {
				/* Don't do anything with the detritus values */
				if (FunctGroupArray[pred].groupAgeType == AGE_STRUCTURED_BIOMASS) {
					for (cohort = 0; cohort < FunctGroupArray[pred].numStages; cohort++) {
						if (FunctGroupArray[prey].isDetritus == FALSE) {
							FunctGroupArray[pred].pSPEat[cohort][prey][SED] = FunctGroupArray[pred].pSPEat[cohort][prey][WC];
						}
						FunctGroupArray[pred].pSPEat[cohort][prey][EPIFAUNA] = FunctGroupArray[pred].pSPEat[cohort][prey][WC];

						if(bm->ice_on){
							if(FunctGroupArray[pred].habitatCoeffs[ICE_BASED] > 0 || FunctGroupArray[prey].habitatCoeffs[ICE_BASED] > 0)
								FunctGroupArray[pred].pSPEat[cohort][prey][ICE_BASED] = FunctGroupArray[pred].pSPEat[cohort][prey][WC];
						}
					}
				} else {
					cohort = 0;

					if (FunctGroupArray[prey].isDetritus == FALSE) {
						FunctGroupArray[pred].pSPEat[cohort][prey][SED] = FunctGroupArray[pred].pSPEat[cohort][prey][WC];
					}
					FunctGroupArray[pred].pSPEat[cohort][prey][EPIFAUNA] = FunctGroupArray[pred].pSPEat[cohort][prey][WC];

					if(bm->ice_on){
						if(FunctGroupArray[pred].habitatCoeffs[ICE_BASED] > 0 || FunctGroupArray[prey].habitatCoeffs[ICE_BASED] > 0)
							FunctGroupArray[pred].pSPEat[cohort][prey][ICE_BASED] = FunctGroupArray[pred].pSPEat[cohort][prey][WC];
					}
				}
			}
		}
	}

    /* Set up diet matrix for vertebrates */
	for (pred = 0; pred < bm->K_num_tot_sp; pred++) {
		if (FunctGroupArray[pred].isVertebrate == TRUE) {
			for (prey = 0; prey < bm->K_num_tot_sp; prey++) {
				for (chrtstage = 0; chrtstage < FunctGroupArray[pred].numStages; chrtstage++) {
					for (preyage = 0; preyage < FunctGroupArray[prey].numStages; preyage++) {

						if (!FunctGroupArray[pred].pSPEat[chrtstage][prey][WC] && bm->pSPVERTeat[pred][prey][chrtstage][preyage] > 0) {

							/* If any of this groups cohorts each this prey then set the general pSPEat array to true */
							FunctGroupArray[pred].pSPEat[chrtstage][prey][WC] = bm->pSPVERTeat[pred][prey][chrtstage][preyage];
							if (FunctGroupArray[prey].isDetritus == FALSE) {
								FunctGroupArray[pred].pSPEat[chrtstage][prey][SED] = bm->pSPVERTeat[pred][prey][chrtstage][preyage];
							}
							FunctGroupArray[pred].pSPEat[chrtstage][prey][EPIFAUNA] = bm->pSPVERTeat[pred][prey][chrtstage][preyage];

							//if(bm->which_check == pred){
							//	fprintf(llogfp,"EcolInit: %s on %s chrtstage: %d, pSPeat: %.20e, pSPVERTeat: %e\n",
							//			FunctGroupArray[pred].groupCode, FunctGroupArray[prey].groupCode, juv_id, FunctGroupArray[pred].pSPEat[juv_id][prey][WC], bm->pSPVERTeat[pred][prey][chrtstage][preyage]);
							//}

							if(bm->ice_on){
								if(FunctGroupArray[pred].habitatCoeffs[ICE_BASED] > 0 || FunctGroupArray[prey].habitatCoeffs[ICE_BASED] > 0)
									FunctGroupArray[pred].pSPEat[chrtstage][prey][ICE_BASED] = bm->pSPVERTeat[pred][prey][chrtstage][preyage];
							}

						}
					}
				}
			}
		}
	}

	if ((bm->debug == debug_biology_process) && (bm->dayt >= bm->checkstart) && (bm->dayt < bm->checkstop)) {
		Print_Eat_Diagnostics(bm, llogfp, 0, WC, 3);
		Print_Eat_Diagnostics(bm, llogfp, 0, SED, 3);
		Print_Eat_Diagnostics(bm, llogfp, 0, EPIFAUNA, 3);
	}
    
	/* Work out if the group eats fish */
	for (pred = 0; pred < bm->K_num_tot_sp; pred++) {
		for (prey = 0; prey < bm->K_num_tot_sp; prey++) {
			if (FunctGroupArray[prey].isVertebrate == TRUE) {
				if (FunctGroupArray[pred].pSPEat[juv_id][prey][WC] > 0)
					FunctGroupArray[pred].speciesParams[fisheater_id] = 1;
			}
		}
		/* Flag if this group eats one of the groups that are caught by a fishery */
		for (prey = 0; prey < bm->K_num_fisheries; prey++) {
			if (bm->pFLEET[pred][prey] > 0)
				FunctGroupArray[pred].speciesParams[catcheater_id] = 1;
		}
	}

    /* Do distribution reallocation - for groups with only one cohort move any distributions
	 under "adult" into both slots just to be safe - otherwise can miss invertebrate
	 distributions as read-in by default as adult but only execut juvenile as have only 1
	 cohort.
	 */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isMobile == TRUE) {
			if (FunctGroupArray[sp].numCohorts < FunctGroupArray[sp].numStages) {
				for (b = 0; b < bm->nbox; b++) {
					for (k = 0; k < FunctGroupArray[sp].numMoveEntries; k++) {
						/* As read-in code stores values for adults and not juveniles slot,
						 but migration and movement code executes upto ncohorts, which means
						 only juveniles not adults executed.
						 */
						FunctGroupArray[sp].distrib[b][k][juv_id] = FunctGroupArray[sp].distrib[b][k][adult_id];
					}
				}
			}
		}
	}
    
    /* Print out some diagnostic information */
	if (bm->debug && ((bm->debug == debug_age) || (bm->debug == debug_migrate))) {
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if ((sp == bm->move_check) && (FunctGroupArray[sp].sp_geo_move == TRUE)) {
				for (b = 0; b < bm->nbox; b++) {
					for (qid = 0; qid < MIGRATION[sp].num_in_queue; qid++){
						for (stage = 0; stage < FunctGroupArray[sp].numStages; stage++) {
							fprintf(llogfp, "MigBox%s-%d %e\n", FunctGroupArray[sp].groupCode, b, MIGRATION[sp].Box[b][stage][qid]);
						}
					}
					for (k = 0; k < FunctGroupArray[sp].numMoveEntries; k++) {
						for (i = 0; i < FunctGroupArray[sp].numStages; i++) {
							fprintf(llogfp, "distrib%s-%d-%d-%d %e\n", FunctGroupArray[sp].groupCode, b, k, i, FunctGroupArray[sp].distrib[b][k][i]);
						}
					}
				}
			}
		}
	}
    
    max_stock = -1;
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
            
            /* Find number of stocks per species */

			/** Horizontal stocks **/
			sum = -MAXDOUBLE;
			for (b = 0; b < bm->nbox; b++) {
				if (bm->stock_struct[b][sp] > sum) {
					sum = bm->stock_struct[b][sp];
				}
			}
            
            /* Set number of stocks to a minimum of 1 */
			if (sum < 1)
				sum = 1;
			FunctGroupArray[sp].speciesParams[hstockstruct_id] = sum;

            /** Vertical stocks **/
			sum = -MAXDOUBLE;
			for (b = 0; b < bm->wcnz; b++) {
				if (bm->v_stock_struct[b][sp] > sum) {
					sum = bm->v_stock_struct[b][sp];
				}
			}
			FunctGroupArray[sp].speciesParams[vstockstruct_id] = sum;
			/* Set number of stocks to a minimum of 1 */
			if (sum < 1)
				sum = 1;
            
            /* Check total number of stocks */
			if(FunctGroupArray[sp].numStocks > max_stock )
				max_stock = FunctGroupArray[sp].numStocks;
            if ((int)(FunctGroupArray[sp].speciesParams[vstockstruct_id]) > FunctGroupArray[sp].numStocks)
                quit("vertical stock array for %s has a value (%d) > number of stocks in Groups.csv file (%d), fix one or the other\n", FunctGroupArray[sp].groupCode, (int)(FunctGroupArray[sp].speciesParams[vstockstruct_id]), FunctGroupArray[sp].numStocks);
            if ((int)(FunctGroupArray[sp].speciesParams[hstockstruct_id]) > FunctGroupArray[sp].numStocks)
                quit("horizontal stock array for %s has a value (%d) > number of stocks in Groups.csv file (%d), fix one or the other\n", FunctGroupArray[sp].groupCode, (int)(FunctGroupArray[sp].speciesParams[hstockstruct_id]), FunctGroupArray[sp].numStocks);
            
			/* Set stock striucture type */
			if (FunctGroupArray[sp].speciesParams[vstockstruct_id] > 1) {
				if (FunctGroupArray[sp].speciesParams[hstockstruct_id] > 1)
					FunctGroupArray[sp].speciesParams[stockstruct_type_id] = mixed_stock;
				else
					FunctGroupArray[sp].speciesParams[stockstruct_type_id] = vert_only;
			} else
				FunctGroupArray[sp].speciesParams[stockstruct_type_id] = horiz_only;

			/* Initialise recruitment tracking flag used in Vertebrate_Reproduction () */
			FunctGroupArray[sp].speciesParams[firstrecday_id] = 1.0;

		} else {
			/* Set stock number to one for all invertebrates */
			FunctGroupArray[sp].speciesParams[hstockstruct_id] = 1.0;
			FunctGroupArray[sp].speciesParams[vstockstruct_id] = 1.0;
		}
	}
    
    /* Check the K_num_max_stock value */
	if(max_stock < bm->K_num_stocks_per_sp)
		warn("K_num_stocks_per_sp value in your run.prm file is too large. Should be %d\n", max_stock);

	if(max_stock > bm->K_num_stocks_per_sp)
		quit("K_num_stocks_per_sp value in your run.prm file is too small. Should be %d\n", max_stock);


	// Leave in - loggin data.
	//	sp = FVB_id;
	//	b = (int) (FunctGroupArray[sp].speciesParams[num_migrate_id]);
	//
	//	for (i = 0; i < b; i++) {
	//
	//		if (bm->debug && ((bm->debug == debug_migrate) && (sp == bm->which_check))) {
	//			fprintf(llogfp, "%s-juv T%d, %s-ad T: %d\n", FunctGroupArray[sp].groupCode, (int) (MigrateIO[sp][juv_id][i][Time_id]),
	//					FunctGroupArray[sp].groupCode, (int) (MigrateIO[sp][adult_id][i][Time_id]));
	//		}
	//	}


	/** Allocate initial distribution of relative cohort strengths for each vertebrate groups **/
	/* First allocate any pre-existing distributions that have been read-in */
	if (readin_popratio) {

		//stockHash_pt = initBiolStockArrayHashTable(bm);
		// Allocate and init array.
		readinpopratio = Util_Alloc_Init_4D_Double(bm->maxspage, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, nstock, NAN);
	}

	/*	Read in the data from the input file
	 The ratios will only be read if readin_popratio is true.
	 */
	/* Read in the stock parameters */
	Read_Biology_Stock_Parameters(bm, convertedXMLFileName);

	/* Do the actual initial allocations. If no popratios readin then simply assign numbers
	 uniformly, otherwise assign	pre-loaded distributions readin above */
	Init_Population_Ratios(bm);

	/* Initiate EMBRYO */
	Ecology_Setup_Reproduction(bm);
    
    /* Allocate values from general vertical distributions to the recruit distibutions
	 for the vertebrates and initiate the number of larvae in the water for those groups
	 who spawn in one calendar year and settle in the next */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {

		// Check that this is an invertebrate.
 		if (FunctGroupArray[sp].isVertebrate == TRUE){
			sp_active = (int) (FunctGroupArray[sp].speciesParams[flagactive_id]);
			if (sp_active == 2)
				sp_active = 1;

			for (b = 0; b < bm->wcnz; b++) {
				recruit_vdistrib[b][sp] = FunctGroupArray[sp].distrib_VERTICAL[sp_active][b][0];
			}

			/* Handling of number of initial recruits in water column done
			 in AnnualBiology() */
            for (b = 0; b < FunctGroupArray[sp].numStocks; b++) {
                EMBRYO[sp].readytospawn[b] = 1;
            }
		}
	
		/* Double check that have as many (or less) spawns as cohorts per year
		TO DO: Eventually need to generalise
		*/
		if(FunctGroupArray[sp].numSpawns > FunctGroupArray[sp].numCohorts){
			quit("At present need to have numCohorts >= numSpawns - if need something else recode\n");
		}
	}

	/* Free memory for those parameter arrays no longer needed (as allocated
	 to species/time/cohort specific entries of larger arrays */
	printf("Free unneeded memory\n");
	Free_Biol_Param_Arrays(bm);

	for (b = 0; b < bm->nbox; b++) {
		/* Determine percent area of reef, soft, flat and canyon type seafloor */
		bm->coveramt[bm->REEFcover_id][b] = bm->boxes[b].reef;
		bm->coveramt[bm->FLATcover_id][b] = bm->boxes[b].flat;
		bm->coveramt[bm->SOFTcover_id][b] = bm->boxes[b].soft;
		bm->coveramt[bm->CANYONcover_id][b] = bm->boxes[b].canyon;

		/* Also initialise light per box - set to 1.0 in case don't want changing daylengths
		 (so in that case then it has no impact on light limitation calculations)
		 */
		bm->boxes[b].prop_light_time = 1.0;
	}
    
	/*
	 * Error trapping on daylight hours flag
	 */
	if (bm->lim_sun_hours) {
		//Check_Projection(); - if no projection quit
		if(bm->projection == NULL)		{
			quit("ERROR: If you have the lim_sun_hours flag set to true (1) your bgm box model file must have a projection.\n The projection format should be like: \nprojection proj=alb, lon_0=134. ,lat_1=-36. ,lat_2=-18. x_0=3000000., y_0=6000000\n");
		}
	}

    /* See if multiple recruitment time series are called */
    Load_Imposed_Recruits(bm, llogfp);
    
    /* Identify recruitment environmental forcing time series ids for each vertebrate group */
	if (bm->flagtsforcerecruit) {
        
        if(bm->env_force == NULL)
            quit("The Recruitment_enviro_forcing file is missing - check force.prm to see the path and file name are correct or set flagtsforcerecruit to 0 to turn off this feature\n");
        
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			FunctGroupArray[sp].speciesParams[envforce_id] = -1;
			if (FunctGroupArray[sp].isVertebrate == TRUE) {
				for (b = 0; b < bm->env_force->nv; b++) {
					if (strcmp(FunctGroupArray[sp].groupCode, bm->env_force->varname[b]) == 0)
						FunctGroupArray[sp].speciesParams[envforce_id] = b;
				}
			}
		}
	}

	/* Identify recruitment time series ids for each vertebrate group */
	check_for_ts = 0;
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			if (((int) (FunctGroupArray[sp].speciesParams[flagrecruit_id]) == ts_recruit) || ((int) (FunctGroupArray[sp].speciesParams[flagstocking_id] > 0))) {
				check_for_ts++;
				break;
			}
		}
	}
	if (check_for_ts) {
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if (FunctGroupArray[sp].isVertebrate == TRUE) {
				for (b = 0; b < bm->tsRecruit->nv; b++) {
					if (strcmp(FunctGroupArray[sp].groupCode, bm->tsRecruit->varname[b]) == 0)
						FunctGroupArray[sp].speciesParams[tsrecruit_id] = b;
				}
			}
		}
	}

    /* Identify recruitment sizing forcing time series ids for each vertebrate group */
    if (bm->flag_modify_KWSR) {
        
        if(bm->KWSR_force == NULL)
            quit("The KWSR_forcing file is missing - check force.prm to see the path and file name are correct or set flag_modify_KWSR to 0 to turn off this feature\n");
        
        for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
            FunctGroupArray[sp].speciesParams[KWSRforce_id] = -1;
            if (FunctGroupArray[sp].isVertebrate == TRUE) {
                for (b = 0; b < bm->KWSR_force->nv; b++) {
                    if (strcmp(FunctGroupArray[sp].groupCode, bm->KWSR_force->varname[b]) == 0)
                        FunctGroupArray[sp].speciesParams[KWSRforce_id] = b;
                }
            }
        }
    }
    
    /* Set up the indexing for the linear mortality scalar timeseries */
	Setup_Linear_Mortality_Indicies(bm);

	/* Do the same for the changes in size */
	Setup_Change_Indicies(bm, bm->tsSizeChange, size_scale_id);
	Setup_Change_Indicies(bm, bm->tsGrowthRateChange, mum_scale_id);
	Setup_Change_Indicies(bm, bm->tsFSPBChange, FSPB_scale_id);
	for(sp = 0; sp < bm->K_num_tot_sp; sp++){
		// No longer just vertebrates so do for all
        for(cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++){
            FunctGroupArray[sp].scaled_mum[cohort] = FunctGroupArray[sp].mum[cohort];
            FunctGroupArray[sp].scaled_C[cohort] = FunctGroupArray[sp].SP_C[cohort];

        }
        if( FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED ||FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS){
        	for(cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++){
        		FunctGroupArray[sp].scaled_FSPB[cohort] = FunctGroupArray[sp].FSPB[cohort];
        	}
        }
        
        FunctGroupArray[sp].speciesParams[recruit_outside_id] = 0;
        FunctGroupArray[sp].speciesParams[recruit_qid_id] = 0;
        FunctGroupArray[sp].speciesParams[direct_recruit_entry_id] = 0;
	}
    
	bm->predayt = -2.0;
	bm->DofW = 6; /* So that newweek flag tripped for first step of run */

	/* Check the initial biomass */
	Check_Layer_Initial_Biomass(bm);

    /* Open the output files */
	Open_Ecology_Output_Files(bm);

    /*** Set up Invading species arrays and index ***/
	Setup_Invade(bm);
    
    /* Set up the prey availability array for use in eat */
	Setup_PreyAvail(bm, llogfp);
    
    /*** Set up any home ranges ***/
	Setup_HomeRanges(bm, llogfp);
    
    /* Read in the larval dispersion matrix */
	Ecology_Read_Larval_Matrix(bm);
    
	/** Set up eating check for use in testing of foodwebs **/
	for(sp = 0; sp < bm->K_num_tot_sp; sp++){
		if(FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS || FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED){
			ncohort = FunctGroupArray[sp].numStages;
		} else {
			ncohort = 1;
		}
		for(cohort = 0; cohort < ncohort; cohort++){
			totavail = 0.0;
			for(b = 0; b < bm->K_num_tot_sp; b++){
				for(hab = WC; hab <= SED; hab++){
					totavail += FunctGroupArray[sp].pSPEat[cohort][b][hab];
				}
			}
			if(totavail > 0)
				FunctGroupArray[sp].cohortSpeciesParams[cohort][flageat_id] = 1;
			else
			
                FunctGroupArray[sp].cohortSpeciesParams[cohort][flageat_id] = 0;
		}
        
        if ((FunctGroupArray[sp].isCover == TRUE) && ((FunctGroupArray[sp].groupType == CORAL) || (FunctGroupArray[sp].groupType == SPONGE))) {
            FunctGroupArray[sp].speciesParams[max_colony_diam_id] = 0.0;
            
            for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
                if ( FunctGroupArray[sp].cohortSpeciesParams[cohort][colony_diam_id] > FunctGroupArray[sp].speciesParams[max_colony_diam_id] )
                    FunctGroupArray[sp].speciesParams[max_colony_diam_id] = FunctGroupArray[sp].cohortSpeciesParams[cohort][colony_diam_id];
            }
        }
	}

    /* Initialise refuge_status */
    check_rugosity_done = 0;
	for (sp = 0; sp < bm->K_num_tot_sp; sp++){
		for (b = 0; b < bm->nbox; b++) {
			if(bm->boxes[b].type != BOUNDARY && bm->boxes[b].type != LAND){
				//Box_Rugosity(bm, &bm->boxes[b], 0, llogfp);  As now inside Vertebrate_Assess_Enviro()
				Vertebrate_Assess_Enviro(bm, sp, b, bm->coveramt, bm->boxes[b].botz, check_rugosity_done, llogfp);
			}
            if(bm->track_rugosity_arag)
                bm->boxes[b].base_rugosity = bm->boxes[b].tr[0][Rugosity_i];
		}
        check_rugosity_done = 1;
        
    /* Initialise evolution stats */
        Find_Evolution_Stats(bm, sp, llogfp, 1);
	}

	/* Read in external biology forcing netcdf data */
	Init_External_Scalars(bm);
    
    for(sp = 0; sp < bm->K_num_tot_sp; sp++){
    /* Check RecStock */
        totavail = 0.0;
        if((FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED) || (FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS)){
           for (b = 0; b < FunctGroupArray[sp].numStocks; b++) {
               totavail += recSTOCK[sp][b];
            }
            if (!totavail)
                quit("All the entries in recStock for %s are 0, you must have at least 1 non-zero entry or you will get no recruitment - please make sure you have this parameter in your biology parameter file and that there is at least 1 non-zero entry in the vector\n", FunctGroupArray[sp].groupCode);
        }
    }
   
	if(verbose)
		printf("Ecology initialisation done\n");

    return;
}

/**
 *	\brief This sets up names of ecological performance indices
 *
 */
void Ecology_Set_Index_Name_ID(MSEBoxModel *bm) {
	sprintf(bm->ecolindxNAME[PDratio_id], "%s", "PelDemRatio");
	sprintf(bm->ecolindxNAME[FPFVratio_id], "%s", "PiscivPlankRatio");
	sprintf(bm->ecolindxNAME[InfEpi_id], "%s", "InfEpiRatio");
	sprintf(bm->ecolindxNAME[DivCount_id], "%s", "DivCount");
	sprintf(bm->ecolindxNAME[BSSslope_id], "%s", "BSSslope");
	sprintf(bm->ecolindxNAME[coverindx_id], "%s", "HabitCover");

	return;
}

/**
 *\brief Index determination routines
 * The routine setTracerIndex(MSEBoxModel *bm) is called by initBiology.
 *
 * It searches through a namelist of biological tracers, and finds their index
 * in the MSEBoxModel tracer array.
 *
 * This routine set indices of cell tracers/variables
 * according to the order of their names in input
 * file inmodextra.nc. The structure trnamelist is defined
 * in biology.h
 */
void Set_Tracer_Index(MSEBoxModel* bm, FILE *llogfp) {
	int ij, id;
	int numLayers = 2 * numwcvar + numepivar;

	if (verbose > 0)
		printf("Set tracer ids\n");

	for (id = 0; id < numLayers; id++) {
		Fluxflag[id] = 1;
		Tolflag[id] = 0;
		Bioflag[id] = 0;
		Activeflag[id] = 0;
	}
	for (ij = 0; ij < nTrSize; ij++) {
		id = trIndex(bm->tinfo, bm->ntracer, trnamelist[ij].name);

		if (id < 0){
			quit("Set_Tracer_Index: Can't find tracer %d, variable '%s'\n", ij, trnamelist[ij].name);
		}
		bm->tinfo[id].isUsed = TRUE;
		*(trnamelist[ij].index) = id;

		/* set flag values in wc and sm tracers */
		sprintf(Varname[id], "%s %s", trnamelist[ij].name, "in wc");

		if (verbose > 1) {
			fprintf(llogfp, "Found %s, %d\n", Varname[id], id);
			printf("Found %s, %d\n", Varname[id], id);
		}

		Fluxflag[id] = trnamelist[ij].Flux;
		Tolflag[id] = trnamelist[ij].Tol;
		Bioflag[id] = trnamelist[ij].Bio;

		sprintf(Varname[id + numwcvar], "%s %s", trnamelist[ij].name, "in sm");

		Fluxflag[id + numwcvar] = trnamelist[ij].Flux;
		Tolflag[id + numwcvar] = trnamelist[ij].Tol;
		Bioflag[id + numwcvar] = trnamelist[ij].Bio;
	}
	fflush(stdout);
	return;
}

/**
 *	This routine set indices of epibenthic variables
 *	according to the order of their names in input
 *	file in.nc. The structure epinamelist is defined in biology.h
 *
 */
void Set_Epiben_Index(MSEBoxModel* bm, FILE *llogfp) {
	int ij, id;

	if (verbose > 0)
		fprintf(llogfp, "Set epibenthic ids\n");

	for (ij = 0; ij < nEpiSize; ij++) {

		id = epiIndex(bm->einfo, bm->nepi, epinamelist[ij].name);
		if (id < 0)
			quit("Set_Epiben_Index: Can't find variable '%s'\n", epinamelist[ij].name);
		*(epinamelist[ij].index) = id;

		sprintf(Varname[id + 2 * numwcvar], "%s %s", epinamelist[ij].name, "in epi");

		//	if (verbose > 1)
		//	fprintf(llogfp, "Found %s, %d\n", Varname[id + 2 * numwcvar], id);

		Fluxflag[id + 2 * numwcvar] = epinamelist[ij].Flux;
		Tolflag[id + 2 * numwcvar] = epinamelist[ij].Tol;
		Bioflag[id + 2 * numwcvar] = epinamelist[ij].Bio;

	}

	return;
}

/**
 *	This routine set indices of land variables
 *	according to the order of their names in input
 *	file in.nc. The structure land is defined in biology.h
 *
 */
void Set_Land_Index(MSEBoxModel* bm, FILE *llogfp) {
	int ij, id;

	if (verbose > 0)
		fprintf(llogfp, "Set land ids\n");

	for (ij = 0; ij < nLandSize; ij++) {

		id = landIndex(bm->landinfo, bm->nland, landnamelist[ij].name);
		if (id < 0)
			quit("Set_Land_Index: Can't find variable '%s'\n", landnamelist[ij].name);
		*(landnamelist[ij].index) = id;

		sprintf(Varname[id + 2 * numwcvar + numepivar], "%s %s", landnamelist[ij].name, "in land");

		if (verbose > 1)
			fprintf(bm->logFile, "Found %s, %d\n", landnamelist[ij].name, id);

		Fluxflag[id + 2 * numwcvar + numepivar] = landnamelist[ij].Flux;
		Tolflag[id + 2 * numwcvar + numepivar] = landnamelist[ij].Tol;
		Bioflag[id + 2 * numwcvar + numepivar] = landnamelist[ij].Bio;

	}

	return;
}

/**
 *	Set ActiveFlag status
 *
 */
void Set_Active_Flag(MSEBoxModel *bm, FILE *llogfp) {

	int ij, checkdone, sp, chrt, guild, foundchrt = -1, id;
	int cohort, tracerIndex;

	/* First water column and sediment variables */
	for (ij = 0; ij < nTrSize; ij++) {
		id = trIndex(bm->tinfo, bm->ntracer, trnamelist[ij].name);

		guild = -1;

		if (Bioflag[id]) {
			/* Find out which group is being checked */
			checkdone = -1;
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].habitatType != EPIFAUNA) {
					if (checkdone < 0) {
						for (chrt = 0; chrt < FunctGroupArray[sp].numCohortsXnumGenes; chrt++) {
							if (checkdone < 0) {
								if (FunctGroupArray[sp].isVertebrate == TRUE) {
									if (id == FunctGroupArray[sp].structNTracers[chrt] || id == FunctGroupArray[sp].resNTracers[chrt] || id
											== FunctGroupArray[sp].NumsTracers[chrt]) {
										guild = sp;
										foundchrt = chrt;
										checkdone++;
										break;
									}
								} else {

									if (id == FunctGroupArray[sp].totNTracers[chrt]) {
										guild = sp;
										foundchrt = chrt;
										checkdone++;
										break;
									}
									/* Check a secondary tracer */
									if (id == FunctGroupArray[sp].secondNutrientTracerIndex) {
										guild = sp;
										checkdone++;
										break;
									}

									if(bm->track_atomic_ratio == TRUE && FunctGroupArray[sp].speciesParams[flag_id] == TRUE){
										for(tracerIndex = 0; tracerIndex < num_atomic_id; tracerIndex++){
											if(id == FunctGroupArray[sp].addRatioTracers[chrt][tracerIndex]) {
												guild = sp;
												foundchrt = chrt;
												checkdone++;
												break;
											}
										}
										if(guild >= 0){
											break;
										}
									}
								}
							}
						}
					}
				}
			}

			/* If the tracer is not found make it is inactive */
			if(checkdone < 0){
				Activeflag[id] = 0;
				Activeflag[id + numwcvar] = 0;
				bm->tinfo[id].flagid = 0;
			} else {
				if (strcmp(trnamelist[ij].name, "MicroNut") != 0) {
					/* Check if group NOT active */
					if (FunctGroupArray[guild].speciesParams[flag_id] == FALSE || foundchrt >= (FunctGroupArray[guild].numCohorts * FunctGroupArray[guild].numGeneTypes)) {
						Activeflag[id] = 0;
						Activeflag[id + numwcvar] = 0;
						bm->tinfo[id].flagid = 0;
					} else {
						Activeflag[id] = 1;
						Activeflag[id + numwcvar] = 1;
						bm->tinfo[id].flagid = 1;
					}

				} else {
					/* Only set micronutrients active if micronutrient limitation being used */
					if (!bm->flagmicro) {
						Activeflag[id] = 0;
						Activeflag[id + numwcvar] = 0;
						bm->tinfo[id].flagid = 0;
					} else {
						Activeflag[id] = 1;
						Activeflag[id + numwcvar] = 1;
						bm->tinfo[id].flagid = 1;
					}
				}
			}

			if(verbose > 1)
				fprintf(llogfp, "Doing %s -> %s(%d) has Activeflag %d (id %d)\n", trnamelist[ij].name, FunctGroupArray[guild].groupCode, guild, Activeflag[id], id);
		}
	}

	/* Then epibenthic variables */
	for (ij = 0; ij < nEpiSize; ij++) {
		id = epiIndex(bm->einfo, bm->nepi, epinamelist[ij].name);

		if (Bioflag[id + 2 * numwcvar]) {
			/* Find out which group is being checked */
			guild = -1;

			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].habitatType == EPIFAUNA){// && FunctGroupArray[sp].speciesParams[flag_id] == TRUE) {

					for (cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++) {
						if (id == FunctGroupArray[sp].totNTracers[cohort]) {
							guild = sp;
							break;
						}
					}
					if(guild >=0)
						break;

					if(bm->track_atomic_ratio == TRUE && FunctGroupArray[sp].speciesParams[flag_id] == TRUE){
						for(tracerIndex = 0; tracerIndex < num_atomic_id; tracerIndex++){
							if(id == FunctGroupArray[sp].addRatioTracers[0][tracerIndex]) {
								guild = sp;
								break;
							}
						}
						if(guild >=0)
							break;
					}
				}
			}


			if (guild == -1) {
				quit("Set_Active_Flag: %s - guild not found \n", epinamelist[ij].name);
			}

			/* Check if NOT active */
			if (!((int) (FunctGroupArray[guild].speciesParams[flag_id]))) {
				Activeflag[id + (2 * numwcvar)] = 0;
				bm->einfo[id].flagid = 0;
			} else {
				Activeflag[id + (2 * numwcvar)] = 1;
				bm->einfo[id].flagid = 1;
			}
		}
	}
	return;
}

/**
 *	\brief Total system state
 *
 *	TODO: Check if this can be called from within Ecology_init.
 */
void Ecology_Init_Populations(MSEBoxModel *bm, FILE *llogfp) {
    int ij, n, sp, k, flag_sp, sp_stock_type, stock_id, nreg, qid,  leave_stage, leave_day,
    ns, sn, rn, den, give_warn, alert_msg, fished_chrt, stage, pid, migID = 0;
    //int num_mig;
	int ncells = bm->nbox;
	int totnum = bm->K_num_tot_sp + 1; // The +1 is for DIN
	int nstock = bm->K_num_stocks_per_sp;
	double sp_abund, diffs, sumstock, regtot;
	int fgIndex, cohort, localised_recruit;
	int vertebratesActive = FALSE;
	int anycounted = 0;
    //double SN, prey_SN, KLP_SN, KUP_SN, maxavail, sizeScalar, xmid, Kmax_coefft;
    //int prey, preychrt;
    
    printf("DEN: %e\n", MIGRATION[27].DEN[0][0]);
    
    /* Initialise size spectra parameters */
	bm->smallID = -1;
	bm->largeID = -1;
	bm->smallsize = MAXDOUBLE;
	bm->largesize = 0;

	/* Initialise local arrays */
	for (sp = 0; sp < totnum; sp++) {
		bm->totbiom[sp] = 0.0; //total biomass for each group.
		bm->tot_SSB[sp] = 0.0;
		bm->totinitpop[sp] = 0.0; //Array of overall (per species) virgin biomasses.
        
		for (nreg = 0; nreg < bm->K_num_reg; nreg++) {
			bm->initreg_prop[sp][nreg] = 0.0; //Inital split of biomasses between reporting regions for biomass output.
			bm->lastreg_prop[sp][nreg] = 0.0; //Inital split of biomasses between reporting regions for biomass output.
		}

		if (sp < bm->K_num_tot_sp) {
			if (FunctGroupArray[sp].isVertebrate == TRUE)
				for (stock_id = 0; stock_id < nstock; stock_id++)
					tot_yoy[sp][stock_id] = 0.0;
		}

		for (ij = 0; ij < bm->K_num_max_cohort * bm->K_num_max_genetypes; ij++)
			bm->totagepop[sp][ij] = 0.0;

	}
    
    /* Initialise VERTinfo array */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			for (ij = 0; ij < FunctGroupArray[sp].numStages; ij++) {
				bm->calcNstart[sp][ij] = 0; //Array for storing pseudo recruit estimates
				bm->calcNstartPerPred[sp][ij] = 0; //Array for storing total number estimates
			}

			totden[sp][0] = 0;

			/* Initialise stock sums */
			for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				for (ij = 0; ij < bm->K_num_stocks_per_sp; ij++) {
					bm->stock_struct_prop[sp][n][ij] = 0.0; //Array of proportional stock structure (here so fisheries code can access for use in setting regional TACs.
				}
			}
		}
	}
    
    Util_Calculate_StockID(bm);  // So prepared when go through initial conditions

    /* Determine total biomass for each group */
	for (ij = 0; ij < ncells; ij++) {
		nreg = bm->regID[ij]; //ID for each box indicating which biomass reporting region it is in.

		if (bm->boxes[ij].type != BOUNDARY) {
			Calculate_Box_Biomass(bm, llogfp, ij, nreg, TRUE, FALSE);
		}
	}
    
   /* Determine average initial conditions for fish size */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        
        bm->totinitpop[sp] = 0.0;
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
			fished_chrt = (int) (FunctGroupArray[sp].speciesParams[Age95pcntV_id]);
			if (fished_chrt < ((FunctGroupArray[sp].numCohortsXnumGenes) / 2))
				fished_chrt = ((FunctGroupArray[sp].numCohortsXnumGenes) / 2);

			/* For those that haven't migrated in yet */
			/* Include any migration into the model after the model starts */
			if (flag_sp) {
				vertebratesActive = TRUE;
                //num_mig = FunctGroupArray[sp].speciesParams[num_migrate_id];

				for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
					anycounted = 0;
					stage = FunctGroupArray[sp].cohort_stage[n];

					sn = FunctGroupArray[sp].structNTracers[n];
					rn = FunctGroupArray[sp].resNTracers[n];
					den = FunctGroupArray[sp].NumsTracers[n];

					/* Initialise min and max */
					sizeMinMax[min_SN_id] = MAXDOUBLE; // Minimum SN
					sizeMinMax[max_SN_id] = 0; // Maximum SN
					sizeMinMax[min_RN_id] = MAXDOUBLE; // Minimum RN
					sizeMinMax[max_RN_id] = 0; // Maximum RN

					/* Initialise abundance */
					sp_abund = 0;

					for (ij = 0; ij < ncells; ij++) {
						if (bm->boxes[ij].type != BOUNDARY) {
							for (k = 0; k < bm->boxes[ij].nz; k++) {

                                stock_id = bm->group_stock[sp][ij][k];

                                // This was not in new version, is that an over sight? - This is done in Calculate_Box_Biomass(). Adding here doubles values.
                                //bm->stock_struct_prop[sp][n][stock_id] += bm->boxes[ij].tr[k][den];
								//bm->calcTrackedMort[sp][n][stock_id][start_id] += bm->boxes[ij].tr[k][den];

								sp_abund += bm->boxes[ij].tr[k][den];

								if (bm->boxes[ij].tr[k][den] > bm->min_dens) {
									anycounted++;

									/* Check minimum SN */
									if (bm->boxes[ij].tr[k][sn] < sizeMinMax[min_SN_id])
										sizeMinMax[min_SN_id] = bm->boxes[ij].tr[k][sn];
									/* Check maximum SN */
									if (bm->boxes[ij].tr[k][sn] > sizeMinMax[max_SN_id])
										sizeMinMax[max_SN_id] = bm->boxes[ij].tr[k][sn];
									/* Check minimum RN */
									if (bm->boxes[ij].tr[k][rn] < sizeMinMax[min_RN_id])
										sizeMinMax[min_RN_id] = bm->boxes[ij].tr[k][rn];
									/* Check maximum RN */
									if (bm->boxes[ij].tr[k][rn] > sizeMinMax[max_RN_id])
										sizeMinMax[max_RN_id] = bm->boxes[ij].tr[k][rn];
								}

								/**
								//if (bm->debug && ((bm->debug > debug_stock) && ((sp == bm->which_check) || (sp > bm->K_num_tot_sp)))) {
									fprintf(llogfp, "%s box%d-%d, SN-%d: %e RN-%d %e DEN-%d %e\n", FunctGroupArray[sp].groupCode, ij, k, n,
											bm->boxes[ij].tr[k][sn], n, bm->boxes[ij].tr[k][rn], n, bm->boxes[ij].tr[k][den]);
								//}
								**/
							}
						}
					}

					for (qid = 0; qid < MIGRATION[sp].num_in_queue; qid++) {
                        migID = MIGRATION[sp].migrationID[n][qid];
                        leave_stage = MIGRATION[sp].leave_stage_prm[n][migID];
                        leave_day = MIGRATION[sp].Leave_Now[leave_stage][qid];
                        
                        /* Check to see if actually need to scrub out entires where won't have migrated yet */
                        if ((sp_abund > bm->min_dens) && (leave_day > 0) && MIGRATION[sp].DEN[n][qid]) {
                            warn("Reset MIGRATION array for %s-%d entry %d as %e animals in domain already and leave day is %d so should be none in MIGRATION array as yet (but was %e)\n", FunctGroupArray[sp].groupCode, n, qid, sp_abund, leave_day, MIGRATION[sp].DEN[n][qid]);
                            fprintf(llogfp,"Reset MIGRATION array for %s-%d entry %d as %e animals in domain already and leave day is %d so should be none in MIGRATION array as yet (but was %e)\n", FunctGroupArray[sp].groupCode, n, qid, sp_abund, leave_day, MIGRATION[sp].DEN[n][qid]);
                            MIGRATION[sp].DEN[n][qid] = 0;
                        }
                        
                        bm->totbiom[sp] += MIGRATION[sp].survival[stage][migID] * (MIGRATION[sp].DEN[n][qid] * (MIGRATION[sp].SN[n][qid]
								+ MIGRATION[sp].RN[n][qid]));
						bm->totagepop[sp][n] += MIGRATION[sp].survival[stage][migID] * (MIGRATION[sp].DEN[n][qid] * (MIGRATION[sp].SN[n][qid]
						        + MIGRATION[sp].RN[n][qid]));

						/**
						fprintf(llogfp,"%s-%d qid: %d, stage: %d, totbiom: %f, FSM: %f, DEN: %f, SN: %f, RN: %f\n", 
							FunctGroupArray[sp].groupCode, n, qid, stage, bm->totbiom[sp], MIGRATION[sp].survival[stage][migID], MIGRATION[sp].DEN[n][qid], MIGRATION[sp].SN[n][qid], MIGRATION[sp].RN[n][qid]);
						**/

                        sp_abund += MIGRATION[sp].DEN[n][qid];

						if (n == fished_chrt) {
							bm->calcNstart[sp][hist_id] += MIGRATION[sp].survival[stage][migID] * MIGRATION[sp].DEN[n][qid];
						}

						bm->calcNstartPerPred[sp][hist_id] += MIGRATION[sp].survival[stage][migID] * MIGRATION[sp].DEN[n][qid];

						if (MIGRATION[sp].DEN[n][qid] > bm->min_dens) {
							anycounted++;

							if (bm->debug && ((bm->debug > debug_stock) && (sp == bm->which_check))) {
								fprintf(llogfp, "mig %d, MigSN-%d: %e (min: %e, max: %e) MigRN-%d %e MigDEN-%d %e\n", qid, n, MIGRATION[sp].SN[n][qid],
										sizeMinMax[min_SN_id], sizeMinMax[max_SN_id], n, MIGRATION[sp].RN[n][qid], n, MIGRATION[sp].DEN[n][qid]);
							}
                            
							/* Check minimum SN */
							if (MIGRATION[sp].SN[n][qid] < sizeMinMax[min_SN_id])
								sizeMinMax[min_SN_id] = MIGRATION[sp].SN[n][qid];
							/* Check maximum SN */
							if (MIGRATION[sp].SN[n][qid] > sizeMinMax[max_SN_id])
								sizeMinMax[max_SN_id] = MIGRATION[sp].SN[n][qid];
							/* Check minimum RN */
							if (MIGRATION[sp].RN[n][qid] < sizeMinMax[min_RN_id])
								sizeMinMax[min_RN_id] = MIGRATION[sp].RN[n][qid];
							/* Check maximum RN */
							if (MIGRATION[sp].RN[n][qid] > sizeMinMax[max_RN_id])
								sizeMinMax[max_RN_id] = MIGRATION[sp].RN[n][qid];
						}

						/**
						if (bm->debug && ((bm->debug > debug_stock) && ((sp == bm->which_check) || (sp > bm->K_num_tot_sp)))) {
							fprintf(llogfp, "%s mig %d, MigSN-%d: %e MigRN-%d %e MigDEN-%d %e (%d, %d, %d, %d)\n", FunctGroupArray[sp].groupCode, qid, n,
									MIGRATION[sp].SN[n][qid], n, MIGRATION[sp].RN[n][qid], n, MIGRATION[sp].DEN[n][qid], bm->debug, debug_stock,
									sp, bm->which_check);
						}
						**/
                        
					}

					/* Check here to see if numbers or sizes are very small */
					if (flag_sp && !anycounted) {
						warn("%s cohort %d marked as active in the model but nums in input nc file and migration array is < %e - so if get odd size answers will relax nums constraint and try again\n", FunctGroupArray[sp].groupCode, n, bm->min_dens);
						fprintf(llogfp, "%s cohort %d marked as active in the model but nums in input nc file and migration array is < %e\n", FunctGroupArray[sp].groupCode, n, bm->min_dens);
					}

					if (flag_sp && sizeMinMax[min_SN_id] < buffer_rounding) {
						warn("minimum inital size of %s:%d-SN is VERY small: %e;\n", FunctGroupArray[sp].groupCode, n, sizeMinMax[min_SN_id], n);
						fprintf(llogfp, "inital size of %s:%d-SN is VERY small: %e (cohort (%d)\n", FunctGroupArray[sp].groupCode, n, sizeMinMax[min_SN_id], n);
					}
					if (flag_sp && sizeMinMax[min_RN_id] < buffer_rounding) {
						warn("minimum inital size of %s:%d-RN is VERY small: %e;\n", FunctGroupArray[sp].groupCode, n, sizeMinMax[min_RN_id], n);
						fprintf(llogfp, "inital size of %s:%d-RN is VERY small: %e (cohort (%d)\n", FunctGroupArray[sp].groupCode, n, sizeMinMax[min_RN_id], n);
					}

					/* Use 10000 to arbitrate the check here as numbers involved
					 are huge when dealing with MAXDOUBLE */
					if (flag_sp && sizeMinMax[min_SN_id] > MAXDOUBLE / 3.0) {
						warn("maximum inital size of %s:%d-SN is VERY large: %e (cohort %d) - will retry without looking at numbers present\n", FunctGroupArray[sp].groupCode,  n, sizeMinMax[min_SN_id], n);
						fprintf(llogfp, "inital size of %s:%d-SN is VERY large: %e (cohort (%d) - will retry without looking at numbers present\n", FunctGroupArray[sp].groupCode,  n,  sizeMinMax[min_SN_id], n);
					}
					if (flag_sp && sizeMinMax[min_RN_id] > MAXDOUBLE / 3.0) {
						warn("maximum inital size of %s:%d-RN is VERY large: %e (cohort (%d) - will retry without looking at numbers present\n", FunctGroupArray[sp].groupCode,  n, sizeMinMax[min_RN_id], n);
						fprintf(llogfp, "inital size of %s:%d-RN is VERY large: %e (cohort (%d) - will retry without looking at numbers present\n", FunctGroupArray[sp].groupCode,  n, sizeMinMax[min_RN_id], n);
					}

					/* If no individuals present size again with relaxed density constraints */
					if (((!anycounted) || (sizeMinMax[min_SN_id] > (MAXDOUBLE / 3.0)))) {
						for (ij = 0; ij < bm->nbox; ij++) {
							if (bm->boxes[ij].type != BOUNDARY) {
								for (k = 0; k < bm->boxes[ij].nz; k++) {
									sp_abund += bm->boxes[ij].tr[k][den];

									/* Check minimum SN */
									if (bm->boxes[ij].tr[k][sn] < sizeMinMax[min_SN_id])
										sizeMinMax[min_SN_id] = bm->boxes[ij].tr[k][sn];
									/* Check maximum SN */
									if (bm->boxes[ij].tr[k][sn] > sizeMinMax[max_SN_id])
										sizeMinMax[max_SN_id] = bm->boxes[ij].tr[k][sn];
									/* Check minimum RN */
									if (bm->boxes[ij].tr[k][rn] < sizeMinMax[min_RN_id])
										sizeMinMax[min_RN_id] = bm->boxes[ij].tr[k][rn];
									/* Check maximum RN */
									if (bm->boxes[ij].tr[k][rn] > sizeMinMax[max_RN_id])
										sizeMinMax[max_RN_id] = bm->boxes[ij].tr[k][rn];
								}
							}
						}
					}
					
					/* Trying again for max size */
					if (flag_sp && sizeMinMax[min_SN_id] > MAXDOUBLE / 3.0) {
						warn("maximum inital size of %s:%d-SN is VERY large: %e (cohort %d) - you likely have a real problem here\n", FunctGroupArray[sp].groupCode,  n, sizeMinMax[min_SN_id], n);
						fprintf(llogfp, "inital size of %s:%d-SN is VERY large: %e (cohort (%d) - you likely have a real problem here\n", FunctGroupArray[sp].groupCode,  n,  sizeMinMax[min_SN_id], n);
					}
					if (flag_sp && sizeMinMax[min_RN_id] > MAXDOUBLE / 3.0) {
						warn("maximum inital size of %s:%d-RN is VERY large: %e (cohort (%d) - you likely have a real problem here\n", FunctGroupArray[sp].groupCode,  n, sizeMinMax[min_RN_id], n);
						fprintf(llogfp, "inital size of %s:%d-RN is VERY large: %e (cohort (%d) - you likely have a real problem here\n", FunctGroupArray[sp].groupCode,  n, sizeMinMax[min_RN_id], n);
					}

					/* Store final results - including average size for each cohort of species */
					initVERTinfo[sp][n][DEN_id] = sp_abund;
					initVERTinfo[sp][n][SN_id] = (sizeMinMax[min_SN_id] + sizeMinMax[max_SN_id]) / 2.0;
					initVERTinfo[sp][n][RN_id] = (sizeMinMax[min_RN_id] + sizeMinMax[max_RN_id]) / 2.0;
                    bm->totinitpop[sp] += initVERTinfo[sp][n][DEN_id] * (initVERTinfo[sp][n][SN_id] + initVERTinfo[sp][n][RN_id]);

					/* Store population sizes */
					if (fishtest) {
						VERTabund_check[sp][n] = totden[sp][n];
					}

					/* Get size spectra info - in kg */
					if (flag_sp && (n == ((FunctGroupArray[sp].numCohortsXnumGenes) - 1))) {
						if ((initVERTinfo[sp][n][SN_id] + initVERTinfo[sp][n][RN_id]) < bm->smallsize) {
							bm->smallID = sp;
							bm->smallsize = (initVERTinfo[sp][n][SN_id] + initVERTinfo[sp][n][RN_id]);
						}
						if ((initVERTinfo[sp][n][SN_id] + initVERTinfo[sp][n][RN_id]) > bm->largesize) {
							bm->largeID = sp;
							bm->largesize = initVERTinfo[sp][n][SN_id] + initVERTinfo[sp][n][RN_id];
						}
					}

					/* Also normalise stock structure for recruitment reseeding check below */
					for (ij = 0; ij < FunctGroupArray[sp].numStocks; ij++) {
						bm->stock_struct_prop[sp][n][ij] = bm->stock_struct_prop[sp][n][ij] / (totden[sp][n] + small_num);
                        
                        if (FunctGroupArray[sp].numStocks == 1) {
                            bm->stock_struct_prop[sp][n][ij] = 1.0;
                        }
					}
				}
			}
		}
        bm->totfishpop[sp] = bm->totinitpop[sp];
        bm->tot_SSB[sp] = bm->totinitpop[sp]; // Just as a proxy
	}

    /* Check size spectra parameters make sense */
	if(vertebratesActive){
		if (bm->smallID < 0)
			quit("No suitable small vertebrate found for size spectra (smallID: %d)\n", bm->smallID);
		if (bm->largeID < 0)
			quit("No suitable large vertebrate found for size spectra (largeID: %d)\n", bm->largeID);
		if (!bm->smallsize)
			quit("Smallest vertebrate (%s) has zero size\n", FunctGroupArray[bm->smallID].groupCode);
		if (!bm->largesize)
			quit("Largest vertebrate (%s) has zero size\n", FunctGroupArray[bm->largeID].groupCode);
	}

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			bm->calcNstart[sp][expect_id] = bm->calcNstart[sp][hist_id];
			bm->calcNstartPerPred[sp][expect_id] = bm->calcNstartPerPred[sp][hist_id];
			if (verbose)
				fprintf(llogfp, "%s has startN = %e\n", FunctGroupArray[sp].groupCode, bm->calcNstart[sp][hist_id]);

			/* If going to skip biology while debugging fisheries */
			if (bm->flag_skip_biol) {
				FunctGroupArray[sp].speciesParams[calcupdate_date_id] = 0;
				bm->calcFnum[sp][hist_id] = 0.2 * bm->calcNstart[sp][hist_id];
				bm->calcFnum[sp][expect_id] = bm->calcFnum[sp][hist_id];

				bm->calcMnum[sp][hist_id] = 0.2 * bm->calcNstart[sp][hist_id];

			}
		}
	}
    
    /* Output name of smallest and largest vertebrates */
	if(vertebratesActive){
		fprintf(llogfp, "%s is smallest vertebrate (at %e kg) - SN: %e, RN: %e\n", FunctGroupArray[bm->smallID].groupCode, bm->smallsize * bm->X_CN * mg_2_kg,
				initVERTinfo[bm->smallID][FunctGroupArray[bm->smallID].numCohortsXnumGenes - 1][SN_id], initVERTinfo[bm->smallID][FunctGroupArray[bm->smallID].numCohortsXnumGenes - 1][RN_id]);
		printf("%s is smallest vertebrate (at %e kg)\n", FunctGroupArray[bm->smallID].groupCode, bm->smallsize * bm->X_CN * mg_2_kg);
		fprintf(llogfp, "%s is largest vertebrate (at %e kg) - SN: %e, RN: %e\n", FunctGroupArray[bm->largeID].groupCode, bm->largesize * bm->X_CN * mg_2_kg,
				initVERTinfo[bm->largeID][FunctGroupArray[bm->largeID].numCohortsXnumGenes - 1][SN_id], initVERTinfo[bm->largeID][FunctGroupArray[bm->largeID].numCohortsXnumGenes - 1][RN_id]);
		printf("%s is largest vertebrate (at %e kg)\n", FunctGroupArray[bm->largeID].groupCode, bm->largesize * bm->X_CN * mg_2_kg);
	}

    /* Work out totbiom update for non-Vertebrates */
	for (fgIndex = 0; fgIndex < bm->K_num_tot_sp; fgIndex++) {
		if (FunctGroupArray[fgIndex].isVertebrate == FALSE && FunctGroupArray[fgIndex].isMobile == TRUE && FunctGroupArray[fgIndex].sp_geo_move == TRUE) {
			for (cohort = 0; cohort < FunctGroupArray[fgIndex].numCohortsXnumGenes; cohort++) {
				stage = FunctGroupArray[fgIndex].cohort_stage[cohort];
				for (qid = 0; qid < MIGRATION[fgIndex].num_in_queue; qid++) {
					bm->totbiom[fgIndex] += MIGRATION[fgIndex].survival[stage][migID] * MIGRATION[fgIndex].DEN[cohort][qid];
					bm->totagepop[fgIndex][cohort] += MIGRATION[fgIndex].survival[stage][migID] * MIGRATION[fgIndex].DEN[cohort][qid];
				}
			}
		}
	}

	/* Initial total population size */
	tot_dyn_sea_area = 0.0;
    for (ij = 0; ij < ncells; ij++) {
        if ((bm->boxes[ij].type != BOUNDARY) && (bm->boxes[ij].type != LAND)) {
            tot_dyn_sea_area += bm->boxes[ij].area;
        }
    }

    for (sp = 0; sp < bm->K_num_tot_sp + 1; sp++) {
		bm->totinitpop[sp] = bm->totbiom[sp];
		if (sp < bm->K_num_tot_sp)
			bm->estinitpop[sp] = bm->totbiom[sp];
		if (sp == bm->K_num_tot_sp || ((FunctGroupArray[sp].isDetritus == TRUE || (FunctGroupArray[sp].isDetritus == FALSE
				&& (int) (FunctGroupArray[sp].speciesParams[flag_id]))))) {
			fprintf(llogfp, "Time: %e, species %s virgin biomass is %f t\n", bm->dayt, FunctGroupArray[sp].groupCode, bm->totinitpop[sp] * bm->X_CN
					* mg_2_tonne);
		}

		/** Regional contributions **/
		/* As no migrators considered for the regional proportions - as yet - then
		 sum here as regtot may not equal totbiom (which includes migrators)
		 */
		regtot = 0;
		for (nreg = 0; nreg < bm->K_num_reg; nreg++) {
            /* CHANGE In OUTPUT - this if statement changes biomreg.txt output */
            // if (bm->initreg_prop[sp][nreg] < no_quota) // Filter out no participating regions
			regtot += bm->initreg_prop[sp][nreg];
		}
		/* Make reg_prop trully proportions */
		for (nreg = 0; nreg < bm->K_num_reg; nreg++) {
            /* CHANGE In OUTPUT - this if statement changes biomreg.txt output */
            // if (bm->initreg_prop[sp][nreg] < no_quota) // Filter out no participating regions
			bm->initreg_prop[sp][nreg] = bm->initreg_prop[sp][nreg] / (regtot + small_num);
		}
		if (bm->manage_reg) {
			for (nreg = 0; nreg < bm->K_num_reg; nreg++) {
				if (bm->lastreg_prop[sp][nreg] < no_quota) { // So can have regions where no TAC used
					bm->initreg_prop[sp][nreg] = bm->initreg_prop[sp][nreg] / (regtot + small_num);
				}
			}
		}
        
        // For non-mobile invertebrates constrain them to initial distributions - so store the original distribution
        if(bm->flagconstrain_epiwander && (FunctGroupArray[sp].habitatType == EPIFAUNA) && !FunctGroupArray[sp].sp_geo_move) {
            pid = FunctGroupArray[sp].totNTracers[0];
            for (ij = 0; ij < bm->nbox; ij++) {
                if (bm->boxes[ij].epi[pid] > 0.0)
                    FunctGroupArray[sp].distrib[ij][0][0] = 1.0;
                else
                    FunctGroupArray[sp].distrib[ij][0][0] = 0.0;
            }
        }

	}

    /* Check for artificial stock reseeding in horizontal recruitment distributions */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			flag_sp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);

			if(flag_sp){
				for(n = 0; n < FunctGroupArray[sp].numGeneTypes; n++){
					/* Get allocation per stock */
					sp_stock_type = (int) (FunctGroupArray[sp].speciesParams[stockstruct_type_id]);
					switch (sp_stock_type) {
					case horiz_only:
						for (ij = 0; ij < bm->nbox; ij++) {
							if (bm->boxes[ij].type != BOUNDARY) {
								stock_id = bm->stock_struct[ij][sp] - 1;

								if(stock_id < 0)
									quit("Group %s, box %d horizontal stock is -1. Check your biology input file.\n", FunctGroupArray[sp].groupCode, ij);
								init_stock_struct_prop[sp][n][stock_id] += bm->recruit_hdistrib[n][ij][sp];  // As assume all genetypes have teh same distribution initialy
							}
						}
						break;
					case vert_only:
					case mixed_stock:
						warn("Ecology_Init: %s has vertical or mixed stock definition so isn't currently checked for artifical stock reseeding\n",
								FunctGroupArray[sp].groupCode);
						break;
					default:
						quit("No such stock structure case (%d) defined for %s. Recode\n", sp_stock_type, FunctGroupArray[sp].groupCode);
						break;
					}

					/* If horizontal stocks, normalise if sum doesn't match what it needs to */
					if (sp_stock_type == horiz_only) {
						give_warn = 0;
						alert_msg = 0;
						sumstock = 0;
						for (ij = 0; ij < FunctGroupArray[sp].numStocks; ij++) {
							diffs = fabs(init_stock_struct_prop[sp][n][ij] - bm->stock_struct_prop[sp][n][ij]);
							if (diffs > buffer_rounding) {
								give_warn = 1;
								warn("Ecology_Init: %s geneotype: %d stock %d (of %d) would have recruit contrib %.12f, but stock prop is %.12f\n", FunctGroupArray[sp].groupCode,
										n, ij, FunctGroupArray[sp].numStocks, init_stock_struct_prop[sp][n][ij], bm->stock_struct_prop[sp][n][ij]);
								fprintf(bm->logFile, "%s stock %d (of %d) would have recruit contrib %.12f, but stock prop is %.12f\n", FunctGroupArray[sp].groupCode, ij, FunctGroupArray[sp].numStocks, init_stock_struct_prop[sp][n][ij], bm->stock_struct_prop[sp][n][ij]);
							}
							sumstock += bm->stock_struct_prop[sp][n][ij];
						}

						if (sumstock < small_num) {
							give_warn = 0;
							alert_msg = 1;
						}
						for (qid = 0; qid < MIGRATION[sp].num_in_queue; qid++) {
							if (MIGRATION[sp].DEN[n][qid] > 1.0) {
								give_warn = 0;
								alert_msg = 1;
							}
						}

						if (give_warn) {
							warn("Ecology_Init: Renormalising %s recruit_hdistrib as entered values would cause artificial reseeding of stocks\n",
									FunctGroupArray[sp].groupCode);
							for (ij = 0; ij < bm->nbox; ij++) {
								if (bm->boxes[ij].type != BOUNDARY) {
									stock_id = bm->stock_struct[ij][sp] - 1;
									bm->recruit_hdistrib[n][ij][sp] = bm->recruit_hdistrib[n][ij][sp] * bm->stock_struct_prop[sp][n][stock_id]
											/ (init_stock_struct_prop[sp][n][stock_id] + small_num);
								}
							}
						}

						if (alert_msg) {
							warn("Ecology_Init: %s has migrants outside model domain at model start so can't perform artifical reseeding preventative check.\n",
									FunctGroupArray[sp].groupCode);
							warn("Ecology_Init: This is probably not an issue, but if you are having troubles with %s check recruit_hdistrib.\n",
									FunctGroupArray[sp].groupCode);
						}

						/** Recaste recruit_hdistrib so that can assume that internal sum of proportions for boxes
						 covered by the stock sums to 1
						 **/
						for (ns = 0; ns < FunctGroupArray[sp].numStocks; ns++) {
							sumstock = 0.0;
							/* Get current total across internal boxes */
							for (ij = 0; ij < bm->nbox; ij++) {
								if (bm->boxes[ij].type != BOUNDARY) {
									stock_id = bm->stock_struct[ij][sp] - 1;
									if (stock_id == ns) {
										sumstock += bm->recruit_hdistrib[n][ij][sp];
									}
								}
							}
							/* Rescale if necessary - only deal with < 1 case as can't
							 sum > 1 as overall sum = 1 checked on read-in
							 */
							diffs = fabs(sumstock - 1);
							if (diffs > buffer_rounding) {
								for (ij = 0; ij < bm->nbox; ij++) {
									if (bm->boxes[ij].type != BOUNDARY) {
										stock_id = bm->stock_struct[ij][sp] - 1;
										if (stock_id == ns) {
											bm->recruit_hdistrib[n][ij][sp] = (1.0 / (sumstock + small_num)) * bm->recruit_hdistrib[n][ij][sp];
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			/* Calculate the larval dispersion matrix for this species */
			localised_recruit = (int) (FunctGroupArray[sp].speciesParams[flaglocalrecruit_id]);
			/* Calculate the larval dispersion matrix  - the recruit_hdistrib matrix should not be normalised.*/
			if (localised_recruit == larval_dispersal)
				Larval_Dispersal(bm, sp, llogfp);
		}
	}
    
    /* If using bi-logistic feeding window - set up max_scalar
     Ideally this would go in Ecology_Init() but has to be here
     as need initVERTinfo to have been populated first */
    
    //TODO: This is currently deactivated as the maximum scalar calculation is probably not needed
    /**
    
    if ( !bm->UseHardFeedingWindow && bm->UseBiLogisticFeedingWindow ) {
        for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
            Kmax_coefft = FunctGroupArray[sp].speciesParams[Kmax_coefft_id];
            
            for(cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++){
                chrtstage = FunctGroupArray[sp].cohort_stage[cohort];
                FunctGroupArray[sp].max_scalar[cohort] = 0.0;
                if (FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED) {
                    SN = initVERTinfo[sp][cohort][SN_id];
                    RN = initVERTinfo[sp][cohort][RN_id];
                    pred_len = Ecology_Get_Size(bm, sp, (SN+RN), cohort);				// returns length in cm
                } else {
                    SN = FunctGroupArray[sp].sn[cohort];
                    li_a = bm->li_a_invert;
                    li_b = bm->li_b_invert;
                    invert_weight = (SN * k_wetdry * 2) / 1000.0;  // We assumed that RN/SN ratio in invertebrates is 1:1.
                    pred_len = pow((invert_weight / (li_a + small_num)), li_b);
                }
                
                KLP_SP = FunctGroupArray[sp].speciesParams[KLP_id];
                KUP_SP = FunctGroupArray[sp].speciesParams[KUP_id];
                
                //fprintf(bm->logFile, "Initialise bi-logistic Pred Len: species %s cohort %d has SN: %e, has length: %e KLP_SP: %e KUP_SP: %e\n",
                //        FunctGroupArray[sp].groupCode, cohort, SN, pred_len, KLP_SP, KUP_SP);
                
                
                for (prey = 0; prey < bm->K_num_tot_sp; prey++) {
                    prey_active = (int) (FunctGroupArray[prey].speciesParams[flagactive_id]);
                    
                    if (prey_active && FunctGroupArray[prey].isVertebrate == TRUE) { // loop only over active vertebrate prey species for which size-based feeding aplies
                        temp_scalar = 0; // temporary scalar to get the maximum value over all cohorts of each prey
                        
                        for(preychrt = 0; preychrt < FunctGroupArray[prey].numCohortsXnumGenes; preychrt++){
                            
                            if (FunctGroupArray[prey].groupAgeType == AGE_STRUCTURED) {
                                prey_SN = initVERTinfo[prey][preychrt][SN_id];
                                prey_RN = initVERTinfo[prey][preychrt][RN_id];
                                prey_len = Ecology_Get_Size(bm, prey, (prey_SN + prey_RN), preychrt);				// returns length in cm
                            } else {
                                prey_len = 0;  // size based feeding only applies to vertebrate prey
                            }
                            
                            maxavail = KLP_SP + (KUP_SP - KLP_SP) * 0.5;
                            if (prey_len <= maxavail * pred_len) {
                                xmid = (KLP_SP + (maxavail - KLP_SP ) * 0.5) * pred_len;
                                sizeScalar = 1.0 / (1.0 + exp(-Kmax_coefft * (prey_len - xmid)));
                                fprintf(bm->logFile, "Initialise bi-logistic1: species %s cohort %d for prey %s preychrt %d has len: %e prey_len: %e, KLP_SP: %e KUP_SP: %e maxavail: %e Kmax: %e xmid: %e sizeScalar: %e max_scalar: %e tempscalar: %e\n",
                                        FunctGroupArray[sp].groupCode, cohort, FunctGroupArray[prey].groupCode, preychrt, pred_len, prey_len, KLP_SP, KUP_SP, maxavail, Kmax_coefft, xmid, sizeScalar, FunctGroupArray[sp].max_scalar[cohort], temp_scalar);
                                
                            }
                            if (prey_len > maxavail * pred_len) {
                                xmid = (KUP_SP - (KUP_SP - maxavail) * 0.5) * pred_len;
                                sizeScalar = 1.0 / (1.0 + exp(Kmax_coefft * (prey_len - xmid)));
                                fprintf(bm->logFile, "Initialise bi-logistic2: species %s cohort %d for prey %s preychrt %d has len: %e prey_len: %e, KLP_SP: %e KUP_SP: %e maxavail: %e Kmax: %e xmid: %e sizeScalar: %e max_scalar: %e tempscalar: %e\n",
                                        FunctGroupArray[sp].groupCode, cohort, FunctGroupArray[prey].groupCode, preychrt, pred_len, prey_len, KLP_SP, KUP_SP, maxavail, Kmax_coefft, xmid, sizeScalar, FunctGroupArray[sp].max_scalar[cohort], temp_scalar);
                                
                            }
                            //fprintf(bm->logFile, "Initialise bi-logistic4: scalar %e tempscalar: %e\n", FunctGroupArray[sp].max_scalar[cohort], temp_scalar);
                            
                            if (sizeScalar > temp_scalar)
                                temp_scalar = sizeScalar;
                            
                            
                            //   if (!FunctGroupArray[sp].max_scalar[cohort][prey] && (bm->pSPVERTeat[sp][prey][chrtstage][preychrt] > 0.0)) {
                            //	   quit("There is something wrong with your parameterisation as you will never have any prey availability with current parameterisation\n");
                            //      }
                            
                            // This check is necessary as you should not get a zero result given test covers both >= and < checks so should cover species of any size either way
                            
                        }
                    } else {
                        temp_scalar = 0; // for prey groups that are not active set the size scalar to 0, which means they are not available 
                    }
                    
                    if (temp_scalar > FunctGroupArray[sp].max_scalar[cohort])
                        FunctGroupArray[sp].max_scalar[cohort] = temp_scalar;
                    
                    
                }
            }
        }
    }
    */
    
	return;
}

/**
 *	Array initialisation
 *
 *	Initialise parameter arrays
 */
void Initialise_Arrays(MSEBoxModel *bm) {
	int sp, b;

	if (verbose > 0)
		printf("Initialise biological arrays\n");

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		for (b = 0; b < bm->K_num_reg; b++) {
			bm->reg_prop[sp][b] = 1.0 / bm->K_num_reg;
			bm->initreg_prop[sp][b] = 1.0 / bm->K_num_reg;
		}
	}
	return;
}

/**
 *	Memory rationalisation
 *	Free memory for those parameter arrays no longer needed (as allocated
 *	to species/time/cohort specific entries of larger arrays in the main
 *	setup code)
 *
 */
void Free_Biol_Param_Arrays(MSEBoxModel *bm) {

	if (verbose > 1)
		printf("Freeing vertTchange_multi and vertSchange_multi\n");

	if(bm->flagtempchange)
		free1d(vertTchange_multi);
	if(bm->flagsaltchange)
		free1d(vertSchange_multi);
	if(bm->flagpHchange)
		free1d(vertPHchange_multi);

	if (verbose > 1)
		printf("Freeing regIDi\n");

	//if(bm->K_num_stocks_per_sp > 1)
	free1d(regIDi);
    
    if (verbose > 1)
        printf("Finished Free_Biol_Param_Arrays\n");

    return;
}

/**
 *	\brief Checking for cryptic biomass hiding in the boundary boxes
 *
 */
void Ecology_Boundary_Check(MSEBoxModel *bm, FILE *llogfp) {
	int b, k, n;
	char numstr[] = "Nums";

	printf("Checking for cryptic vertebrate biomass\n");

	/* Loop over boxes looking for boundary boxes */
	for (b = 0; b < bm->nbox; b++) {
		if (bm->boxes[b].type == BOUNDARY) {
			for (k = 0; k < bm->boxes[b].nz; k++) {
				for (n = 0; n < bm->ntracer; n++) {
					if (bm->boxes[b].tr[k][n] > 0) {
						if (strstr(bm->tinfo[n].name, numstr) != NULL) {
							//warn("%s has non zero members in box-%d layer-%d %e\n", bm->tinfo[n].name, b, k, bm->boxes[b].tr[k][n]);
							fprintf(llogfp, "%s has non zero members in boundary box-%d layer-%d %e\n", bm->tinfo[n].name, b, k, bm->boxes[b].tr[k][n]);
						}
					}
				}
			}
		}
	}

	return;
}

/**
 *	\brief Freeing ecological arrays
 *
 */
void Ecology_Free(MSEBoxModel *bm) {
	/* Close the output files */
	Close_Ecology_Output_Files(bm);

	printf("Freeing biology specific arrays\n");

	Tracer_Array_Free(bm);
	Epi_Tracer_Array_Free(bm);
	if(bm->terrestrial_on == TRUE)
		Land_Tracer_Array_Free(bm);

	printf("Freeing the home range structures\n");
	Free_HomeRange_Structures(bm);

	i_free1d(Fluxflag);
	i_free1d(Tolflag);
	i_free1d(Bioflag);

	i_free1d(Activeflag);
	i_free1d(DiagFluxflag);

	i_free1d(DiagTolflag);
	i_free1d(DiagBioflag);
	i_free1d(DiagActiveflag);

	if (verbose > 0)
		printf("freeing VERT arrays\n");

	free2d(VERTabund_check);

	free3d(VERTinfo);
	free3d(AGE_stock_struct_prop);

	if(BEDchange != NULL)
		free3d(BEDchange);
	free1d(BED_scale);

	if (verbose > 0)
		printf("freeing distribution arrays\n");

	free3d(cysts);
	i_free2d(counted);
	free2d(CATCHEATINGinfo);
	free2d(CATCHGRAZEinfo);
	free3d(EATINGinfo);
	free3d(FEEDinfo);
	free3d(GRAZEinfo);
	free3d(init_stock_struct_prop);
	free3d(initVERTinfo);
	free2d(KDENR);

    if(bm->flag_import_feed) {
        free2d(SUPPdistrib);
    }
    
    d_free4d(newden);
	i_free2d(nSTOCK);

	if (verbose > 0)
		printf("freeing recruitment arrays\n");

	free3d(PREYinfo);
	free3d(pSTOCK);
	free2d(recSTOCK);
	i_free2d(recover_help);
	free1d(recover_help_set);
	free2d(recruit_vdistrib);
	free4d(recVERTpopratio);
	free2d(roc);
	free3d(shiftVERT);
    
    i_free1d(tsRecruitsid);
    i_free1d(bleaching_has_occurred);

	if (verbose > 0)
		printf("freeing salt and pH change arrays\n");

	if(bm->flagsaltchange)
		free2d(Schange);
	if(bm->flagpHchange)
		free2d(PHchange);

	if (verbose > 0)
		printf("freeing tracker arrays\n");

	i_free2d(shiftVERTON);
	free1d(sizeMinMax);
	free2d(spSTOCKprop);
	i_free2d(starve_vert);
	free2d(stock_prop);
	free2d(sumSTOCK);
	free2d(step1distrib);
	if(bm->flagtempchange)
		free2d(Tchange);
	free2d(tempdistrib);
	free2d(totden);

	if (verbose > 0)
		printf("freeing tot arrays\n");

	free3d(totrecruit);
	free1d(bm->tot_SSB);
	free2d(tot_yoy);
	if(Vchange_max_num > 0)
		free3d(Vchange);

	if(verbose > 0)
		printf("Free variable info\n");

	c_free2d(Varname);
	c_free2d(DiagVarname);

	if(verbose > 0)
		printf("Free coastal degradation and invader arrays\n");

	free1d(Box_degradedi);

	if (bm->InvadeArray)
		free2d(bm->InvadeArray);
    if (bm->invader_spread_scalars)
        free2d(bm->invader_spread_scalars);
	free5d(LinearMortChange);
	i_free3d(numMortChanges);

	if(verbose > 1)
		printf("Free diet info\n");

	free4d(spPreyAvail);

	free5d(DIET_check);

	// Free EMBRYO data structure
	Free_Embryo(bm);
	
	/* Free up the external scaling memory */

	Free_Imposed_Recruits(bm);
	if (bm->use_external_scaling) {
		Free_Scalar_Prop(bm, bm->externalBiologyInput);
	}

	// Free MIGRATION data structure
	Free_Migration(bm);

	// Free DNA data structure
	Free_Evolution(bm);

	// Free Coral Reef data structure
	Free_CoralReef(bm);

	if(bm->track_contaminants){
		Free_Contaiminants(bm);
	}

	return;
}

/**
 *\brief Free up the MIGRATION memory.
 *
 *	Frees up each of the tracer arrays and then the MIGRATION array.
 */
void Free_Migration(MSEBoxModel *bm) {
	int sp;

	if(verbose > 0)
		printf("Free Migration info\n");

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        
        i_free1d(MIGRATION[sp].ActualMigrator);
        
        free2d(MIGRATION[sp].aging);
		i_free2d(MIGRATION[sp].EndDay);
        i_free2d(MIGRATION[sp].StartDay);
        i_free2d(MIGRATION[sp].Leave_Now);
        i_free2d(MIGRATION[sp].Return_Now);
        i_free2d(MIGRATION[sp].Period);
        i_free2d(MIGRATION[sp].Return_Period);
        i_free2d(MIGRATION[sp].Leave_Period);
        i_free2d(MIGRATION[sp].YearsAway);
        
        i_free2d(MIGRATION[sp].returnstock);
        i_free2d(MIGRATION[sp].all_go);
        free2d(MIGRATION[sp].survival);
        free2d(MIGRATION[sp].growth);
        
        i_free2d(MIGRATION[sp].AgeMigrationCheckDone);
        i_free2d(MIGRATION[sp].return_stage_prm);
        i_free2d(MIGRATION[sp].leave_stage_prm);
        i_free2d(MIGRATION[sp].use_stage_prm_done);
        i_free2d(MIGRATION[sp].migrationID);
        i_free2d(MIGRATION[sp].start_return_chrt);
        i_free2d(MIGRATION[sp].end_return_chrt);
        
        free2d(MIGRATION[sp].num_aging_event);
        free2d(MIGRATION[sp].current_pop_ratio);
        free3d(MIGRATION[sp].pop_ratio);
        free2d(MIGRATION[sp].prop_mig);
        free1d(MIGRATION[sp].totprop_mig);
        free2d(MIGRATION[sp].recruit);

        free2d(MIGRATION[sp].DEN);
        free2d(MIGRATION[sp].SN);
        free2d(MIGRATION[sp].RN);
        
        free2d(MIGRATION[sp].MigYOY);
        free2d(MIGRATION[sp].MigYOY_SN);
        free2d(MIGRATION[sp].MigYOY_RN);
        
        free3d(MIGRATION[sp].Box);

        free2d(MIGRATION[sp].InitDEN);
        free2d(MIGRATION[sp].InitSN);
        free2d(MIGRATION[sp].InitRN);

	}

	free(MIGRATION);

}

/**
 *\brief Free up the EMBRYO memory.
 *
 *	Frees up each of the tracer arrays and then the EMBRYO array.
 */
void Free_Embryo(MSEBoxModel *bm) {
	int sp;

	if(verbose > 0)
		printf("Free Embryo info\n");

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if ((FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED || FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS)) {
			i_free2d(EMBRYO[sp].Age_Now);
			i_free2d(EMBRYO[sp].Spawn_Now);
			i_free2d(EMBRYO[sp].EndDay);
			i_free2d(EMBRYO[sp].StartDay);
			free1d(EMBRYO[sp].RecruitPeriod);
			i_free1d(EMBRYO[sp].wraps);

			free1d(EMBRYO[sp].BulkRecruits);
			free1d(EMBRYO[sp].TotSpawn);
			free1d(EMBRYO[sp].IndSpawn);
			free1d(EMBRYO[sp].recruitSPden);

			free3d(EMBRYO[sp].Larvae);
			free4d(EMBRYO[sp].num_recruits);
            
            i_free1d(EMBRYO[sp].readytospawn);
		}
	}

	free(EMBRYO);

}

/**
 *\brief Free up the DNA memory.
 *
 *	Frees up each of the tracer arrays and then the DNA array.
 */
void Free_Evolution(MSEBoxModel *bm) {
	int sp;

	if(!bm->flag_do_evolution && !bm->flag_mult_grow_curves)  // Nothing to do
		return;

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		free1d(DNA[sp].stdev_gene_map);  // Used if there are multiple growth curves

		if(!bm->flag_do_evolution)      // Rest only used of there is evolution
			continue;

		free1d(DNA[sp].tot_num);
		free1d(DNA[sp].sn);
		free1d(DNA[sp].rn);
		free1d(DNA[sp].num);
		free1d(DNA[sp].phenotype_aging_up);
        d_free1longd(DNA[sp].scaled_change);
		d_free3longd(DNA[sp].trait);
		free2d(DNA[sp].phenotype_transition);
		d_free4longd(DNA[sp].trait_shift);

		i_free1d(DNA[sp].trait_active);

	}

	free(DNA);
    
    /* Free up the trait value arrays */
    if(bm->flag_do_evolution) {
        free3d(bm->evolTraitValues);
        free3d(bm->evolTraitOriginalValues);
    }

	return;
}

/**
 *\brief Free up the CORALREEF memory.
 *
 *	Frees up each of the tracer arrays and then the CORALREEF array.
 */
void Free_CoralReef(MSEBoxModel *bm) {
	int sp, id;

	if(!bm->containsCoral)  // Nothing to do
		return;

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {

		if((FunctGroupArray[sp].groupType != CORAL) && (FunctGroupArray[sp].groupType != SPONGE))
			continue;
        
        id = (int)(FunctGroupArray[sp].speciesParams[coralID_id]);

		free1d(CORALREEF[id].DHWsum);  // Used if there are multiple growth curves
		free2d(CORALREEF[id].DHWqueue);
		free1d(CORALREEF[id].TempShift);
		free1d(CORALREEF[id].GrowShift);
		free2d(CORALREEF[id].PropUnBleached);
		free2d(CORALREEF[id].RugosityEaten);
	}
	free(CORALREEF);

	return;


}

/**
 *
 *	Check that all the input data was loaded correctly.
 *
 *
 */
void Check_Input_Data(MSEBoxModel *bm, FILE *llogfp) {
	int sp, ngene, b;

	// Used to do Check_Migration_Data() but that has been moved to where MIGRATION is initialised

	// Copy recruit_hdistrib to all gene types
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		for (ngene = 0; ngene < FunctGroupArray[sp].numGeneTypes; ngene++) {
			for (b = 0; b < bm->nbox; b++) {
                if (ngene > 0)
                    bm->recruit_hdistrib[ngene][b][sp] = bm->recruit_hdistrib[0][b][sp];  // As zero entry was read in from file
				// (currently assumes all genetypes start with the same distrubtion initially)
                bm->recruit_hdistrib_orig[ngene][b][sp] = bm->recruit_hdistrib[0][b][sp];
			}
		}
	}

}

/**
 *	\brief This function is called to allocate arrays before the input file is read.
 *	Only allocates arrays required to store input parameters - allocate the rest
 *	once we have successfully read in the input file.
 *
 */
void Allocate_Arrays_Pre_Load(MSEBoxModel *bm, FILE *llogfp) {
	int totalNumberDiagVars, totalNumberDynVars;

	//totalNumberVars = 2 * numwcvar + numepivar + numdiagvar + numfstatvar;
	totalNumberDynVars = 2 * numwcvar + numepivar + numlandvar;
	totalNumberDiagVars = numdiagvar + numfstatvar;

	/* Build global vectors ******************************************************************
	 Using sjwlib routines for doubles and ints but spell it out in standard c for Name case */

	if(verbose > 0)
		printf("Allocate fluxes and flags\n");

	/* Now those for the eco libraries */
	Fluxflag = (int *) i_alloc1d(totalNumberDynVars);
	Tolflag = (int *) i_alloc1d(totalNumberDynVars);
	Bioflag = (int *) i_alloc1d(totalNumberDynVars);
	Activeflag = (int *) i_alloc1d(totalNumberDynVars);
	DiagFluxflag = (int *) i_alloc1d(totalNumberDiagVars);
	DiagTolflag = (int *) i_alloc1d(totalNumberDiagVars);
	DiagBioflag = (int *) i_alloc1d(totalNumberDiagVars);
	DiagActiveflag = (int *) i_alloc1d(totalNumberDiagVars);

	Varname = (char **) c_alloc2d(50, totalNumberDynVars);
	DiagVarname = (char **) c_alloc2d(50, totalNumberDiagVars);

	/* Allocate the arrays that are required to store input parameters.
	 * Allocate the rest once we have successfully loaded the input file.
	 */

	/* Set vertebrate array values (i.e. populate the array with values, which are
	 actual parameter values read in previously or defaults to be used if no
	 parameters exist) */
	//distrib_VERTICAL = Util_Alloc_Init_4D_Double(bm->K_num_tot_sp, 2, bm->wcnz, 2, 0.0);

	recruit_vdistrib = Util_Alloc_Init_2D_Double(bm->K_num_tot_sp, bm->wcnz, 0.0);

	pSTOCK = Util_Alloc_Init_3D_Double(bm->K_num_max_stages, bm->K_num_stocks_per_sp, bm->K_num_tot_sp, 1.0);
	KDENR = Util_Alloc_Init_2D_Double(bm->K_num_stocks_per_sp, bm->K_num_tot_sp, 0.0);
	recSTOCK = Util_Alloc_Init_2D_Double(bm->K_num_stocks_per_sp, bm->K_num_tot_sp, 1.0);

	maxMortChange = 1;
	numMortChanges = Util_Alloc_Init_3D_Int(bm->nbox, bm->K_num_max_stages, bm->K_num_tot_sp, 0);
	LinearMortChange = Util_Alloc_Init_5D_Double(3, maxMortChange, bm->nbox, bm->K_num_max_stages, bm->K_num_tot_sp, 0);
    
    tsRecruitsid = Util_Alloc_Init_1D_Int(bm->K_num_tot_sp, 0);
    
    bleaching_has_occurred = Util_Alloc_Init_1D_Int(bm->K_num_tot_sp, 0);  // for use with corals

    if(bm->flag_import_feed)
        SUPPdistrib = (double **) alloc2d(bm->nbox, bm->K_num_tot_sp);

    Ecology_Setup_Evolution(bm, llogfp);
}

/**
 *	\brief This function is called to allocate arrays after the input file is read.
 *
 */
void Allocate_Arrays_Post_Load(MSEBoxModel *bm, FILE *llogfp) {
	int i, totdensize;
	int nlayer = bm->wcnz;
	int ncells = bm->nbox;
	int ntotsp = bm->K_num_tot_sp;
	int ncohorts = bm->K_num_max_cohort;
	int nstock = bm->K_num_stocks_per_sp;
	int ngenetypes = bm->K_num_max_genetypes;

	//printf("Creating PostLoad arrays\n");

	/* Allocate memory for vertebrate parameter arrays */
	/* Setup all arrays for vertebrate processes */
	VERTabund_check = Util_Alloc_Init_2D_Double(ncohorts * ngenetypes, bm->K_num_tot_sp, 0.0);
	VERTinfo = Util_Alloc_Init_3D_Double(3, ncohorts * ngenetypes, bm->K_num_tot_sp, 0.0);

	/* Set up arrays for migration out of model domain; total system state;
	 other vertebrate state info, processes, and reproduction parameters.
	 */

	/* Arrays - listed in alphabetical order for ease of access */
	AGE_stock_struct_prop = (double ***) alloc3d(nstock, ncohorts * ngenetypes, bm->K_num_tot_sp);

	// No initial values are set. These are set in InitiliseArrays.
	BED_scale = Util_Alloc_Init_1D_Double(bm->K_num_bed_types, 1.0);

	for (i = 0; i < bm->K_num_tot_sp; i++) {
		if ((FunctGroupArray[i].groupAgeType == AGE_STRUCTURED_BIOMASS) || (FunctGroupArray[i].groupAgeType == AGE_STRUCTURED)){  // Used to be for vertebrates only but now needed for any age structured due to demography code
			FunctGroupArray[i].boxPopRatio = Util_Alloc_Init_4D_Double(FunctGroupArray[i].ageClassSize, (FunctGroupArray[i].numCohortsXnumGenes), nlayer, ncells, 0.0);
		}
	}

	cysts = Util_Alloc_Init_3D_Double(bm->num_active_habitats, bm->nbox, bm->K_num_tot_sp, 0.0);
	CATCHEATINGinfo = (double **) alloc2d(ncohorts * ngenetypes, bm->K_num_tot_sp);
	CATCHGRAZEinfo = (double **) alloc2d(ncohorts * ngenetypes, bm->K_num_tot_sp);
	DIET_check = Util_Alloc_Init_5D_Double(2, bm->K_num_tot_sp, bm->K_num_stocks_per_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
    
	EATINGinfo = (double ***) alloc3d(bm->num_active_habitats, ncohorts * ngenetypes, bm->K_num_tot_sp + 1);  // The +1 is the slot for aquaculture feed
	FEEDinfo = (double ***) alloc3d(bm->num_active_habitats, ncohorts * ngenetypes, bm->K_num_tot_sp + 1);  // The +1 is the slot for aquaculture feed
	GRAZEinfo = (double ***) alloc3d(bm->num_active_habitats, ncohorts * ngenetypes, bm->K_num_tot_sp + 1);  // The +1 is the slot for aquaculture feed

	init_stock_struct_prop = Util_Alloc_Init_3D_Double(nstock, ncohorts * ngenetypes, bm->K_num_tot_sp, 0.0);

	bm->initreg_prop = Util_Alloc_Init_2D_Double(bm->K_num_reg, ntotsp + 1, 0.0);
	initVERTinfo = Util_Alloc_Init_3D_Double(3, ncohorts * ngenetypes, bm->K_num_tot_sp, 0.0);

	bm->lastreg_prop = Util_Alloc_Init_2D_Double(bm->K_num_reg, ntotsp + 1, 0.0);
	counted = Util_Alloc_Init_2D_Int(ncohorts * ngenetypes, bm->K_num_tot_sp, 0);

	newden = Util_Alloc_Init_4D_Double(ncells, nlayer, ncohorts * ngenetypes, bm->K_num_tot_sp, 0.0);
	nSTOCK = (int **) i_alloc2d(bm->maxspage, nstock);

	PREYinfo = (double ***) alloc3d(bm->num_active_habitats, ncohorts * ngenetypes, bm->K_num_tot_sp);

	recover_help = Util_Alloc_Init_2D_Int(2, bm->K_num_tot_sp, 0);
	recover_help_set = Util_Alloc_Init_1D_Double(bm->K_num_tot_sp, 0.0);

	recVERTpopratio = (double ****)d_alloc4d(bm->maxspage, bm->K_num_max_genetypes, bm->K_num_tot_sp, nstock);
	bm->regID = Util_Alloc_Init_1D_Int(bm->nbox, 0);
	bm->reg_prop = Util_Alloc_Init_2D_Double(bm->K_num_reg, ntotsp + 1, 0.0);
	roc = Util_Alloc_Init_2D_Double(ncohorts * ngenetypes, ncells, 0.0);

	shiftVERT = Util_Alloc_Init_3D_Double(3, ncohorts * ngenetypes, bm->K_num_tot_sp, 0.0);
	shiftVERTON = Util_Alloc_Init_2D_Int(ncohorts * ngenetypes, bm->K_num_tot_sp, 0);
	sizeMinMax = Util_Alloc_Init_1D_Double(4, 0.0);

	spSTOCKprop = (double **) alloc2d(ncohorts * ngenetypes, nstock);
	starve_vert = Util_Alloc_Init_2D_Int(ncells, bm->K_num_tot_sp, 0);
	bm->stock_struct_prop = (double ***) alloc3d(nstock, ncohorts * ngenetypes, bm->K_num_tot_sp);
	stock_prop = (double **) alloc2d(nstock, bm->K_num_tot_sp);
	sumSTOCK = (double **) alloc2d(bm->maxspage, nstock);
	step1distrib = (double **) alloc2d(bm->K_num_max_stages, bm->wcnz);

	tempdistrib = (double **) alloc2d(bm->K_num_max_stages, bm->wcnz);
	bm->tempPopRatio = (double ****) alloc4d(bm->maxspage, ncohorts * ngenetypes, bm->K_num_tot_sp, nstock);
	bm->totbiom = Util_Alloc_Init_1D_Double(ntotsp + 1, 0.0);
	bm->groupTotCatch = Util_Alloc_Init_2D_Double(bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
	bm->tot_SSB = (double *) alloc1d(ntotsp + 1); // Use same size as totbiom as can initialise it quickly
	totrecruit = Util_Alloc_Init_3D_Double(ngenetypes, nstock, bm->K_num_tot_sp, 0.0);

    totdensize = (ncohorts * ngenetypes);
    if((bm->K_max_invert_cohorts + 1) > totdensize)
        totdensize =  bm->K_max_invert_cohorts + 1; //As need an additional slot for propsum in invertebrate movement code
    totden = Util_Alloc_Init_2D_Double(totdensize, bm->K_num_tot_sp, 0.0);
    
	bm->diagnosticBiom = Util_Alloc_Init_1D_Double(ntotsp + 1, 0.0);

	tot_yoy = (double **) alloc2d(nstock, bm->K_num_tot_sp);

	if(Vchange_max_num > 0)
		Vchange = (double ***) alloc3d(K_num_env_scales, bm->wcnz, Vchange_max_num);

	spPreyAvail = Util_Alloc_Init_4D_Double(bm->num_active_habitats, bm->K_num_tot_sp, ncohorts * ngenetypes, bm->K_num_tot_sp, 0.0);

	// Create CORAL data structure
	Coral_Setup(bm, llogfp);

    /* Setup the evolution arrays - Needs to be done post load as the flag evolution value needs to be read in */
    if(bm->flag_do_evolution) {
        Create_Evolution_Parameters(bm);
    }

}
/**
 * \brief Allocate the population ratios.
 *
 */
void Init_Population_Ratios(MSEBoxModel *bm) {
	int i, k, ij, b;
	int sp, update_popratio;
	double totsum, sp_ageClassSize;
	int stock_id;

	/* Do the actual initial allocations. If no popratios readin then simply assign numbers
	 uniformly, otherwise assign	pre-loaded distributions readin above */
	if (!readin_popratio) {
		/* Case where no pre-existing distributions are loaded then uniform distibution assumed*/
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if(FunctGroupArray[sp].speciesParams[flag_id]){
				sp_ageClassSize = FunctGroupArray[sp].ageClassSize;
                if (sp_ageClassSize < 1)
                    sp_ageClassSize = 1;
				if ((FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS) || (FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED)) {
					for (b = 0; b < FunctGroupArray[sp].numCohortsXnumGenes; b++) {
						for (i = 0; i < FunctGroupArray[sp].ageClassSize; i++) {
							/* Population age distributions */
							for (ij = 0; ij < bm->nbox; ij++) {
								for (k = 0; k < bm->wcnz; k++) {
									FunctGroupArray[sp].boxPopRatio[ij][k][b][i] = min(1.0, 1.0 / sp_ageClassSize);
								}
							}

							/* Initialise stock summaries of age distributions */
							for (ij = 0; ij < FunctGroupArray[sp].numStocks; ij++) {
								bm->tempPopRatio[ij][sp][b][i] = min(1.0, 1.0 / sp_ageClassSize);
							}
						}

						/* Make sure the props sum to one */
						update_popratio = 0;
						totsum = 0;
						for (ij = 0; ij < FunctGroupArray[sp].numStocks; ij++) {
							totsum = 0;
							for (i = 0; i < FunctGroupArray[sp].ageClassSize; i++) {
								totsum += bm->tempPopRatio[ij][sp][b][i];
							}
							if (totsum != 1.0) {
								for (i = 0; i < FunctGroupArray[sp].ageClassSize; i++) {
									bm->tempPopRatio[ij][sp][b][i] /= totsum;

								}
								update_popratio++;
							}
						}

						if (update_popratio) {
							for (ij = 0; ij < bm->nbox; ij++) {
								for (k = 0; k < bm->wcnz; k++) {
									for (i = 0; i < FunctGroupArray[sp].ageClassSize; i++) {
										FunctGroupArray[sp].boxPopRatio[ij][k][b][i] = bm->tempPopRatio[0][sp][b][i];
									}
								}
							}
						}
					}
				}
			}
		}
	} else {
		/* Loading pre-existing distributions */
		stock_id = -1;
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if ((FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED_BIOMASS) || (FunctGroupArray[sp].groupAgeType == AGE_STRUCTURED)) {
				for (ij = 0; ij < bm->nbox; ij++) {
					for (k = 0; k < bm->boxes[ij].nz; k++) {
						stock_id = bm->group_stock[sp][ij][k];
						/* Local population age distributions */
						for (b = 0; b < FunctGroupArray[sp].numCohortsXnumGenes; b++) {
							for (i = 0; i < FunctGroupArray[sp].ageClassSize; i++) {
								FunctGroupArray[sp].boxPopRatio[ij][k][b][i] = readinpopratio[stock_id][sp][b][i];
							}
						}
					}
				}

				/* Initialise stock summaries of age distributions */
				for (stock_id = 0; stock_id < FunctGroupArray[sp].numStocks; stock_id++) {
					for (b = 0; b < FunctGroupArray[sp].numCohortsXnumGenes; b++) {
						for (i = 0; i < FunctGroupArray[sp].ageClassSize; i++) {
							bm->tempPopRatio[stock_id][sp][b][i] = readinpopratio[stock_id][sp][b][i];

							//if((int)(FunctGroupArray[sp].speciesParams[flag_id])){
							//		fprintf(bm->logFile, "bm->tempPopRatio[%d][%d][%d][%d] = %e\n",stock_id,  sp, b, i, bm->tempPopRatio[stock_id][sp][b][i]);
							//		fprintf(bm->logFile, "readinpopratio[%d][%d][%d][%d] = %e\n", stock_id, sp, b, i, readinpopratio[stock_id][sp][b][i]);
							//}

						}
					}
				}
			}
		}

		/* Free readinpopratio as no longer needed */
		free4d(readinpopratio);
	}
}

/**
 *	\brief This function is called to allocate and setup invading species related arrays.
 *
 */
static void Setup_Invade(MSEBoxModel *bm) {
	int b, chkbox, nb = -1, ndist, k, sp_move;
	double xdiff = 0.0, ydiff = 0.0, avgdist = 0.0, basedt = 0.0, dt = 0.0, dist_step1 = 0.0, maxdist = 0.0, nsteps = 0.0;

	/* Don't bother setting things up if never invading or can't spread as have zero speed */
	if ((bm->invading_sp_model == no_invader) || (!bm->InvaderSpeed))
		return;
    
    bm->invader_spread_scalars = Util_Alloc_Init_2D_Double(bm->wcnz, bm->nbox, 0.0);  // Just make in nbox so don't have to try to map chbox to box_id etc (just easier even if slightly higher memory footprint)
    
	/* Rescale InvaderScalar to a per bm->dt rate */
	nsteps = 365.0 * 86400.0 / bm->dt;
	bm->InvaderScalar = (bm->InvaderScalar - 1.0) / nsteps;

	/* Start with functional group tracer ID - get youngest cohort for all
	 as actually only used for invertebrates, any vertebrates have a
	 cohort specific call to FunctGroupArray[].NumsTracers[] in
	 the Invading_Species()
	 */
	bm->InvaderPID = FunctGroupArray[bm->InvaderIndex].totNTracers[0];

	/*** Set up Invading species spread array - to be used as an interpolated
	 scalar through time in Invading_Species()

	 Start by finding timestep associated with intermediate spread of the
	 front of invading species - so know how many subarrays are needed
	 - minimum resolution of per month (at least for now)
	 ***/
	avgdist = 0;
	ndist = 0;
	for (b = 0; b < bm->nbox; b++) {
		for (chkbox = 0; chkbox < bm->boxes[b].nconn; chkbox++) {
			nb = bm->boxes[b].ibox[chkbox];
			xdiff = bm->boxes[b].inside.x - bm->boxes[nb].inside.x;
			ydiff = bm->boxes[b].inside.y - bm->boxes[nb].inside.y;
			avgdist += sqrt(xdiff * xdiff + ydiff * ydiff);
			ndist++;
		}
	}
	avgdist /= ndist;
	basedt = (avgdist / bm->InvaderSpeed) / (86400.0);
	dt = floor(basedt / 90);

	if (dt < 1.0) {
		/* Use monthly resolution */
		bm->Invadedt = 30.0;
	} else if (dt < 2.0) {
		/* Use quarterly resolution */
		bm->Invadedt = 91.0;
	} else if (dt < 3.0) {
		/* Use half yearly resolution */
		bm->Invadedt = 182.0;
	} else {
		/* Use yearly resolution */
		bm->Invadedt = 365.0;
	}

	/* Maximum distance */
	maxdist = 0.0;
	for (b = 0; b < bm->nbox; b++) {
		xdiff = bm->boxes[b].inside.x - bm->boxes[nb].inside.x;
		ydiff = bm->boxes[b].inside.y - bm->boxes[nb].inside.y;
		dist_step1 += sqrt(xdiff * xdiff + ydiff * ydiff);
		if (dist_step1 > maxdist)
			maxdist = dist_step1;
	}

	/* Find time to saturation - maximum distance from Entry box that is in the model domain */
	basedt = (maxdist / bm->InvaderSpeed) / (86400.0);
	bm->InvaderSatDay = basedt + bm->InvaderStartDay;
	bm->Invadendt = (int) ceil(basedt / bm->Invadedt);

	/* Set up InvadeArray */
	//printf("Creating Invader array\n");

	bm->InvadeArray = Util_Alloc_Init_2D_Double(bm->Invadendt, bm->nbox, 0.0);

	/* Populate InvadeArray */
	sp_move = (int) (FunctGroupArray[bm->InvaderIndex].speciesParams[ddepend_move_id]);
	if (sp_move == no_move) {
		/* No explicit movement so have to do invasion spread here */
		bm->InvadeArray[bm->InvaderEntryBox][0] = bm->InvaderScalar;
		for (k = 0; k < bm->Invadendt; k++) {
			for (b = 0; b < bm->nbox; b++) {
				if (bm->InvadeArray[b][k] > 0) {
					for (chkbox = 0; chkbox < bm->boxes[b].nconn; chkbox++) {
						nb = bm->boxes[b].ibox[chkbox];
						xdiff = bm->boxes[b].inside.x - bm->boxes[nb].inside.x;
						ydiff = bm->boxes[b].inside.y - bm->boxes[nb].inside.y;
						dist_step1 += sqrt(xdiff * xdiff + ydiff * ydiff);
						if (dist_step1 < (bm->InvaderSpeed * bm->Invadedt * 86400.0))
							bm->InvadeArray[b][k] = bm->InvaderScalar;
					}
				}
				if ((k > (bm->Invadendt - 2)) && (bm->InvadeArray[b][k] < bm->InvaderScalar)) {
					/* For last array entry all array should be saturated */
					bm->InvadeArray[b][k] = bm->InvaderScalar;
				}
			}
		}
	} else {
		/* Movement explicit so just feed in via EntryBox - only set values
		 in EntryBox as all rest initialised to zero anyway
		 */
		for (k = 0; k < bm->Invadendt; k++) {
			bm->InvadeArray[bm->InvaderEntryBox][k] = bm->InvaderScalar;
		}
	}
    
    //printf("With send setup value of invader_spread_scalars[10][0]: %e\n", bm->invader_spread_scalars[10][0]);

    
	return;
}

/**
 *	\brief This function is called to free up the home range memory.
 *
 */
static void Free_HomeRange_Structures(MSEBoxModel *bm) {
	int sp, b;

	if(verbose > 0)
		printf("Free Home Range info\n");

	/* Free home range related counters */
	for (b = 0; b < bm->nbox; b++) {
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			i_free1d(bm->boxes[b].HomeRangeInfo[sp].ids);

			free1d(bm->boxes[b].HomeRangeInfo[sp].rangewgt);
			free2d(bm->boxes[b].HomeRangeInfo[sp].rangenum);

		}
		free(bm->boxes[b].HomeRangeInfo);
	}

	free3d(bm->HomeRangeTotal);

}

/**
 *	\brief This function is called to allocate and setup invading species related arrays.
 *
 */
static void Setup_HomeRanges(MSEBoxModel *bm, FILE *llogfp) {
	int b, sp, sp_ddepend_move, n, den, k, bb, chkbox, idnum, ij, nij, rij, last_checked, new_checked, more_to_do, sides_covered, start_box, surrounded;
	double totarea = 0.0, dist = 0.0;
	int *connected;

	//printf("Creating Homerange arrays\n");

	connected = Util_Alloc_Init_1D_Int(bm->nbox, 0);

	/* Initialise home range related counters */
	bm->K_num_homerange = 0;
	for (b = 0; b < bm->nbox; b++) {
		if ((bm->boxes[b].HomeRangeInfo = (HomeRange *) malloc((size_t)bm->K_num_tot_sp * sizeof(HomeRange))) == NULL)
			quit("Setup_HomeRanges: Can't allocate memory for HomeRangeInfo in box %d\n", b);
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			bm->boxes[b].HomeRangeInfo[sp].n = 0;
			bm->boxes[b].HomeRangeInfo[sp].ids = (int *) i_alloc1d(bm->nbox); // As should never be more home ranges than there are boxes
			for (rij = 0; rij < bm->nbox; rij++) {
				bm->boxes[b].HomeRangeInfo[sp].ids[rij] = -1;
			}
		}
	}

	printf("Constructing home ranges\n");

	/* Find max number of home ranges */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		sp_ddepend_move = (int) (FunctGroupArray[sp].speciesParams[ddepend_move_id]);

		//fprintf(llogfp,"%s has move %d vs %d\n", FunctGroupArray[sp].groupCode, sp_ddepend_move, homerange_move);

		if (sp_ddepend_move == homerange_move) {

			for (ij = 0; ij < bm->nbox; ij++) {
				if (bm->boxes[ij].type != BOUNDARY) {

					//fprintf(llogfp, "%s depth: %e vs mindepth: %e, maxdepth: %e\n", FunctGroupArray[sp].groupCode, -1.0 * bm->boxes[ij].botz,
					//		FunctGroupArray[sp].speciesParams[mindepth_id], FunctGroupArray[sp].speciesParams[maxdepth_id]);

					if (((-1.0 * bm->boxes[ij].botz) > FunctGroupArray[sp].speciesParams[mindepth_id]) && ((-1.0 * bm->boxes[ij].botz)
							<= FunctGroupArray[sp].speciesParams[maxtotdepth_id])) {
						/* Need to calculate a home range so calculate connection network */
						for (b = 0; b < bm->nbox; b++) {
							connected[b] = 0;
						}
						connected[ij] = 1;

						/* Find connections */
						start_box = ij;
						more_to_do = TRUE;
						while (more_to_do == TRUE) {
							last_checked = 0;
							new_checked = 0;
							for (b = 0; b < bm->nbox; b++) {
								/* Already identified as connected to start_box ? */
								if (connected[b]) {
									/* Cycle through nconn and see what other cells fit the bill */
									for (nij = 0; nij < bm->boxes[b].nconn; nij++) {
										chkbox = bm->boxes[b].ibox[nij];

										fprintf(llogfp, "In %d checking %d\n", ij, chkbox);

										/* Check if a boundary box */
										if (bm->boxes[chkbox].type != BOUNDARY) {
											/* Check if already connected */
											if (connected[chkbox] < 1) {
												/* Check if within range of start_box */
												dist = sqrt((bm->boxes[start_box].inside.x - bm->boxes[chkbox].inside.x) * (bm->boxes[start_box].inside.x
														- bm->boxes[chkbox].inside.x) + (bm->boxes[start_box].inside.y - bm->boxes[chkbox].inside.y)
														* (bm->boxes[start_box].inside.y - bm->boxes[chkbox].inside.y));

												fprintf(llogfp, "%s dist: %e vs rad: %e\n", FunctGroupArray[sp].groupCode, dist,
														FunctGroupArray[sp].speciesParams[homerangerad_id]);

												if (dist < FunctGroupArray[sp].speciesParams[homerangerad_id]) {
													/* Check if in appropriate depth range */

													if (((-1.0 * bm->boxes[chkbox].botz) > FunctGroupArray[sp].speciesParams[mindepth_id]) && ((-1.0 * bm->boxes[chkbox].botz) <= FunctGroupArray[sp].speciesParams[maxtotdepth_id])) {
														/* For no-overlap case check whether home-range already exists in this cell */

														fprintf(llogfp, "%s overlap: %e and chkbox-homrange-n: %d\n", FunctGroupArray[sp].groupCode,
																FunctGroupArray[sp].speciesParams[rangeoverlap_id], bm->boxes[chkbox].HomeRangeInfo[sp].n);

														if (FunctGroupArray[sp].speciesParams[rangeoverlap_id] == 0) {
															if (bm->boxes[chkbox].HomeRangeInfo[sp].n == 0) {
																connected[chkbox] = 1;
																new_checked++;
															}

															fprintf(llogfp, "new_checked: %d\n", new_checked);

														} else {
															/* For overlapping case then connection fine regardless */
															connected[chkbox] = 1;
															new_checked++;
														}
													}
												}
											}
										}
									}
								}
							}
							/* If no new ones to add to the list then break */
							if (last_checked == new_checked)
								more_to_do = FALSE;
						}

						/** Now create home ranges - Start with case where no existing home range **/
						if (bm->boxes[ij].HomeRangeInfo[sp].n == 0) {
							/* Add new home range starting in this box and checking network of neighbours */
							for (nij = 0; nij < bm->nbox; nij++) {
								/* No over-lap then add to home range */
								if (connected[nij] > 0) {
									idnum = bm->boxes[nij].HomeRangeInfo[sp].n;
									bm->boxes[nij].HomeRangeInfo[sp].ids[idnum] = bm->K_num_homerange;
									bm->boxes[nij].HomeRangeInfo[sp].n++;

									fprintf(llogfp, "Created home range for %s in box %d-to-box%d\n", FunctGroupArray[sp].groupCode, ij, nij);
								}
							}
							bm->K_num_homerange++;
						} else if (FunctGroupArray[sp].speciesParams[rangeoverlap_id] > 0) {
							/* Check if in centre of existing home range or whether
							 need to create a new overlapping home range

							 Cycle through list of existing home ranges and see if surrounded by
							 boxes under the same home range
							 */
							surrounded = FALSE;
							for (b = 0; b < bm->boxes[ij].HomeRangeInfo[sp].n; b++) {
								start_box = bm->boxes[ij].HomeRangeInfo[sp].ids[b];
								sides_covered = 0;
								for (nij = 0; nij < bm->boxes[ij].nconn; nij++) {
									chkbox = bm->boxes[ij].ibox[nij];
									if (bm->boxes[chkbox].type != BOUNDARY) {
										for (bb = 0; bb < bm->boxes[chkbox].HomeRangeInfo[sp].n; bb++) {
											idnum = bm->boxes[chkbox].HomeRangeInfo[sp].ids[bb];
											if (start_box == idnum)
												sides_covered++;
										}
									} else {
										/* If a boundary box count it as being the same home range type so
										 that can count boxes on edge as surrounded if all active boxes
										 around them share a home range designation
										 */
										sides_covered++;
									}
								}
								if (sides_covered == bm->boxes[ij].nconn)
									surrounded = TRUE;
							}

							/* If not surrounded create a new ov erlapping home range */
							if (surrounded == FALSE) {
								for (nij = 0; nij < bm->nbox; nij++) {
									/* No over-lap then add to home range */
									if (connected[nij] > 0) {
										idnum = bm->boxes[nij].HomeRangeInfo[sp].n;
										bm->boxes[nij].HomeRangeInfo[sp].ids[idnum] = bm->K_num_homerange;
										bm->boxes[nij].HomeRangeInfo[sp].n++;
										if (bm->boxes[nij].HomeRangeInfo[sp].n > bm->nbox)
											quit("Trying to create more home ranges than there are boxes - this will cause a memory stomp\n");
									}
								}
								bm->K_num_homerange++;
							}
						}
					}
				}
			}
		}
	}

	/* Set up the rest of the home range arrays - and populate them */
	bm->HomeRangeTotal = Util_Alloc_Init_3D_Double(bm->K_num_homerange, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
			for (rij = 0; rij < bm->K_num_homerange; rij++) {
				bm->HomeRangeTotal[sp][n][rij] = 0;
			}
		}
	}

	for (b = 0; b < bm->nbox; b++) {
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			bm->boxes[b].HomeRangeInfo[sp].rangewgt = (double *) alloc1d(bm->boxes[b].HomeRangeInfo[sp].n);
			bm->boxes[b].HomeRangeInfo[sp].rangenum = (double **) alloc2d(bm->boxes[b].HomeRangeInfo[sp].n, FunctGroupArray[sp].numCohortsXnumGenes);

			if (bm->boxes[b].type != BOUNDARY) {
				/* Initialise the arrays */
				for (rij = 0; rij < bm->boxes[b].HomeRangeInfo[sp].n; rij++) {
					bm->boxes[b].HomeRangeInfo[sp].rangewgt[rij] = 0;
					for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
						bm->boxes[b].HomeRangeInfo[sp].rangenum[n][rij] = 0.0;
					}
				}

				/* Now figure out real values for species using home ranges */
				sp_ddepend_move = (int) (FunctGroupArray[sp].speciesParams[ddepend_move_id]);
				if (sp_ddepend_move == homerange_move) {

					/* Work out relative weights for cells in the home range */
					fprintf(llogfp, "Box: %d %s has %d home ranges\n", b, FunctGroupArray[sp].groupCode, bm->boxes[b].HomeRangeInfo[sp].n);

					for (rij = 0; rij < bm->boxes[b].HomeRangeInfo[sp].n; rij++) {
						idnum = bm->boxes[b].HomeRangeInfo[sp].ids[rij];

						totarea = 0;
						for (ij = 0; ij < bm->nbox; ij++) {
							for (nij = 0; nij < bm->boxes[ij].HomeRangeInfo[sp].n; nij++) {
								if (bm->boxes[ij].HomeRangeInfo[sp].ids[rij] == idnum) {
									totarea += bm->boxes[ij].area;

									//fprintf(llogfp,"Box-%d (vs Box-%d) - homerange: %d (vs %d), boxarea: %e, totarea: %e\n",
									//	b, ij, idnum, bm->boxes[ij].HomeRangeInfo[sp].ids[rij], bm->boxes[ij].area, totarea);
								}
							}
						}
						bm->boxes[b].HomeRangeInfo[sp].rangewgt[rij] = bm->boxes[b].area / totarea;
						for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
							bm->boxes[b].HomeRangeInfo[sp].rangenum[n][rij] = 0.0;
						}
						fprintf(llogfp, "Box: %d homerange-%d (%d) has wgt: %e\n", b, rij, idnum, bm->boxes[b].HomeRangeInfo[sp].rangewgt[rij]);
					}

					/* Work out numbers in each home range */
					sp_ddepend_move = (int) (FunctGroupArray[sp].speciesParams[ddepend_move_id]);
					if (sp_ddepend_move == homerange_move) {
						for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
							den = FunctGroupArray[sp].NumsTracers[n];
							for (k = 0; k < bm->boxes[b].nz; k++) {
								for (rij = 0; rij < bm->boxes[b].HomeRangeInfo[sp].n; rij++) {
									/* Distribute individuals in the box evenly over the starting home ranges */
									bm->boxes[b].HomeRangeInfo[sp].rangenum[n][rij] += bm->boxes[b].tr[k][den] / bm->boxes[b].HomeRangeInfo[sp].n;

									//fprintf(llogfp, "Box: %d-%d homerange-%d (of %d) %s-%d has num: %e (den: %e, n: %d)\n",
									//	b, k, rij, bm->boxes[b].HomeRangeInfo[sp].n, FunctGroupArray[sp].groupCode, n, bm->boxes[b].HomeRangeInfo[sp].rangenum[n][rij], bm->boxes[b].tr[k][den], bm->boxes[b].HomeRangeInfo[sp].n);

								}
							}
						}
					}
				}
			}
		}
	}
	i_free1d(connected);
	//quit("End home range check so quit test\n");
	return;
}

/**
 * \brief This function will initialise the spPreyAvail array for use in the Eat function.
 *
 * It will also set the isDetritusEater flag to true if the group eats detrius.
 */
static void Setup_PreyAvail(MSEBoxModel *bm, FILE *llogfp) {
	int sppred_id, predatorGuildID, preyGuildID, habitat, cohort, stage, bcohort;
	double prey_avail;

	for (predatorGuildID = 0; predatorGuildID < bm->K_num_tot_sp; predatorGuildID++) {

		/* Assume that the group does not eat detritus */
		FunctGroupArray[predatorGuildID].isDetritusEater = FALSE;

		/* Determine if use age structured prey availability to represent ontogenetic feeding
		 shifts for this group */
		sppred_id = (int) FunctGroupArray[predatorGuildID].speciesParams[age_structured_prey_id];
		for (cohort = 0; cohort < FunctGroupArray[predatorGuildID].numCohortsXnumGenes; cohort++) {
			bcohort = (int)floor (cohort / FunctGroupArray[predatorGuildID].numGeneTypes);
			for (preyGuildID = 0; preyGuildID < bm->K_num_tot_sp; preyGuildID++) {
				for (habitat = WC; habitat < bm->num_active_habitats; habitat++) {

					prey_avail = 0.0;

					/* get general prey availability term *

					stage = FunctGroupArray[predatorGuildID].cohort_stage[cohort];

                    */
                    stage = FunctGroupArray[predatorGuildID].cohort_stage[cohort];
					prey_avail = FunctGroupArray[predatorGuildID].pSPEat[stage][preyGuildID][habitat];

					/* don't do bacteria here as handled elsewhere */
					if (FunctGroupArray[preyGuildID].isBacteria == TRUE){
						prey_avail = 0.0;
					}

					if(bm->flag_fine_ontogenetic_diets){
						/* get vertebrate age structured prey availability terms */
						if (sppred_id && (FunctGroupArray[preyGuildID].groupType == LG_ZOO || FunctGroupArray[preyGuildID].groupType == MED_ZOO || FunctGroupArray[preyGuildID].groupType == LG_INF
								|| FunctGroupArray[preyGuildID].groupType == SED_EP_FF || FunctGroupArray[preyGuildID].groupType == SED_EP_OTHER
								|| FunctGroupArray[preyGuildID].groupType == MOB_EP_OTHER)) {
							/* Only use ontogenetic shift if possible link identified in general array */
							if (prey_avail > 0 && FunctGroupArray[preyGuildID].speciesParams[p_split_id] == 0)
								prey_avail = bm->pSPageeat[predatorGuildID][bcohort][preyGuildID];
						}
					}

					if(prey_avail > 1.0)
						prey_avail = 1.0;

					spPreyAvail[predatorGuildID][cohort][preyGuildID][habitat] = prey_avail;

					/* If the group eats detritus then set the isDetritusEater flag to true */
					if (prey_avail > 0.0 && (FunctGroupArray[preyGuildID].groupType == LAB_DET || FunctGroupArray[preyGuildID].groupType == REF_DET)) {
						FunctGroupArray[predatorGuildID].isDetritusEater = TRUE;
					}
				}
			}
		}
	}
}

static void Set_Default_Species_Values(MSEBoxModel *bm, FILE *llogfp) {
	int i;

	if(verbose > 0)
		printf("Setting default values\n");

	for (i = 0; i < bm->K_num_tot_sp; i++) {
		FunctGroupArray[i].speciesParams[feed_while_spawn_id] = 1;
	}
}

/**
 *	\brief Set the spMinMax values for each of the vertebrates.
 */
static void Set_spMinMax_Values(MSEBoxModel *bm) {
	int sp, nage, nmat;

	if (verbose > 0)
		printf("Get vert ids\n");

	/* Get indices to use in movement allocation routines */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if ((int) FunctGroupArray[sp].speciesParams[flag_id] == TRUE) {
			switch (FunctGroupArray[sp].groupAgeType){
			case AGE_STRUCTURED:
				/* Remember the indices for smallest and largest sizes of the current fish eaters */
				nage = (int) (FunctGroupArray[sp].speciesParams[age_mat_id] - 1);
				nmat = (int) (FunctGroupArray[sp].speciesParams[age_mat_id]);
				if(nmat >= FunctGroupArray[sp].numCohorts)  // Need this check in case of unusual parameterisations (otherwise it stomps memory)
					nmat = FunctGroupArray[sp].numCohorts - 1;
				/* For the vertebrate eaters, set bounds on juvenile and adult size (upper and lower
				 bounds on structural weight) so can determine which grey groups can fit through
				 their gapes. */
				FunctGroupArray[sp].spMinMax[0] = FunctGroupArray[sp].structNTracers[0];
				FunctGroupArray[sp].spMinMax[1] = FunctGroupArray[sp].structNTracers[nage];
				FunctGroupArray[sp].spMinMax[2] = FunctGroupArray[sp].structNTracers[nmat];
				FunctGroupArray[sp].spMinMax[3] = FunctGroupArray[sp].structNTracers[(FunctGroupArray[sp].numCohortsXnumGenes) - 1];
				break;
			case AGE_STRUCTURED_BIOMASS: /* Done a different way, but may refer to totNTracers */
			case BIOMASS:
				break;
			}

		}
	}

	return;
}

/**
 *	Check the migration data is valid.
 *
 */
void Check_Migration_Data(MSEBoxModel *bm, int speciesIndex, int stageIndex)
{
	int qid;
	char str[STRLEN];

	int counter = (int) (FunctGroupArray[speciesIndex].speciesParams[num_migrate_id]);

	//
	//    if(FunctGroupArray[speciesIndex].groupAgeType == AGE_STRUCTURED_BIOMASS)
	//        counter = (int)(FunctGroupArray[speciesIndex].cohortSpeciesParams[adultIndex][num_migrate_id]);
	//    else

	// Check thge migration information.
	for (qid = 0; qid < counter; qid++) {
		if (MIGRATION[speciesIndex].StartDay[stageIndex][qid] > MIGRATION[speciesIndex].EndDay[stageIndex][qid]) {
			sprintf(
					str,
					"atBiology checkMigraionData(): you have %s leaving one year and returning the next. Note those beginning outside model domain not accounted for yet - need to add code for this.\n",
					FunctGroupArray[speciesIndex].groupCode);
			warn(str);
		}
	}
}

/**
 *
 * \brief Read in the larval dispersion input data.
 * IO functions like this should eventually be in a new atBiologyIO.c file that contains
 * all IO functions.
 *
 */
int Ecology_Read_Larval_Matrix(MSEBoxModel *bm) {

	int fid; /* The netcdf file index */
	int sp;
	int ndims = 0; /* Number of dimensions */
	int nvars = 0; /* Number of variables */
	int ngatts = 0; /* Number of global attributes */
	int recdim = 0; /* ID of unlimited dimension */
	int t_id = 0; /* Dimension ids */
	int d_id = 0;
	int r_id = 0;
	int sp_vid;
	long start[3];
	long count[3];
	char variableName[BMSLEN];
	FILE *fp;
	char netcdfFileName[BMSLEN];
	int localised_recruit;
	long n;
	int numRunYears = (int)(ceil(bm->tstop / 86400) / 365.0 + 1);

	//printf("Creating Larval distrib arrays\n");

	/* Open the file */
	if ((fp = Open_Input_File(bm->inputFolder,bm->forceIfname, "r")) == NULL)
		quit("Ecology_Read_Larval_Matrix: Can't open %s%s\n", bm->inputFolder, bm->forceIfname);

	/* Set error routine to warn if parameters not found */
	set_keyprm_errfn(warn);

	/* Read the list of files */
	readkeyprm_i(fp, "use_larvalfiles", &bm->use_larvalfiles);

	if (bm->use_larvalfiles) {

		/* Allocate the connectivity matrix */
		bm->connectivitymatrix = Util_Alloc_Init_4D_Double(bm->nbox, bm->nbox, numRunYears, bm->K_num_tot_sp, 0.0);
		bm->larvaldistrib = Util_Alloc_Init_2D_Double(bm->K_num_tot_sp, bm->nbox, 0.0);

		printf("use_larvalfiles: %d\n", bm->use_larvalfiles);

		/* Set error routine to quit if parameters not found */
		set_keyprm_errfn(quit);
		readkeyprm_i(fp, "larval_rewind", &bm->larval_rewind);
		readkeyprm_s(fp, "Larval0.name", netcdfFileName);

		/* Open input netCDF file */
		fid = Util_ncopen(bm->inputFolder, netcdfFileName, NC_NOWRITE);

		/* Inquire about this file */
		ncinquire(fid, &ndims, &nvars, &ngatts, &recdim);
		if (ndims < 3)
			quit("Ecology_Read_Larval_Matrix: not enough dimensions\n");
		if (nvars < 2)
			quit("Ecology_Read_Larval_Matrix: not enough variables\n");

		/* Check dimensions are as expected */
		if ((t_id = ncdimid(fid, "t")) == -1)
			quit("Ecology_Read_Larval_Matrix: no t dimension");
		if (t_id != recdim)
			quit("Ecology_Read_Larval_Matrix: t dimension not unlimited\n");
		if ((d_id = ncdimid(fid, "d")) == -1)
			quit("Ecology_Read_Larval_Matrix: no d dimension\n");
		if ((r_id = ncdimid(fid, "r")) == -1)
			quit("Ecology_Read_Larval_Matrix: no r dimension\n");

		/* Now read in the data */

		/* Read the number of years that there is dispersion data */
		ncdiminq(fid, t_id, NULL, &n);
		bm->larvalYears = (int)n;
		printf("bm->larvalYears = %d\n", bm->larvalYears);

		start[0] = 0;
		start[1] = 0;
		start[2] = 0;
		count[0] = min(bm->larvalYears, numRunYears);
		count[1] = bm->nbox;
		count[2] = bm->nbox;

		/* Now read the species data into the connectivityMatrix array */
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			localised_recruit = (int) (FunctGroupArray[sp].speciesParams[flaglocalrecruit_id]);
			if (localised_recruit == larval_dispersal) {

				/* Read in the data*/
				sprintf(variableName, "%s_Connnectivity", FunctGroupArray[sp].groupCode);
				fprintf(bm->logFile, "Searching for %s in file %s\n", variableName, netcdfFileName);
				sp_vid = ncvarid(fid, variableName);
				if (sp_vid < 0)
					quit("Ecology_Read_Larval_Matrix: no %s variable in %s\n", variableName, netcdfFileName);

				ncvarget(fid, sp_vid, start, count, bm->connectivitymatrix[sp][0][0]);
			}
		}

		ncclose(fid);
	} else {
		/* Check to see if we should have found file information *
		 */
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if ((int) (FunctGroupArray[sp].speciesParams[flaglocalrecruit_id]) == larval_dispersal)
				quit(
						"ERROR: Ecology_Read_Larval_Matrix: You have requested larval dispersal local recruitment for %s but not specified an input netcdf file in your forcing file. See the Atlantis wiki for more information\n",
						FunctGroupArray[sp].groupCode);
		}

	}

	fclose(fp);
    
    
    // Also do some sanity checking
    if (!bm->use_larvalfiles && bm->larvae_connect_only) {
        quit("use_larvalfiles in force.prm set to 0 but larvae_connect_only in biol.prm set to 1. This does not make sense, if there are no larvalfile set larvae_connect_only to 0\n");
    }
    
	return 0;
}

/**
 *
 * \brief Setup EMBRYO data structure
 *
 */
void Ecology_Setup_Reproduction(MSEBoxModel *bm) {
	int sp = 0, cohort = 0;
	int max_num = 1;
	int num_stocks = 1;
    int numRunYears = (int)(ceil(bm->tstop / 86400) / 365.0 + 1);
    int Recruit_Time_sp, add_step;

	// Create EMBRYO data structure
	//printf("Creating EMBRYO arrays\n");

	EMBRYO = (DemographicStruct *) malloc(sizeof(DemographicStruct) * (size_t)(bm->K_num_tot_sp + 1));
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        
		if(FunctGroupArray[sp].groupAgeType == BIOMASS) // If not age structured then don't need to worry about spawning queues
			continue;

		cohort = FunctGroupArray[sp].numCohortsXnumGenes;
        Recruit_Time_sp = (int) (FunctGroupArray[sp].speciesParams[Recruit_Time_id]);
        add_step = floor(Recruit_Time_sp / 365) + 1; // find steps needed for the first year to cover larvae from the previous year - always allow for a single year just in case
        
		EMBRYO[sp].num_in_yr = (int)(FunctGroupArray[sp].numSpawns);
		max_num = (EMBRYO[sp].num_in_yr) * (numRunYears + add_step);
		num_stocks = FunctGroupArray[sp].numStocks;
		EMBRYO[sp].recruiting_now = 0;
		EMBRYO[sp].num_in_spawn_queue = max_num;
		EMBRYO[sp].num_in_aging_queue = max_num;
		EMBRYO[sp].num_in_larval_queue = max_num;

        EMBRYO[sp].readytospawn = Util_Alloc_Init_1D_Int(num_stocks, 0);;
		
		EMBRYO[sp].Age_Now = Util_Alloc_Init_2D_Int(max_num, cohort, 0);
		EMBRYO[sp].Spawn_Now = Util_Alloc_Init_2D_Int(max_num, cohort, 0);
		EMBRYO[sp].EndDay = Util_Alloc_Init_2D_Int(max_num, cohort, 0);
		EMBRYO[sp].StartDay = Util_Alloc_Init_2D_Int(max_num, cohort, 0);
		EMBRYO[sp].RecruitPeriod = Util_Alloc_Init_1D_Double(max_num, 0);
		EMBRYO[sp].wraps = Util_Alloc_Init_1D_Int(cohort, 0);

		EMBRYO[sp].BulkRecruits = Util_Alloc_Init_1D_Double(FunctGroupArray[sp].numGeneTypes, 0);
		EMBRYO[sp].TotSpawn = Util_Alloc_Init_1D_Double(FunctGroupArray[sp].numGeneTypes, 0);
		EMBRYO[sp].IndSpawn = Util_Alloc_Init_1D_Double(cohort, 0);
		EMBRYO[sp].recruitSPden = Util_Alloc_Init_1D_Double(FunctGroupArray[sp].numGeneTypes, 0);

		EMBRYO[sp].Larvae = Util_Alloc_Init_3D_Double(max_num, FunctGroupArray[sp].numGeneTypes, num_stocks, 0.0);
		EMBRYO[sp].num_recruits = Util_Alloc_Init_4D_Double(max_num, FunctGroupArray[sp].numGeneTypes, bm->wcnz, bm->nbox, 0);

	}

}

/**
 *
 * \brief Setup DNA data structure
 *
 */
void Ecology_Setup_Evolution(MSEBoxModel *bm, FILE *llogfp) {
	int sp = 0, gene_cohort = 0, num_ages = 0, ntrait = 0, cohort  = 0;

	if(bm->K_num_max_genetypes < 2)  // Nothing to do
		return;

	// Create DNA data structure
	//printf("Creating DNA arrays\n");

	DNA = (EvolutionStruct *) malloc(sizeof(EvolutionStruct) * (size_t)(bm->K_num_tot_sp + 1));
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {

		gene_cohort = FunctGroupArray[sp].numCohortsXnumGenes;
		num_ages = FunctGroupArray[sp].ageClassSize;

		DNA[sp].stdev_gene_map = Util_Alloc_Init_1D_Double(FunctGroupArray[sp].numGeneTypes, 0);  // This is used if there are multiple growth curves

		DNA[sp].tot_num = Util_Alloc_Init_1D_Double(FunctGroupArray[sp].numCohorts, 0);
		DNA[sp].sn = Util_Alloc_Init_1D_Double(gene_cohort, 0);
		DNA[sp].rn = Util_Alloc_Init_1D_Double(gene_cohort, 0);
		DNA[sp].num = Util_Alloc_Init_1D_Double(gene_cohort, 0);
        DNA[sp].scaled_change = Util_Alloc_Init_1D_Long_Double(K_num_traits, 0);
		DNA[sp].trait = Util_Alloc_Init_3D_Long_Double(K_num_evol_prop, FunctGroupArray[sp].numCohorts, K_num_traits, 0.0);
		DNA[sp].phenotype_aging_up = Util_Alloc_Init_1D_Double(gene_cohort, 0);
		DNA[sp].phenotype_transition = Util_Alloc_Init_2D_Double(FunctGroupArray[sp].numGeneTypes, gene_cohort, 0.0);
		DNA[sp].trait_shift = Util_Alloc_Init_4D_Long_Double(K_num_evol_shift, num_ages, FunctGroupArray[sp].numCohorts, K_num_traits, 0);

		DNA[sp].trait_active = Util_Alloc_Init_1D_Int(K_num_traits, 0);

		for (ntrait = 0; ntrait < K_num_traits; ntrait++) {
			for (cohort = 0; cohort < FunctGroupArray[sp].numCohorts; cohort ++)
                DNA[sp].trait_shift[ntrait][cohort][0][evol_birth_shift_id] = 1.0;
		}

	}

	return;
}


/**
 *
 * \brief Setup Coral data structure
 *
 */
void Coral_Setup(MSEBoxModel *bm, FILE *llogfp) {
	int sp;
    int id = 0;

	if(!bm->containsCoral)
		return;

	//printf("Creating CORAL arrays\n");

	CORALREEF = (CoralStruct *) malloc(sizeof(CoralStruct) * (size_t)(bm->K_num_tot_sp + 1));
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        FunctGroupArray[sp].speciesParams[coralID_id] = -1;

		if((FunctGroupArray[sp].groupType != CORAL) && (FunctGroupArray[sp].groupType != SPONGE))
			continue;

		CORALREEF[id].DHWsum = Util_Alloc_Init_1D_Double(bm->nbox, 0.0);
		CORALREEF[id].DHWqueue = Util_Alloc_Init_2D_Double(bm->K_max_num_DHW, bm->nbox, 0.0);

		CORALREEF[id].TempShift = Util_Alloc_Init_1D_Double(bm->nbox, 1.0);
		CORALREEF[id].GrowShift = Util_Alloc_Init_1D_Double(bm->nbox, 1.0);

		CORALREEF[id].PropUnBleached = Util_Alloc_Init_2D_Double(bm->nbox, (FunctGroupArray[sp].numCohortsXnumGenes), 1.0);
		CORALREEF[id].RugosityEaten = Util_Alloc_Init_2D_Double(bm->nbox, (FunctGroupArray[sp].numCohortsXnumGenes), 0.0);
        
        FunctGroupArray[sp].speciesParams[coralID_id] = id;
        id++;
	}

	return;

}

/**
 * Setup cohort distribution of evolving parameters so they can be tracked acorss cohorts.
 * We store the original values as well as initialise the array vallues that will change over time.
 *
 *
 */
static void Create_Evolution_Parameters(MSEBoxModel *bm){
    
    //double numsec = 86400.0; /* number of seconds in a day */
    //double *values = 0;
    double final_val, stdev_map_param, sp_std_dev, speciesValue;
    int b, cohort, ngene;
    int traitIndex, speciesParamIndex, species;
	speciesParamIndex = -1;
    
    /* Check that ecolution is turned on - else return */
    if (!bm->flag_do_evolution)
        return;
    
    /* Allocate the arrays */
    bm->evolTraitValues = Util_Alloc_Init_3D_Double(K_num_traits, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
    bm->evolTraitOriginalValues = Util_Alloc_Init_3D_Double(K_num_traits, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
    
    for (traitIndex = 0; traitIndex < K_num_traits; traitIndex++){
        
        switch (traitIndex) {
            case growth_trait_id:  		/* Growth rate */
                /* Intentionally not handled - this functionality is covered by other code */
                break;
            case consumption_trait_id:
                /* Intentionally not handled - this functionality is covered by other code */
                break;
            case maturation_trait_id: 	/* Size of maturity */
                /* Intentionally not handled - this functionality is covered by other code */
                fprintf(stderr , "WARNING - NOT TESTED AT ALL!!!!!!");
                break;
            case reproduce_trait_id:  	/* Reproductive investment - TODO: Will need to make this have a genetic component */
                speciesParamIndex = FSP_id;
                fprintf(stderr , "WARNING - NOT TESTED AT ALL!!!!!!");
                
                break;
            case temp_trait_id:  		/* Temperature tolerance - will need to cover range and effect */
                // TODO: Need to diversify how these traits work or have co-evolution of traits; and allow options for bounds to expand (i.e. not just one end of window of tolerance to move but both)
                fprintf(stderr , "WARNING - NOT TESTED AT ALL!!!!!!");
                if (bm->flag_bound_change)
                    speciesParamIndex = max_move_temp_id;
                else
                    speciesParamIndex = q10_optimal_temp_id;
                break;
            case pH_trait_id:  			/* pH tolerance and level of impact - will need to cover range and effect  */
                // TODO: As with temperature will need to make this have a genetic component and deal with more aspects of the traits
                fprintf(stderr , "WARNING - NOT TESTED AT ALL!!!!!!");
                
                if (bm->flag_bound_change)
                    speciesParamIndex = pH_constB_id;
                else
                    speciesParamIndex = pH_constA_id;
                break;
            case salt_trait_id:			/* Salinity tolerance - will need to cover range and effect  */
                fprintf(stderr , "WARNING - NOT TESTED AT ALL!!!!!!");
                // TODO: As with temperature will need to make this have a genetic component and deal with more aspects of the traits
                if (bm->flag_bound_change)
                    speciesParamIndex = min_move_salt_id;
                else
                    speciesParamIndex = salt_correction_id;
                break;
            case rsmid_trait_id:  		/* RSmid - age at half the RN/SN maximum */
                speciesParamIndex = RSmid_id;
                break;
            case rsprop_trait_id:
                speciesParamIndex = RSprop_id;
                break;
                
            default:
                quit(" No such trait functional added as yet\n");
                break;
        }
        
        for (species = 0; species < bm->K_num_tot_sp; species++) {
            
            if (DNA[species].trait_active[traitIndex] > 0){
                /* Get the value from the species parameter */
                speciesValue = FunctGroupArray[species].speciesParams[speciesParamIndex];
                for (cohort = 0; cohort < FunctGroupArray[species].numCohortsXnumGenes; cohort++) {
                    
                    b = (int)floor(cohort / FunctGroupArray[species].numGeneTypes);
                    ngene = cohort - (b * FunctGroupArray[species].numGeneTypes);
                    
                    stdev_map_param = DNA[species].stdev_gene_map[ngene];
                    sp_std_dev = FunctGroupArray[species].speciesParams[trait_variance_id];
                    final_val = speciesValue + sp_std_dev * stdev_map_param * speciesValue;
                    
                    /* Store the original and current values */
                    bm->evolTraitValues[species][cohort][traitIndex] = final_val;
                    bm->evolTraitOriginalValues[species][cohort][traitIndex] = final_val;
                    
                   // fprintf(bm->logFile ,"bm->evolTraitValues[species = %s][cohort = %d][traitIndex = %d] = %e\n",
                   //         FunctGroupArray[species].groupCode, cohort, traitIndex, bm->evolTraitValues[species][cohort][traitIndex]);
                    
                    
                }
            }
            
        }
    }
    
    return;
}
