/**
 \file
 \brief C file for process subroutines dealing with an external population model for vertebrates - originally developed by Marie Savina
 \ingroup atEcology

 File:	atexternalpop.c
 Author:	Beth Fulton
 Created:	13/12/2016
 Purpose:	C file for processes dealing with an external vertebrate populaiton (rather than being in status when outside the model domain)
 Revisions:


 **/

/*  Open library routines */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sjwlib.h>
#include "atecology.h"

/*************************************************************************//**

 */

void External_Box_Ecology(MSEBoxModel *bm, int b, double dt, FILE *llogfp) {
    double linf, Kbert, tzero, li_a, li_b, pR_sp, age_mat, age, Length, lengthgrowth ;
    double nums, Growth, SN, RN, FRC_sp, mLext, mPext, mort, ageclasssize, X_RS, Density, Resp = 0, avail_intake;
    int species, cohort, pid, mid;
    
    // Work on the MIGRATION array and only when box zero executing
    if (!b) {
        if(bm->debug == debug_external){
            fprintf(bm->logFile, "External_Box_Ecology running for box %d\n", bm->current_box);
        }
    
        Parameter_Q10(bm, &bm->boxes[b], bm->dt, 1, 0, 0, bm->boxes[b].inside.y, WC, bm->logFile);
    
        // Per cohort
        for (species = 0; species < bm->K_num_tot_sp; species++) {
            if(FunctGroupArray[species].speciesParams[flag_id] == TRUE){
                if (FunctGroupArray[species].isVertebrate == TRUE) {
                    if (FunctGroupArray[species].isExternal == TRUE) {
                    
                        Density = 1.0;
                        linf = FunctGroupArray[species].speciesParams[linf_id];
                        Kbert = FunctGroupArray[species].speciesParams[Kbert_id];
                        tzero = FunctGroupArray[species].speciesParams[tzero_id];
                        li_a = FunctGroupArray[species].speciesParams[li_a_id];
                        li_b = FunctGroupArray[species].speciesParams[li_b_id];
                        pR_sp = FunctGroupArray[species].speciesParams[pR_id];
                        age_mat = FunctGroupArray[species].speciesParams[age_mat_id];
                    
                        for (cohort = 0; cohort < FunctGroupArray[species].numCohortsXnumGenes; cohort++) {
                            X_RS = FunctGroupArray[species].X_RS[cohort];
                            pid = FunctGroupArray[species].cohort_stage[cohort];
                            for (mid = 0; mid < MIGRATION[species].num_in_queue; mid++) {
                                if (((MIGRATION[species].StartDay[pid][mid] > MIGRATION[species].EndDay[pid][mid]) && (bm->TofY < MIGRATION[species].Return_Now[pid][mid])) || ((MIGRATION[species].StartDay[pid][mid] > MIGRATION[species].EndDay[pid][mid]) && (bm->TofY > MIGRATION[species].Leave_Now[pid][mid]))) {
                                    nums = MIGRATION[species].DEN[cohort][mid];
                        
                                    /* Only do if there are actually numbers in this box */
                                    if(nums > bm->min_dens){
                            
                                        if(bm->debug == debug_external){
                                            fprintf(bm->logFile, "\n\nGroup %s:%d in migration array\n",
                                                FunctGroupArray[species].groupCode, cohort);
                                        }
                            
                                        //		Growth calculation
                                        //      ------------------
                                        //			calculation of age
                                        ageclasssize = FunctGroupArray[species].ageClassSize;
                                        age = ageclasssize*(cohort-1) + ageclasssize/2;
                                        //			calculation of length
                                        Length = linf - (linf * exp(-Kbert * (age - tzero)));
                            
                                        //			daily growth in length (cm)
                                        lengthgrowth = Kbert * (linf - Length) / 365;
                                        //			daily growth in weight (mg N)
                                        Growth = li_a * pow(lengthgrowth,li_b) * 1000 / (k_wetdry * bm->X_CN)  ;

                                        //            calculation of the proportion of growth going into SN and RN
                                        SN = MIGRATION[species].SN[cohort][mid];
                                        RN = MIGRATION[species].RN[cohort][mid];

                                        // Include respiration in case of dynamic size structuring and respiration
                                        switch (flagresp) { //ASTAFIX - make sure all respirations cases are read, because now it just assumes boolean flag
                                            case no_resp:
                                                Resp = 0.0; /* Turning off respiration means the fish model is essentially/very similar to a Deriso-Schnute */
                                                break;
                                            case base_resp:
                                                Fish_Respiration(bm, species, SN, RN, X_RS, Density, &Resp);
                                                break;
                                            case deb_resp: // DEB model for respitaiton
                                                Fish_Respiration_DEB(bm, species, SN, RN, X_RS, Density, &Resp);
                                                break;
                                        }
                                        avail_intake = Growth - Resp;
                                        
                                        if(bm->debug == debug_external){
                                            fprintf(bm->logFile, "Kbert = %e, linf= %e, Length = %e, Kbert= %e, tzero= %e\n",
                                                    Kbert, linf, Length,Kbert, tzero);
                                            fprintf(bm->logFile, "li_a = %e, lengthgrowth= %e,li_b = %e\n", li_a,lengthgrowth,li_b);
                                        }
                                        
                                        if (bm-> flag_dynamicXRS) {  // Test needs to be here for consistency with old code
                                            Partition_Weight_Dynamic(bm, species, SN, RN, X_RS, &FRC_sp, avail_intake, llogfp);
                                        }
                                        else {
                                            Partition_Weight(bm, species, pR_sp, SN, RN, X_RS, &FRC_sp, llogfp);
                                        }
                            
                                        //			allocation to SN and RN
                                        MIGRATION[species].SN[cohort][mid] += (FRC_sp * Growth) * dt;
                                        MIGRATION[species].RN[cohort][mid] += (Growth - (FRC_sp * Growth)) * dt ;
                            
                                        if(bm->debug == debug_external){
                                            fprintf(bm->logFile, "Growth = %e, new sn = %e new rn = %e\n",
                                                    Growth, MIGRATION[species].SN[cohort][mid], MIGRATION[species].RN[cohort][mid]);
                                        }
                            
                            
                                        //		Mortality calculation
                                        //		---------------------
                                        if (cohort < age_mat) {
                                            mLext = FunctGroupArray[species].cohortSpeciesParams[juv_id][mLext_id];
                                            mPext = FunctGroupArray[species].cohortSpeciesParams[juv_id][mPext_id];
                                        } else {
                                            mLext = FunctGroupArray[species].cohortSpeciesParams[adult_id][mLext_id];
                                            mPext = FunctGroupArray[species].cohortSpeciesParams[adult_id][mPext_id];
                                        }
                                        mort = (mLext + mPext) * nums;
                            
                                        MIGRATION[species].DEN[cohort][mid] -= (mort * dt);
                            
                            
                                        if(bm->debug == debug_external){
                                            fprintf(bm->logFile, "New Density = %e, rt = %e, dt = %e\n",
                                                    MIGRATION[species].DEN[cohort][mid], mort, dt);
                                
                                            fprintf(bm->logFile, "mLext = %e, mPext= %e, nums= %e, mort = %e\n", mLext, mPext, nums, mort);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    return;
    
}
