/**
 \file
 \brief C file for running the movement routines.
 \ingroup atecology
 File:		atmovement.c
 Created:	21/9/2004
 Author:		Beth Fulton,   CSIRO Marine Laboratories,  2004
 Based on work by Ouyang and Fulton for Port Phillip Bay
 Purpose:	C file for running the movement routines 

 Revisions:  8/8/2004 Created msebiolmove.c from from the sebiolmove.c file

 23/8/2004 Parameter arrays generalised to simplify routines and
 remove switch statements for verebrate parameter definitions

 21/9/2004 Created atmovement.c from msebiolmove.c. And renamed
 FSL, FSO, FSF, FST and FSG to generic names so apply to
 other models/generic case.
 FSL -> FDC  (Ling -> Demersal_DC_Fish)
 FSO -> FDO  (Orange_Roughy -> Demersal_O_Fish)
 FSF -> FDB  (Flathead -> Demersal_B_Fish)
 FST -> FVO  (Bluefin_Tuna -> Pisciv_O_Fish)
 FSG -> SHB  (Gummy_Shark -> Shark_B)

 22/9/2004 Replaced numbers in switch statements with id
 guild numbers.

 26/9/2004 Added invertebrate geographic migration to Invert_Migration()

 15/10/2004 Added BML and BFF.

 19/10/2004 Added Prawns

 24/10/2004 Added soft sediments

 26/10/2004 Added FBP, FVB, SP, FDE, FDF, SHR, SSK, REP, WDG. Also
 added non-homogeneous sizes (so could have some differential
 effects of fishing pressure/closures on vertebrates at different
 locations

 5/11/2004 Removed KMIGa call from Total_Verts_And_Migration() and
 put into atbiolsetup

 7/12/2004 Added call to Check_Gape()

 29/3/2005 Added bm->DIN_id so can track "stock size" of DIN. Increased
 totbiom, totfishpop, totinitpop from bm->K_num_vert_sp + K_num_prey
 entries to bm->K_num_tot_sp to allow for the DIN entry.

 16/8/2005 Put in default case for all switch statements

 1/9/2005 Added multiple stock structure (horizontal and vertical)
 including ReturnStock entry for migration

 3/10/2005 Corrected multiple stock code (was getting artifical stock
 growth as normalisation incorrect) and added sp_amt so that don't
 process a group if less than one individual left in the model domain

 5/10/2005 Moved total abundance reporting code to Ecology_Calculate_Total_Abundance()
 in atbiology.c

 20/10/2005 Simplifed movement code to reduce number of loops (so
 easier to understand and more efficient to execute). Required
 some restructuring of initialisation points so initiliased before
 used at all. Needed to add checks to make sure stock structure
 has no artifical re-seeding

 17/8/2006 Fixed bug in localised recruitment case where was reinitialising
 recruit_hdistrib in each water layer not for each box.

 14/5/2008 Beth Fulton
 Fixed VERTfoodDead, VERTfoodAnimal and VERTfoodPlant - was only assigning
 last value as had a = not the necessary +=. Also fixed preyamt[DC_id]
 (was asigning to preyamt[n] instead).

 20/5/2008 Bec Gorton
 Fixed the VERTfoodAnimal set code. Adult values were not being set.

 26-05-2008 Bec Gorton
 Changed all references from bm->VERTind to the tracer arrays associated with
 each functional group.

 29-11-2008 Beth Fulton
 Added home-range based movement.

 2-12-2008 Beth Fulton
 Corrected storage of migrators in box0 (was updating at wrong point (i.e. every box
 instead of a final assignment after all boxes) and also needed to move the
 intialisation of avgsn etc accordingly


 20-01-2009 Bec Gorton
 Fixed the Ecology_Invert_Migration function. Changed all code in this function to
 use the K_num_tot_sp and then check the isVertebrate flag instead of using the
 K_num_vert_sp flag. Changed all code to use the Util_Get_Current_Stock_Index function.
 Change the code to use the number of cohorts stored with each functional group in the
 FunctGroupArray instead of the more generic K_num_cohorts. This will allow the user
 to vary the number of cohorts in the functional groups.
 Changed the code that calculates the preyamt array values in Total_Verts_And_Migration
 to loop over the functional groups instead of explicitly calculating the biomass of the
 invertebrate groups.
 Note: The water column groups are calculated first, then the sediment, then the epibenthic.
 We could change the code to loop over all groups and check the habitat_type but this results in
 a different result due to differences in the adding order. So will leave it as it is for now.

 11-05-2009 Bec Gorton
 Moved the num_migrate_id parameter from the cohort species parameters to the normal species
 parameters.

 10-06-2009 Bec Gorton
 Added the SEAGRASS invertebrate type.

 23-05-2009 Beth Fulton
 Trunk merge 1126 - Added tidal movement routines and checks

 15-12-2009 Bec Gorton
 Merged in trunk changes to get same movement outcomes.

 29-01-2010 Bec Gorton
 Updated the Calculate_Species_Clearance_Rate function to reflect a possible issue in the main code.
 Will need to check with Beth.
 Also updated code to use the renamed harvest functions.

 17-02-2010 Bec Gorton
 Removed the VERTfoodAnim, VERTfoodPlant and VERTfoodDead arrays as these can just be variables in Calculate_Species_Clearance_Rate.

 01-03-2010 Bec Gorton
 Added support for vertebrate larval dispersion in the movement code.
 larval_dispersal is now a valid localised recruitment option.

 5-04-2010 Beth Fulton
 Added expanded environmental forcing of movement and recruitment locations (envirodepend).

 10-12-2012 Beth Fulton
 Replaced migration arrays with MIGRATION data structure

 ************************************************************************************************/

/*  Open library routines */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "atecology.h"
#include <atHarvestLib.h>

static double Calculate_Migration_Proportion(MSEBoxModel *bm, FILE *llogfp, double dt, int sp, double start, double period, double IOBox){
	double migtime2, depreciaiton_scalar, step1, step2;
	double migtemp = dt/86400.0;
	double x, y;

	if(IOBox == 0)
		return 0;

     /* Calculate the proportion that are migrating away in this timestep */
     if(k_migslow == 1){
        if(period > migtemp ){
            if(bm->flag_replicated_old) {
                x = bm->dayt - start;
                y = period - x;

                migtime2 = ( migtemp * IOBox) / ( x * (1-IOBox) + y);
            } else {
                step1 = (bm->dayt - start);
                step2 = (IOBox * period) / (period * IOBox - IOBox * IOBox);
                depreciaiton_scalar = pow(step2, step1);
                migtime2 = depreciaiton_scalar * (IOBox / period) * migtemp;
            }
        } else {
            migtime2 = IOBox; // was 1.0 but need to allow for the fact not all might go
        }
     } else {
        migtime2 = IOBox; // was 1.0 but need to allow for the fact not all might go
     }

    if(migtime2 > 1.0) {
    	 migtime2 = 1.0;
    }

    if(migtime2 < 0.0) {
        migtime2 = 0.0;
    }

    if (sp == 35) {
        fprintf(llogfp,"Time: %e, %s migtime2: %e period: %e start: %e IOBox: %e: migtemp: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, migtime2, period, start, IOBox, migtemp);
    }
     return migtime2;
}

static double Calculate_Migration_Proportion_Back(MSEBoxModel *bm, FILE *llogfp, double dt, int sp, double back, double period){
	double migtemp = 86400.0/dt;
	double propStep = dt/86400.0;
	double migtime2;

	/* Calculate the proportion that are coming back in this timesetp */
	if(k_migslow == 1){
		if( period > propStep ){
            if(bm->flag_replicated_old) {
                migtime2 = 1.0 / (1.0 + (period - (bm->dayt - back) - 1/migtemp) * migtemp);
            } else {
                migtime2 = (((1.0 + (bm->dayt - back)) / period) / migtemp);
            }
		} else {
			migtime2 = 1.0;
		}
	}else{
		migtime2 = 1.0;
	}

    if(migtime2 > 1.0) {
        migtime2 = 1.0;
    }
    
    if(migtime2 < 0.0) {
        migtime2 = 0.0;
    }
     
     if (sp == 35) {
         fprintf(llogfp,"Time: %e, %s migtime2: %e period: %e back: %e migtemp: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, migtime2, period, back, migtemp);
     }


	return migtime2;
 }

/**
 * \brief Calculate the clearance rate of the given cohort of the species in the ijth box.
 *
 *
 */
static double Calculate_Species_Clearance_Rate(MSEBoxModel *bm, FILE *llogfp, int sp, int cohort, int ij, double ***preyamt) {

	double step1, clear, preyavail;
	int prey, chrtstage, preystage, k, predSNID, preymaxSNID, preyminSNID;
	int preychrtstage = 0;
	double invertPreyAmount, prey_fits, preyMaxSn, preyMinSn, predSn;
	double E1_sp = FunctGroupArray[sp].speciesParams[E1_id];
	double E2_sp = FunctGroupArray[sp].speciesParams[E2_id];
	double E3_sp = FunctGroupArray[sp].speciesParams[E3_id];
	double KDEP_sp = FunctGroupArray[sp].speciesParams[KDEP_id];
	double C_SP = 0;
	double mum_SP = 0;
	double VERTfoodAnim = 0.0;
	double VERTfoodPlant = 0.0;
	double VERTfoodDead = 0.0;
	double preyFlag;

	C_SP = FunctGroupArray[sp].SP_C_per_day[cohort];
	mum_SP = FunctGroupArray[sp].mum_per_day[cohort];

	if ((bm->debug == debug_biology_process) && (bm->dayt >= bm->checkstart) && (bm->dayt < bm->checkstop)) {
		fprintf(llogfp, "Calculate_Species_Clearance_Rate input parameters sp = %s, cohort = %d, E1_sp = %e, E2_sp = %e, E3_sp = %e, KDEP_sp = %e\n",
			FunctGroupArray[sp].groupCode, cohort, E1_sp, E2_sp, E3_sp, KDEP_sp);

		fprintf(llogfp, "SP_C = %.20e\n", C_SP);
		fprintf(llogfp, "mum= %.20e\n", mum_SP);
	}

	/* Get details of feeding preferences */
	chrtstage = FunctGroupArray[sp].cohort_stage[cohort];

	for (prey = 0; prey < bm->K_num_tot_sp; prey++) {

		invertPreyAmount = 0;
		preyFlag = FunctGroupArray[prey].speciesParams[flag_id];
		if (FunctGroupArray[prey].speciesParams[flag_id] == TRUE) {
			for(preystage = 0; preystage < FunctGroupArray[prey].numStages; preystage++){
				if(bm->flag_olddiet) {
					//preyavail = FunctGroupArray[sp].pSPEat[chrtstage][prey][WC];  // Technically more correct
					preyavail = FunctGroupArray[sp].pSPEat[juv_id][prey][WC];  // What was in the old code - due to remapping that happens in Ecology_Init()
				} else
					preyavail = bm->pSPVERTeat[sp][prey][chrtstage][preystage];
				switch (FunctGroupArray[prey].groupAgeType) {
				case AGE_STRUCTURED:
					prey_fits = 0.0;
					if(bm->flag_olddiet)
						prey_fits = 1.0;  // In old code didn't perform a test specific to this predator, just if matched any predator's feeding window
					else {
						/* Should really test per predator and prey sizes otherwise end up taking fish to where no actual prey they can eat size wise
						 * (as preyamt is just non zero if any predator can access it)
						 * TODO: Should also really test per size of prey rather than just min-max per stage as may have very uneven biomass contributions
						 * so could still be leading the predators astray vs true ideal free distribution */
						preyminSNID = FunctGroupArray[prey].spMinMax[(preystage * 2)];
						preymaxSNID = FunctGroupArray[prey].spMinMax[(preystage * 2 + 1)];
						predSNID = FunctGroupArray[sp].structNTracers[cohort];

						for (k = 0; k < bm->boxes[ij].nz; k++) {
							predSn = bm->boxes[ij].tr[k][predSNID];
							preyMinSn = bm->boxes[ij].tr[k][preyminSNID];
							preyMaxSn = bm->boxes[ij].tr[k][preymaxSNID];

                            // TODO: - if length-based bilogistic feeding window is used and KLP and KUP parameters are based on length
                            // then this option will calculate fit incorrectly.
                            
							if ((preyMaxSn < FunctGroupArray[sp].speciesParams[KLP_id] * predSn) ||         // All smaller than the window
									(preyMinSn > FunctGroupArray[sp].speciesParams[KUP_id] * predSn)) {    // All larger than the window
								// do nothing as failed to coincide
							} else {
								prey_fits = 1.0;  // Bingo, found a match and can stop looking
								break;
							}
							
						}
					}

					step1 = min(1.0, bm->pSPVERTeat[sp][prey][chrtstage][preystage] / (bm->refuge_status[prey][ij][preystage] + small_num));
					VERTfoodAnim += step1 * preyamt[prey][ij][preystage] * prey_fits;

					/**/
					if (VERTfoodAnim < 0) {
						fprintf(llogfp, "Time %e %s-%d on %s-%d in box %d VERTfoodAnim: %e, prey_fits: %e, preyamt: %e, step1: %e pSPVERTeat: %e, refuge_status: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, cohort,
								FunctGroupArray[prey].groupCode, preystage, ij, VERTfoodAnim, prey_fits,
								preyamt[prey][ij][preystage], step1, bm->pSPVERTeat[sp][prey][chrtstage][preystage], bm->refuge_status[prey][ij][preystage]);
					}
					break;

				case AGE_STRUCTURED_BIOMASS:
					invertPreyAmount = preyavail * preyamt[prey][ij][preychrtstage];
					VERTfoodAnim += (preyFlag * preyavail * preyamt[prey][ij][preychrtstage]);

                    /**/
                    if (VERTfoodAnim < 0) {
						fprintf(llogfp, "Time %e %s-%d on %s-%d in box %d VERTfoodAnim: %e, preyavail: %e, preyamt: %e, preyFlag: %e\n",
								bm->dayt, FunctGroupArray[sp].groupCode, cohort,
								FunctGroupArray[prey].groupCode, preystage, ij, VERTfoodAnim, preyavail,
								preyamt[prey][ij][preychrtstage], preyFlag);
					}
					/**/

					break;
				case BIOMASS:
					invertPreyAmount = preyavail * preyamt[prey][ij][preychrtstage];
					if (FunctGroupArray[prey].habitatCoeffs[EPIFAUNA]  > 0) {
						invertPreyAmount = invertPreyAmount / (KDEP_sp + small_num);
					}

					switch (FunctGroupArray[prey].groupType) {
						case LG_PHY:
						case SM_PHY:
						case DINOFLAG:
						case PHYTOBEN:
						case SEAGRASS:
						case MICROPHTYBENTHOS:
						case ICE_DIATOMS:
						case ICE_MIXOTROPHS:
						case TURF:
							VERTfoodPlant += (preyFlag * invertPreyAmount);
							break;
						case LAB_DET:
							VERTfoodDead += (1.0 * invertPreyAmount);
							break;
						case CARRION:
							VERTfoodAnim += (1.0 * invertPreyAmount);
							break;
							/* original code does not include this! */
						case REF_DET:
							//VERTfoodDead += invertPreyAmount;
							break;
						default: /* All the rest */
							VERTfoodAnim += invertPreyAmount;
							break;
					}
                        
                    /**/
                    if ((VERTfoodAnim < 0) || (VERTfoodDead < 0) || (VERTfoodPlant < 0)){
                         fprintf(llogfp, "Time %e %s-%d on %s-%d in box %d invertPreyAmount: %e, KDEP_sp: %e, preyavail: %e, preyamt: %e habCoeffs: %d\n",
                         bm->dayt, FunctGroupArray[sp].groupCode, cohort,
                         FunctGroupArray[prey].groupCode, preychrtstage, ij, invertPreyAmount, KDEP_sp,
                         preyavail, preyamt[prey][ij][preychrtstage], FunctGroupArray[prey].habitatCoeffs[EPIFAUNA]);
                     }
                    /**/
    
                        
                        
					break;
				}
			}
		}
	}
	/* Feeding rates resulting from this level of food supply */
	clear = (VERTfoodAnim + VERTfoodPlant + VERTfoodDead) * C_SP
			/ (1.0 + (VERTfoodAnim * E1_sp + VERTfoodPlant * E2_sp + VERTfoodDead * E3_sp) * C_SP / mum_SP);

	//if ((clear < 0) || ((bm->debug == debug_biology_process) && (bm->dayt >= bm->checkstart) && (bm->dayt < bm->checkstop))) {
    if (clear < 0) {
		fprintf(llogfp,
				"Calculate_Species_Clearance_Rate sp = %s, cohort = %d, box = %d, VERTfoodAnim[ij][cohort] = %.20e, VERTfoodPlant[ij][cohort] = %.20e, VERTfoodDead[ij][cohort] = %.20e, clear = %.20e, E1_sp = %e, mum_SP: %.20e, C_sp: %.20e\n",
				FunctGroupArray[sp].groupCode, cohort, ij, VERTfoodAnim, VERTfoodPlant, VERTfoodDead, clear, E1_sp, mum_SP, C_SP);
	}

	return clear;
}

/**
 *  \brief This routine is the old way we found the preyamt for vertebrate prey
 */
static void Get_Vert_Diet(MSEBoxModel *bm, double ***preyamt, int ij, int k, int prey){
	int rij, rangeid, n, sn, rn, den, pred, predstage, preystage, spmin, spmax;
	double preyavail;
	double upper, lower;
	double *boxLayerTracers;
	int habitat;
	int stock_id = bm->group_stock[prey][ij][k];

	boxLayerTracers = bm->boxes[ij].tr[k];
	habitat = WC;

	/* Identify the stock under consideration */
	

	/* For each cohort */
	for (n = 0; n < FunctGroupArray[prey].numCohortsXnumGenes; n++) {

		preystage = FunctGroupArray[prey].cohort_stage[n];
		counted[prey][n] = 0;
		/* Vertebrate numbers */
		sn = FunctGroupArray[prey].structNTracers[n];
		rn = FunctGroupArray[prey].resNTracers[n];
		den = FunctGroupArray[prey].NumsTracers[n];

		totden[prey][n] += boxLayerTracers[den];
        
        /*
        if (prey == 41) {
            fprintf(bm->logFile,"Time: %e, %s-%d box%d-%d den: %e so totden: %e\n", bm->dayt, FunctGroupArray[prey].groupCode, n, ij, k,  boxLayerTracers[den], totden[prey][n]);
        }
         */
        
		/* Update home range information for those species using home ranges
		 Find proportion of population in home range x
		 As this is a 2D distribution then only do once for each box
		 (DO NOT do it for every layer)
		 */
		if (((int) (FunctGroupArray[prey].speciesParams[ddepend_move_id]) == homerange_move) && (k == 0)) {
			for (rij = 0; rij < bm->boxes[ij].HomeRangeInfo[prey].n; rij++) {
				rangeid = bm->boxes[ij].HomeRangeInfo[prey].ids[rij];
				bm->HomeRangeTotal[prey][n][rangeid] += bm->boxes[ij].HomeRangeInfo[prey].rangenum[n][rij];
			}
		}

		/* Split across stocks */
		init_stock_struct_prop[prey][n][stock_id] += boxLayerTracers[den];

		/* Determine size of vertebrates - divide by totden below to get final values (averages) */
		if (bm->boxes[ij].tr[k][den] > 0.0) {
			VERTinfo[prey][n][SN_id] += boxLayerTracers[sn] * boxLayerTracers[den];
			VERTinfo[prey][n][RN_id] += boxLayerTracers[rn] * boxLayerTracers[den];
			VERTinfo[prey][n][DEN_id] +=  boxLayerTracers[den];
		}

		/** Prey and refuges available **/
		/* Vertebrate prey */
		for (pred = 0; pred < bm->K_num_tot_sp; pred++) {
			if (FunctGroupArray[pred].speciesParams[flag_id] == TRUE) {
				if(!counted[prey][n]){
					for(predstage = 0; predstage < FunctGroupArray[pred].numStages; predstage++){
						if(bm->flag_olddiet){
							preyavail = FunctGroupArray[pred].pSPEat[juv_id][prey][habitat];  // As only tested for the juvenile case originally - dumb decision!
						} else
							preyavail = bm->pSPVERTeat[pred][prey][predstage][preystage];

						if (preyavail) {  // So if any predator can get the prey in the mouth store the value

							if (FunctGroupArray[pred].groupAgeType == AGE_STRUCTURED) {
								spmin = FunctGroupArray[pred].spMinMax[(predstage * 2)];
								spmax = FunctGroupArray[pred].spMinMax[(predstage * 2 + 1)];
								upper = FunctGroupArray[pred].speciesParams[KUP_id] * boxLayerTracers[spmax];
								lower = FunctGroupArray[pred].speciesParams[KLP_id] * boxLayerTracers[spmin];
							} else {
								upper = FunctGroupArray[pred].speciesParams[KUP_id] * FunctGroupArray[pred].sn[predstage];
								lower = FunctGroupArray[pred].speciesParams[KLP_id] * FunctGroupArray[pred].sn[predstage];
							}
							if ((bm->boxes[ij].tr[k][sn] >= lower) && (boxLayerTracers[sn] <= upper)) {
								preyamt[prey][ij][preystage] += (boxLayerTracers[sn] + boxLayerTracers[rn]) * boxLayerTracers[den];
								counted[prey][n] = 1;
							}

							/**
							if(bm->dayt > bm->checkstart){
								fprintf(bm->logFile, "pred: %s ij: %d prey %s-%d counted: %d stage: %d sn = %.20e rn = %.20e den = %.20e preyamt[juv_id] = %.20e preyamt[adult_id] = %.20e\n",
										FunctGroupArray[pred].groupCode, ij, FunctGroupArray[prey].groupCode, n, counted[prey][n], predstage, bm->boxes[ij].tr[k][sn], bm->boxes[ij].tr[k][rn],
										bm->boxes[ij].tr[k][den], preyamt[prey][ij][juv_id], preyamt[prey][ij][adult_id]);
							}
							**/

						}
					}
				}
			}
		}
	}

	return;
}

/**
 * \brief Calculate the prey values. Determine tot numbers per cohort per species and total
 amount of each prey in each box.
 *
 *
 */
static void Calculate_Prey_Values(MSEBoxModel *bm, double ***preyamt, FILE *llogfp) {
	int ij, k, sp, n, pid;
    int rugosity_check_done = 0;
	int preychrtstage = 0;
	double cdepth;

	/* Determine tot numbers per cohort per species and total
	 amount of each prey in each box */

	for (ij = 0; ij < bm->nbox; ij++) {

		/* Determine initial biomasses */
		if (bm->boxes[ij].type == LAND) {
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {

				/* Skip over groups not in the model */
				if (!(int) (FunctGroupArray[sp].speciesParams[flag_id]))
					continue;

				if (FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){

					switch (FunctGroupArray[sp].groupAgeType) {
					case AGE_STRUCTURED:
						Get_Vert_Diet(bm, preyamt, ij, 0, sp);
						break;
					case AGE_STRUCTURED_BIOMASS:	/* Intentional follow through */
					case BIOMASS:
						/* ignore - will not get here */
						quit("Calculate_Prey_Values - no support for land based inverts.\n");
						break;
					}
				}
			}
		}
		else if (bm->boxes[ij].type != BOUNDARY) {

			for (k = 0; k < bm->REEFcover_id; k++)
				bm->coveramt[k][ij] = 0.0;

			cdepth = bm->boxes[ij].botz;
			for (k = 0; k < bm->boxes[ij].nz; k++) {

				/* Initialise whether species counted in this depth band */
				//Util_Init_2D_Int(counted, bm->K_num_tot_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, 0.0);

				for (sp = 0; sp < bm->K_num_tot_sp; sp++) {

					/* Skip over groups not in the model */
					if (!(int) (FunctGroupArray[sp].speciesParams[flag_id]))
						continue;

					if (FunctGroupArray[sp].habitatType == WC){

						switch (FunctGroupArray[sp].groupAgeType) {
						case AGE_STRUCTURED:
							Get_Vert_Diet(bm, preyamt, ij, k, sp);
							break;
						case AGE_STRUCTURED_BIOMASS:	/* Intentional follow through */
						case BIOMASS:
							preychrtstage = 0;
							for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
								preyamt[sp][ij][preychrtstage] += bm->boxes[ij].tr[k][FunctGroupArray[sp].totNTracers[n]];
							}
							break;
						}
					}
				}

			}

			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].speciesParams[flag_id] == TRUE){
					if (FunctGroupArray[sp].habitatType == SED || FunctGroupArray[sp].groupType == CARRION) {
						if(FunctGroupArray[sp].groupAgeType == BIOMASS){
							for (k = 0; k < bm->boxes[ij].sm.nz; k++) {
								preyamt[sp][ij][0] += bm->boxes[ij].sm.tr[k][FunctGroupArray[sp].totNTracers[0]];
							}
						}
					}
				}
			}

			/* Epibenthos and benthic biogenic habitat coverage - use epi call here
			 for epibenthos values instead of tracer value array as easier to
			 access and no difference in value as yet (no invertebrate movement yet)
			 */

			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].speciesParams[flag_id] == TRUE){
					if (FunctGroupArray[sp].habitatType == EPIFAUNA) {
						switch (FunctGroupArray[sp].groupAgeType) {
						case AGE_STRUCTURED:
							/* Do nothing */
							break;
						case AGE_STRUCTURED_BIOMASS: /* Intentional follow through */
						case BIOMASS:
							for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
								preyamt[sp][ij][0] += bm->boxes[ij].epi[FunctGroupArray[sp].totNTracers[n]];
							}
							break;
						}
					}
				}
			}
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if (FunctGroupArray[sp].speciesParams[flag_id] == TRUE){
					if (FunctGroupArray[sp].isCover == TRUE) {
						pid = FunctGroupArray[sp].CoverTracer;
						n = FunctGroupArray[sp].coverID;
						bm->coveramt[n][ij] += bm->boxes[ij].epi[pid];
					}
				}
			}

			/** Assess the environment (to account for habitat depdendency due to
			 refuges not just diet requirements **/
            rugosity_check_done = 0;
			for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
				if(FunctGroupArray[sp].speciesParams[flag_id]){
					if (FunctGroupArray[sp].isVertebrate == TRUE) {

						/* Skip over groups not in the model */
						if (! (int) (FunctGroupArray[sp].speciesParams[flag_id]))
							continue;

                        Vertebrate_Assess_Enviro(bm, sp, ij, bm->coveramt, cdepth, rugosity_check_done, llogfp);
                        rugosity_check_done = 1;
					}
				}
			}
		}
	}
    
    return;
}

/**
 *    \brief This routine calculates any effects of turbidity on predation
 *
 */
void Calculate_Turbid_Effects(MSEBoxModel *bm, FILE *llogfp) {
    double L_sp, a_sp, b_sp, step1;
    int sp, stage, b, k;
    
    if (verbose > 0)
        printf("Calculate_Turbid_Effects\n");
    
    if(!bm->flagIsEstuary)
        return;
    
    // Find the scalars per predator
    for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        for (stage = 0; stage < FunctGroupArray[sp].numStages; stage++) {
            L_sp = FunctGroupArray[sp].cohortSpeciesParams[stage][L_turbid_id];
            b_sp = FunctGroupArray[sp].cohortSpeciesParams[stage][b_turbid_id];
            a_sp = FunctGroupArray[sp].cohortSpeciesParams[stage][a_turbid_id];
            /* Get details of feeding preferences */
            for (b = 0; b < bm->nbox; b++) {
                if (bm->boxes[b].type != BOUNDARY) {
                    for (k = 0; k < bm->boxes[b].nz; k++) {
                        step1 = 1.0 - L_sp / (1.0 + exp(-1.0 * a_sp * (bm->boxes[b].tr[k][SED_i] - b_sp)));
                        bm->turbid_effect[sp][b][k][stage] = (1.0 / step1);
                    }
                }
            }
        }
    }
    
    return;
}

/*
 * Routine for calculating how movement effected by environmental conditions
 */

double Get_Enviro_Move_Scalar(int flag_sensitive_sp, double current_enviro, double K_const_sp, double min_sp, double max_sp, int sp, int prop_ID, double dayt, FILE *llogfp) {
    double step1, step2, step3, step4;
    double numScalar = 1.0;
    
    step1 = K_const_sp * exp(current_enviro - min_sp) / (K_const_sp + (exp(current_enviro - min_sp) - 1.0));
    step2 = K_const_sp * exp(max_sp - current_enviro) / (K_const_sp + (exp(max_sp - current_enviro) - 1.0));
    switch (flag_sensitive_sp) {
        case not_sensitive:  // Nothing to do
            break;
        case sensitive_heaviside_window:
            if ((current_enviro < min_sp) || (current_enviro > max_sp)) {
                numScalar = 0.0;
            }
            break;
        case sensitive_biologistic_window: // Gaussian shape
            numScalar = 1.0;
            step3 = step1 / K_const_sp;
            step4 = step2 / K_const_sp;
            if (step3 > step4) {
                numScalar = step4;
            } else {
                numScalar = step3;
            }
            
            if(numScalar > 1.0)
                numScalar = 1.0;
            if(numScalar < 0.0)
                numScalar = 0.0;
            break;
        case sensitive_gradual_side: // Flat-top version
            numScalar = 1.0;
            if (current_enviro < min_sp) {
                numScalar = step1;
            } else if ( current_enviro > max_sp ) {
                numScalar = step2;
            }
            if(numScalar > 1.0)
                numScalar = 1.0;
            if(numScalar < 0.0)
                numScalar = 0.0;
            break;
        default:
            break;
            
    }
    
    /*
    if(numScalar < 1.0) {
        fprintf(llogfp, "Time: %e %s is environmentally constrained property %d is outside their tolerance levels\n", dayt, FunctGroupArray[sp].groupCode, prop_ID);
    }
    */
    return numScalar;
}


/**
 *	\brief This routine calculates any movements by vertebrates
 *	(horizontal or vertical)
 */
void Ecology_Total_Verts_And_Migration(MSEBoxModel *bm, double dt, FILE *llogfp) {
	int ij, k, n, qrt, next_qrt, sp, flagmother, flagsp, /*spjmin, spjmax, spamin = 0, spamax,*/
    age_mat, sp_ddepend_move, day_part, sn, rn, den, mig_done, spmigrate, spmigrate_done, bearlive, stage, flagimposecatch, stock_id = -1, spupdatemig, do_debug, recalc_needed, decdis, sp_feed_while_spawn, sp_spawn_now, flagchannel, desired_chrt, nf, flagcontract_sp, qid, lid, ngene, spawn_period, spawn_date, bcohort, temp_sensitive_sp, salt_sensitive_sp, update_larval_distrib, updated_already, test_day, cells_checked, cells_impacted;
	double ldayt = bm->t / 86400.0;
	//double migtemp = 86400.0 / dt;
	int maxij = bm->K_num_stocks_per_sp;
	int overall_checkday = (int) (floor(bm->dayt));

	double clear, E1_sp, spSpeed, this_HowFar, vertdistrib, mignum, mignum_actual, spawnmove = 1.0, totmig, midpoint, FSMG_grow, migtime, oldden, totdenom = 0, min_temp_sp, max_temp_sp, maxstock, min_spawntemp_sp, max_spawntemp_sp, temp_effect, finalmig, avgsn, avgrn, dynsn, dynrn, min_salt_sp, max_salt_sp, min_O2_sp, current_enviro, min_spawnsalt_sp, max_spawnsalt_sp, salt_effect, o2_effect, contract_sp, oldsn, oldrn, this_tot_biom, pH_scale, orig_newden, check_day, stagger_scalar, noise_effect, light_effect, K_salt_const_sp, K_o2_const_sp, numScalar_final, growth_period;
    double numScalar, K_temp_const_sp = 0.0;
    // double step1, step2;  OLD WAY OF DOING AGE - DEPRECATE
    double ReturnPeriod;
	int enviro_depend = 0, sp_enviro_depend = 0;
	int **counted;
    int rij, rangeid, rocstage = -1, thiscase1, thiscase2, adstage, sp_Migrate_Years, stagger_return, agec;
    double nbox_spread, stepSN, stepRN, yoy_den, KWSR_sp, KWRR_sp;
	int adbox, chkbox;
	double prop_range;
	int prij, rrid;
	double ***preyamt;
	double **boxden;
	double ****currentden;
	double **leftden;
	double sp_amt;
	double *totboxden;
	double *totroc;
	double migProp;
	double migtime2;
	double *totad;
	double *newden_sum;
	double some_ice = 0.0, ice_effect;
    int do_debug2;
    int *mig_returners = Util_Alloc_Init_1D_Int(bm->K_num_tot_sp, 0);
    
	updated_already = 0;

	if (bm->debug && (((bm->debug > debug_eat) || ((bm->debug > debug_spawn) && (bm->debug < debug_biom))) && (bm->dayt >= bm->checkstart)))
		do_debug = 1;
	else
		do_debug = 0;

	if (bm->flagtempdepend || bm->flagsaltdepend || bm->flagO2depend)
		enviro_depend = 1;

	mig_done = 0;

	if (verbose)
		printf("Dealing with migration\n");

	/* Determine current date and metabolic parameter values.
	 Bases everything on the latitude of box 0, so don't have to worry
	 about accidently calling a box that isn't in the geometry being used. */
	midpoint = bm->boxes[1].inside.y;

	Parameter_Q10(bm, &bm->boxes[1], ldayt, 1, 0, bm->boxes[1].nz - 1, midpoint, WC, llogfp);

	day_part = bm->flagday; // 1 = day time, 0 = night time

	/* Initialise local arrays */
	newden_sum = Util_Alloc_Init_1D_Double(bm->K_num_max_cohort * bm->K_num_max_genetypes, 0.0);
	counted = Util_Alloc_Init_2D_Int(bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0);
	totad = Util_Alloc_Init_1D_Double(bm->K_num_max_cohort * bm->K_num_max_genetypes, 0.0);
	totboxden = Util_Alloc_Init_1D_Double(bm->K_num_max_cohort * bm->K_num_max_genetypes, 0.0);
	Util_Init_2D_Double(bm->targetspbiom, bm->K_num_tot_sp, bm->nbox, 0.0);
	Util_Init_2D_Double(totden, bm->K_num_tot_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, 0.0);
	currentden = Util_Alloc_Init_4D_Double(bm->nbox, bm->wcnz, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
	Util_Init_4D_Double(newden, bm->K_num_tot_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->wcnz, bm->nbox, 0.0);
	Util_Init_3D_Double(VERTinfo, bm->K_num_tot_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, 3, 0.0);
	Util_Init_3D_Double(init_stock_struct_prop, bm->K_num_tot_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_stocks_per_sp, 0.0);
	Util_Init_3D_Double(bm->stock_struct_prop, bm->K_num_tot_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_stocks_per_sp, 0.0);
    Util_Init_3D_Double(bm->HomeRangeTotal, bm->K_num_tot_sp, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_homerange, 0.0);
	preyamt = Util_Alloc_Init_3D_Double(2, bm->nbox, bm->K_num_tot_sp, 0.0);
	boxden = Util_Alloc_Init_2D_Double(bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->nbox, 0.0);
	leftden = Util_Alloc_Init_2D_Double(bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
	totroc = Util_Alloc_Init_1D_Double(bm->K_num_max_cohort * bm->K_num_max_genetypes, 0.0);

	/* Determine tot numbers per cohort per species and total
	 amount of each prey in each box of the bay. Will update the totden array. */
	Calculate_Prey_Values(bm, preyamt, llogfp);

    /* Determine any turbidity effects - to apply to predation */
    Calculate_Turbid_Effects(bm, llogfp);
    
    /* Check for desired cohorts for each fishery */
	if (bm->flag_fisheries_on) {
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if (FunctGroupArray[sp].isVertebrate == TRUE) {
				for (nf = 0; nf < bm->K_num_fisheries; nf++) {
					bm->SP_FISHERYprms[sp][nf][larger_extant_id] = 0.0;
					desired_chrt = (int) (bm->SP_FISHERYprms[sp][nf][desired_chrt_id]);
					for (n = desired_chrt; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
						if (totden[sp][n] > bm->min_dens) {
							bm->SP_FISHERYprms[sp][nf][larger_extant_id] = 1.0;
						}
					}
				}
			}
		}
	}
	if (do_debug && (bm->move_check < no_move_check) && (bm->move_check < bm->K_num_tot_sp)) {
		for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
			if (FunctGroupArray[sp].isVertebrate == TRUE) {
				if (sp == bm->move_check) {
					if(bm->which_check == sp){
                        fprintf(llogfp, "guild: %s, time: %e, ", FunctGroupArray[sp].groupCode, bm->dayt);
                        for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
                            fprintf(llogfp, "stotden[%s][%d]: %e, ", FunctGroupArray[sp].groupCode, n, totden[sp][n]);
                        }
                        fprintf(llogfp, "\n");
                    }
				}
			}
		}
	}

	/**
    if ((bm->which_check <= bm->K_num_tot_sp)){
    	if (FunctGroupArray[bm->which_check].isVertebrate == TRUE) {
			for (ij = 0; ij < bm->nbox; ij++) {
				if (bm->boxes[ij].type != BOUNDARY) {
					for (k = 0; k < bm->boxes[ij].nz; k++) {
						for (n = 0; n < FunctGroupArray[bm->which_check].numCohortsXnumGenes; n++) {
							den = FunctGroupArray[bm->which_check].NumsTracers[n];

                            fprintf(llogfp, "START Time: %e, %s-%d box%d-%d den: %e (vs totden: %e)\n", bm->dayt, FunctGroupArray[bm->which_check].groupCode, n, ij, k, bm->boxes[ij].tr[k][den], totden[bm->which_check][n]);
						}
					}
				}
			}
    	}
	}
	**/

	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        
        //fprintf(llogfp,"%s move0 starts with next_larvae set to %d\n", FunctGroupArray[sp].groupCode, EMBRYO[sp].next_larvae);
        //printf("%s move0 starts with next_larvae set to %d\n", FunctGroupArray[sp].groupCode, EMBRYO[sp].next_larvae);

        
        //if (verbose > 0)
        //    printf("Doing movement for %s\n", FunctGroupArray[sp].groupCode);
        
		if (FunctGroupArray[sp].isVertebrate == TRUE) {
			flagimposecatch = (int) (FunctGroupArray[sp].speciesParams[flagimpose_id]);
			flagsp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);

            do_debug2 = 0;
            /**
            if (bm->debug && (((bm->debug == debug_migrate) || (bm->debug == debug_age)) && (((sp == bm->which_check) && (bm->dayt > bm->checkstart)) || (bm->which_check > bm->K_num_tot_sp)))) {
				do_debug2 = 1;
			}
            
            if (bm->which_check == sp)
                do_debug2 = 1;
             **/

			 this_tot_biom = 0.0;

			 for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				 newden_sum[n] = 0.0;
				 FunctGroupArray[sp].allgone[n] = 1;  // Initialise for the new timestep
			 }

			/* Skip over groups not in the model */
			if (!flagsp)
				continue;
            
            /* Finish finding new structural and reserve weights for each fish group - weight each box's
			 relative contribution by the relative amount of the population in that box */
			recalc_needed = 0;
			decdis = 0;
			for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				if (totden[sp][n] > bm->min_dens) {
					VERTinfo[sp][n][SN_id] /= totden[sp][n];
					VERTinfo[sp][n][RN_id] /= totden[sp][n];
				} else {
					VERTinfo[sp][n][SN_id] = bm->min_pool;
					VERTinfo[sp][n][RN_id] = bm->min_pool;
				}
                
                /* Sanity check */
                if (VERTinfo[sp][n][SN_id] < 0)
                    VERTinfo[sp][n][SN_id] = bm->min_pool;
                if (VERTinfo[sp][n][RN_id] < 0)
                    VERTinfo[sp][n][RN_id] = bm->min_pool;
                
				dynsn = VERTinfo[sp][n][SN_id];
				dynrn = VERTinfo[sp][n][RN_id];

				if (flagimposecatch || bm->flaghighgrading) {
					/* Check if catch distribution recalculation needed */
					mignum = 0;
					for (qid = MIGRATION[sp].num_in_queue_done; qid < MIGRATION[sp].num_in_queue; qid++) {
						mignum += MIGRATION[sp].DEN[n][qid] * (MIGRATION[sp].SN[n][qid] + MIGRATION[sp].RN[n][qid]);
					}

					if ((totden[sp][n] + mignum) < (bm->min_dens * bm->nbox * 2)) {
						/* Fallen to negligible levels so recalc */
						if (!bm->pSPcheck[sp][n]) {
							recalc_needed = 1;
							decdis = 1;
						}
					} else {
						/* Risen again so reset */
						if (bm->pSPcheck[sp][n]) {
							recalc_needed = 1;
							decdis = 0;
						}
					}
				}

				/* Sort out home range proportions */
				for (rij = 0; rij < bm->K_num_homerange; rij++) {
					bm->HomeRangeTotal[sp][n][rij] /= (totden[sp][n] + small_num);
				}
			}

            /* Recalculate time series catch distributions if necessary */
			if (recalc_needed) {
				Harvest_Recalc_Time_Series_Distrib(bm, totden, sp, decdis, llogfp);
			}

			/* Update information to take into account returning migrants (if any) */
			age_mat = (int) (FunctGroupArray[sp].speciesParams[age_mat_id]);
			spmigrate = MIGRATION[sp].num_in_queue;
            spmigrate_done = MIGRATION[sp].num_in_queue_done;

			/* Loop over each of the migrations for this group */
            for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
                stage = FunctGroupArray[sp].cohort_stage[n];
                
                if (!MIGRATION[sp].ActualMigrator[stage])
                    continue;
                
                for (qid = spmigrate_done; qid < spmigrate; qid++) {
                    stock_id = (int) (MIGRATION[sp].returnstock[qid]) - 1;
                    ReturnPeriod = (double)(MIGRATION[sp].Return_Period[qid]);

					/**
                    //if(do_debug2){
                    //if (sp == 33) || ((sp > 8) && (sp < 12))) {
                    if (sp == 35) {
                        fprintf(llogfp, "Time: %e, Species %s-%d qid: %d Return_Period = %d, Return_Now: %d (num_in_queue: %d, num_in_queue_done: %d) FinalMigBack: %d DEN: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, qid, MIGRATION[sp].Return_Period[qid], MIGRATION[sp].Return_Now[qid], MIGRATION[sp].num_in_queue, MIGRATION[sp].num_in_queue_done, MIGRATION[sp].Return_Now[qid] + MIGRATION[sp].Return_Period[qid], MIGRATION[sp].DEN[n][qid]);
					}
                    **/
                    
                    // Update for stagger - so more return in the next year if any stagger left
                    if (bm->dayt == (MIGRATION[sp].Return_Now[qid] + ReturnPeriod + 1.0)) {
                        if (MIGRATION[sp].num_stagger[qid] > 0) {
                            MIGRATION[sp].Return_Now[qid] += 365;
                            MIGRATION[sp].num_stagger[qid] -= 1;
                        }
                    }
                    
                    if (((MIGRATION[sp].Return_Period[qid] > 0) && (bm->dayt < MIGRATION[sp].Return_Now[qid])) && (FunctGroupArray[sp].isComplexMigrator == FALSE))
                        break;
                    
					/* Migrating species returning to the model */
					if ((spmigrate && (MIGRATION[sp].Return_Period[qid] > 0)) && (bm->dayt >= MIGRATION[sp].Return_Now[qid]) && (bm->dayt < (MIGRATION[sp].Return_Now[qid] + MIGRATION[sp].Return_Period[qid])) && (bm->t / 86400.0 > 0.0) && (MIGRATION[sp].DEN[n][qid] > 0)) {  // Only bother doing it if any individuals to return
                        
                        /**
                        //if(do_debug2){
                        //if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                        if (sp == 35) {
                             fprintf(llogfp,"Time: %e, %s-%d mig-%d, MigBack: %d, MigPeriod: %d, FinalMigBack: %d original migDEN: %e\n",
									bm->dayt, FunctGroupArray[sp].groupCode, stage, qid,
									MIGRATION[sp].Return_Now[qid], MIGRATION[sp].Return_Period[qid],
									MIGRATION[sp].Return_Now[qid]+MIGRATION[sp].Return_Period[qid], MIGRATION[sp].DEN[n][qid]);
						}
                        **/

                        /* Update numbers for returning migrants and then update overall size,
						 based on contributions from returning migrants */
						migtime2 = Calculate_Migration_Proportion_Back(bm, llogfp, dt, sp, MIGRATION[sp].Return_Now[qid], MIGRATION[sp].Return_Period[qid]);
						migtime = MIGRATION[sp].Return_Now[qid] - MIGRATION[sp].Leave_Now[qid];

                        // Reduce prop returning if staggering (so some left for next stagger year)
                        stagger_scalar = 0.0;
                        if (MIGRATION[sp].num_stagger[qid] > 0) {
                            stagger_scalar = 1.0 / (double)(MIGRATION[sp].num_stagger[qid]);
                            migtime2 *= stagger_scalar;
                        }
                        
                        /**
						//if(do_debug2){
                        //if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                        if (sp == 35) {
                            fprintf(bm->logFile, "Time: %e, %s qid: %d migtime2 = %e, period = %d, migtime = %e, migrateReturn = %d, away = %d with original migDEN: %e stagger_scalar: %e num_stagger: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, qid, migtime2, MIGRATION[sp].Return_Period[qid], migtime, MIGRATION[sp].Return_Now[qid], MIGRATION[sp].Leave_Now[qid], MIGRATION[sp].DEN[n][qid], stagger_scalar, (double)(MIGRATION[sp].num_stagger[qid]));
						}
                        **/
                        
                        mignum = MIGRATION[sp].DEN[n][qid] * migtime2;
                        
                        if(!mignum)
                            continue;
                        
                        MIGRATION[sp].DEN[n][qid] -= mignum;

                        if(MIGRATION[sp].DEN[n][qid] < 0)
                            MIGRATION[sp].DEN[n][qid] = 0.0;

                        /* Actual numbers returning - corrected for losses while away */
                        mignum_actual = MIGRATION[sp].survival[qid] * mignum;
                        
                        oldden = totden[sp][n];
                        totden[sp][n] += mignum_actual;
                        mig_returners[sp] = 1;
                        
                        /**
                        //if(do_debug2){
                        //if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                        if (sp == 35) {
                            fprintf(bm->logFile,"Time: %e, %s-%d qid: %d totden: %e with mignum_actual: %e mignum: %e migtime2: %e survival: %e migDEN now: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, qid,  totden[sp][n], mignum_actual, mignum, migtime2, MIGRATION[sp].survival[qid], MIGRATION[sp].DEN[n][qid]);
                        }
                        **/
                            
                        /* Split across stocks */
                        if (stock_id < 0) {
                            /* Homogeneously spread across stocks */
                            maxstock = FunctGroupArray[sp].numStocks;
                            for (k = 0; k < maxstock; k++) {
                                init_stock_struct_prop[sp][n][k] += (mignum_actual / maxstock);
                            }
                            stock_id = 0;
                        } else {
                            /* Directed to a specific stock */
                            init_stock_struct_prop[sp][n][stock_id] += mignum_actual;
                        }

                            
                        /* Adjust average size to account for fact not all those who migrate out return (FSM_sp)
                            and growth during the intervening period - rather than add extra parameters
                            for this, assume that over the course of a year recover what is lost in spawning
                            so pro-rate that recovery for the period out side the model domain. Only exceptions
                            are juvenile FVO, which actively grow not just recover reserves during the period,
                            and baleen whales which on recover reserves in the summer migration as don't feed
                            in the winter.  */

                        oldsn = VERTinfo[sp][n][SN_id];
                        if(MIGRATION[sp].IsAnnualMigration[qid]) {
                            if(bm->flag_replicated_old) {
                                FSMG_grow = 1.0 + (MIGRATION[sp].growth[qid] * migtime / 364.0) / FunctGroupArray[sp].X_RS[n];
                            } else {
                                FSMG_grow = 1.0 + (MIGRATION[sp].growth[qid] * migtime / 364.0);
                            }
                        } else {
                            FSMG_grow = 1.0;
                            if (FunctGroupArray[sp].isExternal == FALSE) { // If true explicitly grow without needing additional growth scaling
                                growth_period = (double)(MIGRATION[sp].MinYearsAway[qid]);
                                FSMG_grow = 1.0 + ((MIGRATION[sp].growth[qid] / growth_period) * migtime / 364.0);
                            }
                        }
                        
                        if (MIGRATION[sp].SN[n][qid] > 0) {
                            stepSN = MIGRATION[sp].SN[n][qid] * FSMG_grow * mignum_actual;
                            VERTinfo[sp][n][SN_id] = (oldsn * oldden + stepSN) / (totden[sp][n] + small_num);
                        }

                        oldrn = VERTinfo[sp][n][RN_id];

                        if (MIGRATION[sp].RN[n][qid] > 0) {
                            stepRN = MIGRATION[sp].RN[n][qid] * FSMG_grow * mignum_actual;
                            VERTinfo[sp][n][RN_id] = (oldrn * oldden + stepRN) / (totden[sp][n] + small_num);
                        }
                        
						/* Reset Migration matrix if all have returned or this migration period is over */  
						if (MIGRATION[sp].DEN[n][qid] < 0.0) {
							if (bm->flagavgmig) {
                                MIGRATION[sp].SN[n][qid] = 0.0;
                                MIGRATION[sp].RN[n][qid] = 0.0;
							}
							MIGRATION[sp].DEN[n][qid] = 0.0;
                            
                            /*
                            if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                                fprintf(bm->logFile, "Time: %e reset DEN for %s-%d qid %d to 0 as all migrants exhausted (DEN < 0)\n", bm->dayt, FunctGroupArray[sp].groupCode, n, qid);
                            }
                             */
						}
                        
						if ((bm->dayt + 2) > (MIGRATION[sp].Return_Now[qid] + MIGRATION[sp].Return_Period[qid])) {
							if (bm->flagavgmig) {
                                MIGRATION[sp].SN[n][qid] = 0.0;
                                MIGRATION[sp].RN[n][qid] = 0.0;
							}
							MIGRATION[sp].DEN[n][qid] = 0.0;
                            
                            /*
                            if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                                fprintf(bm->logFile, "Time: %e reset DEN for %s-%d qid %d to 0 due to time test - Return_Now: %d, Return_Period: %d\n", bm->dayt, FunctGroupArray[sp].groupCode, n, qid, MIGRATION[sp].Return_Now[qid], MIGRATION[sp].Return_Period[qid]);
                            }
                            */
						}

                        
                        /** Do any young of the year returning **/
                        
                        /**
                        if(do_debug2){
                            //printf("Time; %e starting movement/migration load of recruits for %s-%d stock_id: %d\n", bm->dayt, FunctGroupArray[sp].groupCode, n, stock_id);
                            //printf("Time: %e, %s-%d recruit_outside: %e direct_recruit_entry: %e larval_queue_extension: %e recruit_qid: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, FunctGroupArray[sp].speciesParams[recruit_outside_id], FunctGroupArray[sp].speciesParams[direct_recruit_entry_id], FunctGroupArray[sp].speciesParams[larval_queue_extension_id], FunctGroupArray[sp].speciesParams[recruit_qid_id]);
                            
                            fprintf(bm->logFile,"Time: %e, %s-%d stock_id: %d qid: %d, recruit_outside: %e direct_recruit_entry: %e larval_queue_extension: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, stock_id, qid, FunctGroupArray[sp].speciesParams[recruit_outside_id], FunctGroupArray[sp].speciesParams[direct_recruit_entry_id], FunctGroupArray[sp].speciesParams[larval_queue_extension_id]);
                        }
                        **/

                        if ((n < FunctGroupArray[sp].numGeneTypes) && FunctGroupArray[sp].speciesParams[recruit_outside_id]) {
                            // First start with any that might be coming from before model started
                            yoy_den = 0.0;
                            if(FunctGroupArray[sp].speciesParams[larval_queue_extension_id] > 0) {
                                for (lid = 0; lid < FunctGroupArray[sp].speciesParams[larval_queue_extension_id]; lid++) {
                                    yoy_den += EMBRYO[sp].Larvae[stock_id][n][lid];
                                    EMBRYO[sp].Larvae[stock_id][n][lid] = 0;
                                }
                                // Reset larval_queue_extension so not called in subsequent years
                                if (stock_id == (FunctGroupArray[sp].numStocks - 1)) {
                                    FunctGroupArray[sp].speciesParams[larval_queue_extension_id] = 0;
                                }
                            } else {
                                //lid = (int)(FunctGroupArray[sp].speciesParams[recruit_qid_id]);
                                //yoy_den += EMBRYO[sp].Larvae[stock_id][n][lid];
                                
                                //Nothing to do as now delivered to MIGRATION[sp].recruit[n][qid]; array direct
                            }

                            /**
                            if(do_debug2){
                                fprintf(bm->logFile,"Time: %e, %s-%d qid: %d MIGrecruit: %e yoy_den: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, qid, MIGRATION[sp].recruit[n][qid], yoy_den);
                            }
                            **/

                            if (FunctGroupArray[sp].speciesParams[direct_recruit_entry_id] && (MIGRATION[sp].recruit[n][qid] || yoy_den)) {
                                // Now direct returning recruits
                                yoy_den += MIGRATION[sp].recruit[n][qid];
                            
                                KWSR_sp = FunctGroupArray[sp].speciesParams[KWSR_id];
                                KWRR_sp = FunctGroupArray[sp].speciesParams[KWRR_id];
                                if (bm->flag_modify_KWSR) {
                                    KWSR_sp = Get_Recruit_Size_Forcing(bm, sp, do_debug, llogfp);
                                    KWRR_sp = KWSR_sp * FunctGroupArray[sp].X_RS[n];
                                }

                                oldsn = VERTinfo[sp][n][SN_id];
                                stepSN = KWSR_sp * yoy_den;
                                VERTinfo[sp][n][RN_id] = (oldsn * totden[sp][n] + stepSN) / (totden[sp][n] + yoy_den + small_num);
                                stepRN = KWRR_sp * yoy_den;
                                oldrn = VERTinfo[sp][n][RN_id];
                                VERTinfo[sp][n][RN_id] = (oldrn * totden[sp][n] + stepRN) / (totden[sp][n] + yoy_den + small_num);

                                totden[sp][n] += yoy_den;  // Add the recruits to tot numbers
                                MIGRATION[sp].recruit[n][qid] = 0;  // Reset
                            
                                /**
                                //if(do_debug2){
                                //if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                                    fprintf(bm->logFile,"Time: %e, %s-%d qid: %d, totden: %e with yoy_den: %e SN: %e RN: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, qid, totden[sp][n], yoy_den, VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id]);
                                //}
                                **/
                            }
                        }
						mig_done++;
					}
				}
			}
		}
        
        //fprintf(llogfp,"%s move1 now has next_larvae set to %d\n", FunctGroupArray[sp].groupCode, EMBRYO[sp].next_larvae);
        //printf("%s move1 now has next_larvae set to %d\n", FunctGroupArray[sp].groupCode, EMBRYO[sp].next_larvae);

	}

    /* Movement of vertebrates */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
        if (FunctGroupArray[sp].isVertebrate == TRUE) {

			spmigrate = 0;
			bearlive = 0;
			flagmother = 0;
			sp_amt = 0;
			this_tot_biom = 0;

			 for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				 newden_sum[n] = 0.0;
			 }

			flagsp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);

			/* Get the current season index */
			qrt = FunctGroupArray[sp].moveEntryIndex;
			//qrt = bm->QofY;
            next_qrt = FunctGroupArray[sp].next_moveEntryIndex;

			/* If which check is greater than all funct groups then show debugging for all groups */
            do_debug2 = 0;
            /**
             if(sp == 64)
             do_debug2 = 1;
             
             if (bm->debug && ((bm->debug == debug_migrate) && (((sp == bm->which_check) && (bm->dayt > bm->checkstart)) || (bm->which_check > bm->K_num_tot_sp)))) {
				do_debug2 = 1;
			}
            if (bm->which_check == sp)
                do_debug2 = 1;
             **/

			/* Skip over groups not in the model */
			if (!flagsp)
				continue;

			/* if a group doesn't move vertically or horizontally then skip */
			if(FunctGroupArray[sp].isMobile == FALSE && FunctGroupArray[sp].sp_geo_move == FALSE)
				continue;

			/* Normalise proportion of total abundance in each stock */
			for (ij = 0; ij < maxij; ij++) {
				for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
					bm->stock_struct_prop[sp][n][ij] = init_stock_struct_prop[sp][n][ij] / (totden[sp][n] + small_num);
					sp_amt += totden[sp][n];

                    /**
					if(do_debug2){
                        fprintf(llogfp,"Time: %e %s-%d, stock: %d (of %d), prop_stock: %e\n",
							 bm->dayt, FunctGroupArray[sp].groupCode, n, ij, FunctGroupArray[sp].numStocks, bm->stock_struct_prop[sp][n][ij]);
					}
                    **/
				}
			}
            
			/* If non present (less than one individual present in entire system) then skip ahead */
			if (sp_amt < bm->min_dens) {
				if (do_debug2 || (do_debug && (sp == bm->move_check)))
					fprintf(llogfp, "No %s present so skipping ahead (%e)\n", FunctGroupArray[sp].groupCode, sp_amt);
				continue;
			}

			for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				/* Initialise totnumber being distributed */
				totboxden[n] = 0.0;
			}

			/* Note that this use of growth rate and clearance parameters is based only
			 on the default Holling type feeding relation and on surface temperatures. This
			 would need to change if other feeding types are used regularly and if depth related
			 changes in feeding efficiency guiding feeding depths */
			sp_ddepend_move = (int) (FunctGroupArray[sp].speciesParams[ddepend_move_id]);
            
            // Allow for vertical movement only - over-write movement case 
            if(FunctGroupArray[sp].sp_geo_move == FALSE)
                sp_ddepend_move = sedentary_move;

			age_mat = (int) (FunctGroupArray[sp].speciesParams[age_mat_id]);
			spSpeed = FunctGroupArray[sp].speciesParams[Speed_id];
			min_temp_sp = FunctGroupArray[sp].speciesParams[min_move_temp_id];
			max_temp_sp = FunctGroupArray[sp].speciesParams[max_move_temp_id];
			min_spawntemp_sp = FunctGroupArray[sp].speciesParams[min_spawn_temp_id];
			max_spawntemp_sp = FunctGroupArray[sp].speciesParams[max_spawn_temp_id];
			min_salt_sp = FunctGroupArray[sp].speciesParams[min_move_salt_id];
			max_salt_sp = FunctGroupArray[sp].speciesParams[max_move_salt_id];
			min_spawnsalt_sp = FunctGroupArray[sp].speciesParams[min_spawn_salt_id];
			max_spawnsalt_sp = FunctGroupArray[sp].speciesParams[max_spawn_salt_id];
			min_O2_sp = FunctGroupArray[sp].speciesParams[min_O2_id];
			temp_sensitive_sp = (int)(FunctGroupArray[sp].speciesParams[flagtempsensitive_id]);
			salt_sensitive_sp = (int)(FunctGroupArray[sp].speciesParams[flagSaltSensitive_id]);
            
            if (FunctGroupArray[sp].numMoveEntries != 4) {
                this_HowFar = FunctGroupArray[sp].HowFar;
            } else {
                this_HowFar = bm->HowFar;
            }

			/* Replicate old bec_dev results on existing models. We will remove this asap! */
			if(bm->flag_replicated_old == FALSE){
				if(salt_sensitive_sp || temp_sensitive_sp)
					sp_enviro_depend = 1;
				else
					sp_enviro_depend = 0;
			}

			bearlive = (int) (FunctGroupArray[sp].speciesParams[flagbearlive_id]);
			flagmother = (int) (FunctGroupArray[sp].speciesParams[flagmother_id]);
			sp_feed_while_spawn = (int) (FunctGroupArray[sp].speciesParams[feed_while_spawn_id]);
			flagchannel = (int) (FunctGroupArray[sp].speciesParams[flagchannel_id]);
			spupdatemig = 0;
			spmigrate = MIGRATION[sp].num_in_queue;

			/* Make parameter adjustments due to acidification */
			flagcontract_sp = (int)FunctGroupArray[sp].speciesParams[flagcontract_tol_id];
			pH_scale = (FunctGroupArray[sp].pHcorr - 1.0);
			if( flagcontract_sp  && (pH_scale > 0.0)) {
				contract_sp = (int)FunctGroupArray[sp].speciesParams[contract_tol_id];
				min_temp_sp += contract_sp * pH_scale;
				max_temp_sp -= contract_sp * pH_scale;
				min_spawntemp_sp += contract_sp * pH_scale;
				max_spawntemp_sp -= contract_sp * pH_scale;
			}

			/* if this group moves vertically only then work out existing % in each box */
			if(FunctGroupArray[sp].isMobile == TRUE && FunctGroupArray[sp].sp_geo_move == FALSE){
				for (n = 0; n < FunctGroupArray[sp].numCohorts; n++) {
					den = FunctGroupArray[sp].NumsTracers[n];

					/* Get details of feeding preferences */
					for (ij = 0; ij < bm->nbox; ij++) {
						boxden[ij][n] = 0;

						if (bm->boxes[ij].type != BOUNDARY) {
							for (k = 0; k < bm->boxes[ij].nz; k++) {
								boxden[ij][n] += bm->boxes[ij].tr[k][den];
							}
						}

						boxden[ij][n]= boxden[ij][n]/(totden[sp][n] + small_num);
					}
				}
			}

			/* For forage and density dependent movement determine ideal forage locations */
			/* if this group is not vertically mobile then need the currentden for use in Get_Vertical_Distribution() */

			if (sp_ddepend_move > perscribed_move || FunctGroupArray[sp].isMobile == FALSE) {

				/* Get general parameter values for density- and food-dependent movement,
				 cohort specific ones are dealt with below. Note that this use of growth rate
				 and clearance parameters is based only on the default Holling type feeding
				 relation and on surface temperatures. This would need to change if other
				 feeding types are used regularly and if depth related
				 changes in feeding efficiency guiding feeding depths */

				E1_sp = FunctGroupArray[sp].speciesParams[E1_id];

				for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
					den = FunctGroupArray[sp].NumsTracers[n];
					spawn_date = EMBRYO[sp].Spawn_Now[n][EMBRYO[sp].next_spawn];
					spawn_period = (int) (FunctGroupArray[sp].speciesParams[spawn_period_id]);

					if((overall_checkday >= spawn_date) && (overall_checkday <= (spawn_date + spawn_period))){
						sp_spawn_now = 1;
					} else {
						sp_spawn_now = 0;
					}

					/* Initialise totroc */
					totroc[n] = 0.0;

					/* Get details of feeding preferences */
					for (ij = 0; ij < bm->nbox; ij++) {
						/* Initialise density record */
						boxden[ij][n] = 0.0;

						/* Initilaise home range information for those species using home ranges */
						if (sp_ddepend_move == homerange_move) {
							for (rij = 0; rij < bm->boxes[ij].HomeRangeInfo[sp].n; rij++) {
								rangeid = bm->boxes[ij].HomeRangeInfo[sp].ids[rij];
								bm->boxes[ij].HomeRangeInfo[sp].rangenum[n][rij] = 0.0;
							}
						}

						if(bm->boxes[ij].type != BOUNDARY && bm->boxes[ij].type != LAND) {

							for (k = 0; k < bm->boxes[ij].nz; k++) {
								currentden[sp][n][k][ij] = bm->boxes[ij].tr[k][den] / (totden[sp][n] + small_num);
							}
							if (sp_ddepend_move > sedentary_move) {

								/* Calculate potential growth as an index of habitat suitability */
								clear = Calculate_Species_Clearance_Rate(bm, llogfp, sp, n, ij, preyamt);

                                if ((int) (FunctGroupArray[sp].speciesParams[flag_id]) && (int) (FunctGroupArray[sp].speciesParams[active_id]) &&
                                		( bm->boxes[ij].botz <= (-1.0 * FunctGroupArray[sp].speciesParams[mindepth_id]) &&
                                		 bm->boxes[ij].botz >= (-1.0 * FunctGroupArray[sp].speciesParams[maxdepth_id]) &&
                                        ((-1.0 * bm->boxes[bm->current_box].botz) <= FunctGroupArray[sp].speciesParams[maxtotdepth_id]))) {
                                //if ((int) (FunctGroupArray[sp].speciesParams[flag_id]) && (int) (FunctGroupArray[sp].speciesParams[active_id]) &&
                                //    (current_depth <= (-1.0 * FunctGroupArray[sp].speciesParams[mindepth_id]) &&
                                //     current_depth >= (-1.0 * FunctGroupArray[sp].speciesParams[maxdepth_id]))) {

									roc[ij][n] = E1_sp * clear;
								} else {
									roc[ij][n] = 0.0;
								}

								switch (bm->flagroc) {
								case no_ddepend_id: /* No forage- and density- dependent movement so do nothing */
									break;
								case step_ddepend_id: /* Threshold breakpoint - base comparison vs average
								 sized individual */
									if (roc[ij][n] > (k_roc_food * VERTinfo[sp][n][SN_id]))
										/* If good feed area will clump */
										roc[ij][n] = roc[ij][n] * roc_wgt;
									else
										/* If poor feed area will disperse */
										roc[ij][n] = roc[ij][n] / roc_wgt;
									break;
								case decay_ddepend_id: /* Exponentially decaying effects */
									roc[ij][n] = exp(-1.0 / (roc[ij][n] + small_num));
									break;
								default:
									quit("No such forage ideal distrib model defined - how did it get here in the vertebrate migration routine?\n");
									break;
								}

								/* Scale outcome based on own refuge_status of local habitat */
								if (bm->flaghabdepend) {
									rocstage = FunctGroupArray[sp].cohort_stage[n];
									roc[ij][n] *= bm->refuge_status[sp][ij][rocstage];
								}
                                
                                if (roc[ij][n] < 0.0) {
                                    
                                    //fprintf (llogfp, "Time: %e, %s-%d  in box %d has roc < 0 (%e) with roc_wgt: %e, flagroc: %d E1_sp: %e clear: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, roc[ij][n], roc_wgt, bm->flagroc, E1_sp, clear);

                                    if (rocstage >= 0){
                                    	fprintf (llogfp, "Time: %e, %s-%d (stage %d) in box %d has roc < 0 (%e) with refuge_status: %e roc_wgt: %e, flagroc: %d E1_sp: %e clear: %e\n",
                                    		bm->dayt, FunctGroupArray[sp].groupCode, n, rocstage, ij, roc[ij][n], bm->refuge_status[sp][ij][rocstage], roc_wgt, bm->flagroc, E1_sp, clear);
                                    }
                                    quit("Negative roc for %s-%d\n", FunctGroupArray[sp].groupCode, n);
                                    
                                    
                                }

								/* Calculate total potential growth across entire area for each species */
								totroc[n] += roc[ij][n];

								/**
                                 if(do_debug2 && (sp == bm->which_check)){
									fprintf(llogfp,"Time: %e box%d %s-%d totroc: %.20e, roc: %.20e, flaghabdepend: %d, refuge_status[0]: %.20e, refuge_status[1]: %.20e, roc_wgt: %.20e, E1_sp: %.20e, clear: %.20e\n",
										bm->dayt, ij, FunctGroupArray[sp].groupCode, n, totroc[n], roc[ij][n], bm->flaghabdepend,
										bm->refuge_status[sp][ij][0], bm->refuge_status[sp][ij][1], roc_wgt, E1_sp, clear);
								}
								**/
							}

							if (sp_ddepend_move == sticky_ddepend) {
								/* If using 'sticky' density dependent movement determine what proportion has to move
								 then move them. Use average sized individual for comparison purposes */
								for (k = 0; k < bm->boxes[ij].nz; k++) {
									if ((flagmother > 0) && (n < age_mat)) {
										if ((roc[ij][age_mat] / roc_wgt) > (k_roc_food * VERTinfo[sp][n][SN_id])) {
											boxden[ij][n] += currentden[sp][n][k][ij];
											totboxden[n] += currentden[sp][n][k][ij];
										}
									} else {
										if ((roc[ij][n] / roc_wgt) > (k_roc_food * VERTinfo[sp][n][SN_id])) {
											boxden[ij][n] += currentden[sp][n][k][ij];
											totboxden[n] += currentden[sp][n][k][ij];
										}
									}
								}
							} else if (sp_ddepend_move == sedentary_move) {
								/* Sedentary apart from vertical movement determine current distribution */
								if (!bm->t) { /* At startup read it in from fixed spatial distributions */
									rocstage = FunctGroupArray[sp].cohort_stage[n];
									boxden[ij][n] = FunctGroupArray[sp].distrib[ij][0][rocstage];
								} else {
									for (k = 0; k < bm->boxes[ij].nz; k++) {
										boxden[ij][n] += currentden[sp][n][k][ij];
									}
								}
							}

							if ((!sp_feed_while_spawn && sp_spawn_now) && (sp_ddepend_move == switch_ddepend)) {
								/* If using the case where using forage distribution when not spawning and perscribed
								 spawning distribution in the spawning distribution, then if in spawning season set
								 roc contribution to 1.0 (set roc = 1.0 + small_num as the equation is roc / (totroc + small_num))
								 */
								roc[ij][n] = 1.0 + small_num;
								totroc[n] = 1.0;
							}
						}
					}
				}
			}
            
			/* If using 'sticky' density dependent movement start by determining
			 leftden and reinitialising totboxden */
			if (sp_ddepend_move == sticky_ddepend) {
				for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
					leftden[sp][n] = 1.0 - totboxden[n];
					if (leftden[sp][n] < 0.0)
						leftden[sp][n] = 0.0;
					else if (leftden[sp][n] > 1)
						leftden[sp][n] = 1.0;
					totboxden[n] = 0.0;
					/* Initialise the stock sums */
					for (k = 0; k < FunctGroupArray[sp].numStocks; k++) {
						init_stock_struct_prop[sp][n][k] = 0.0;
					}
				}
			} else {
				for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
					/* Initialise totnumber being distributed */
					totboxden[n] = 0.0;
					/* Initialise the stock sums */
					for (k = 0; k < FunctGroupArray[sp].numStocks; k++) {
						init_stock_struct_prop[sp][n][k] = 0.0;
					}
				}
			}

            cells_checked = 0;
            cells_impacted = 0;

            /* Determine final movement distributions */
			for (ij = 0; ij < bm->nbox; ij++) {
				/* Vertical distribution - ignore */
				if(bm->terrestrial_on && bm->boxes[ij].type == LAND){

					/* Is group allowed to move onto land */
					if( FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){

						stock_id = bm->group_stock[sp][ij][0];

						for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {

							stage = FunctGroupArray[sp].cohort_stage[n];

							/* Update stored vertdistrib value - so can condition catch timeseries if need be */
							bm->boxes[ij].vert_vdistrib[sp][stage][0] = 1.0;

							/* Used prescribed migration routes */
							newden[sp][n][0][ij] = 1.0 * (this_HowFar * (FunctGroupArray[sp].distrib[ij][next_qrt][stage] - FunctGroupArray[sp].distrib[ij][qrt][stage]) + FunctGroupArray[sp].distrib[ij][qrt][stage]);

							/* Leave this in for now - don't have any sort of landbased refuge yet */
							if (bm->flag_move_habdepend) {
								newden[sp][n][0][ij] *= bm->refuge_status[sp][ij][stage];
							}

							/**
							if(do_debug2){
								fprintf(bm->logFile, "Time: %e (qrt: %d) %s-%d (stage %d) in box %d-%d newden %e, vertdistrib %e, bm->distrib %e\n",
										bm->dayt, qrt, FunctGroupArray[sp].groupCode, n, stage, ij, k, newden[sp][n][k][ij], vertdistrib, FunctGroupArray[sp].distrib[ij][qrt][stage]);
							}
							**/
						}
					}
				}
				else if (bm->boxes[ij].type != BOUNDARY) {

					Get_Vertical_Distribution(bm, ij, sp, currentden, enviro_depend, day_part, -1, llogfp);

					/*
					if((bm->dayt > bm->checkstart) && (sp == bm->which_check)){
						fprintf(llogfp,"Time: %e %s is doing get_vertical_distrib for box %d\n",
								bm->dayt, FunctGroupArray[sp].groupCode, ij);
					}
					*/

					/* Get final distributions per box and stock */
					for (k = 0; k < bm->boxes[ij].nz; k++) {

						stock_id = bm->group_stock[sp][ij][k];

						for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
							spawn_date = EMBRYO[sp].Spawn_Now[n][EMBRYO[sp].next_spawn];
							spawn_period = (int) (FunctGroupArray[sp].speciesParams[spawn_period_id]);

							if((overall_checkday >= spawn_date) && (overall_checkday <= (spawn_date + spawn_period))){
								sp_spawn_now = 1;
							} else {
								sp_spawn_now = 0;
							}
							stage = FunctGroupArray[sp].cohort_stage[n];

							/* Update stored vertdistrib value - so can condition catch timeseries if need be */
							bm->boxes[ij].vert_vdistrib[sp][stage][k] = tempdistrib[k][stage];

							/*
							if((bm->dayt > bm->checkstart) && (sp == bm->which_check)){
								fprintf(llogfp,"Time: %e %s-%d is doing box %d-%d with sp_ddepend_move: %d\n",
										bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, sp_ddepend_move);
							}
							*/

                            switch (sp_ddepend_move) {
								case weight_ddepend:
								case switch_ddepend:
								case only_ddepend:

                                /* If using weighted density dependent movement (weights slow movement but still drift
                                as if ideal free distributed then determine ideal distribution */
                                /* FIX -- may want to have depth based on roc too not just always at optimal,
                                otherwise with conditions change may not see distribution changes */
                                vertdistrib = tempdistrib[k][stage];

                                if(!stage) {
                                    thiscase1 = 1;
                                    thiscase2 = 1;
                                } else {
                                    thiscase1 = 0;
                                    thiscase2 = 0;
                                    if(!sp_feed_while_spawn && sp_spawn_now)
                                        thiscase1 = 1;
                                    if(!sp_feed_while_spawn && !sp_spawn_now)
                                        thiscase2 = 1;
                                }
                                if (sp_ddepend_move == only_ddepend) {
                                    thiscase2 = 1;
                                    thiscase1 = 0;
                                }

                                /* Find other migration pressure */
                                if (thiscase1 || (sp_ddepend_move != switch_ddepend)) {
        							spawnmove = this_HowFar * (FunctGroupArray[sp].distrib[ij][next_qrt][stage] - FunctGroupArray[sp].distrib[ij][qrt][stage]) + FunctGroupArray[sp].distrib[ij][qrt][stage];
                                } else if (thiscase2){
                                    /* If case where use perscribed spawning movement in spawning season and juvenile
                                     * or not spawning and using case where use forage only in non-spawning period,
                                     * then assume always use forage dependent movement alone, so set spawn_move = 1.0 so
                                     * that it makes no contribution.
                                     */
                                    spawnmove = 1.0;
                                }
                            

                                /* Find feeding migration pressure.
                                For animals (e.g. dolphins) where stay with mother
                                until mature have the juveniles stay with mother via
                                basing their allocation on that of the older age group(s) */


                                if( (flagmother > 0) && (n < age_mat) ){
                                    newden[sp][n][k][ij] = spawnmove * roc[ij][age_mat] / (totroc[age_mat] + small_num);
                                    if(!totroc[age_mat])
                                        newden[sp][n][k][ij] = currentden[sp][n][k][ij];
                                }else{
                                    newden[sp][n][k][ij] = spawnmove * roc[ij][n] / (totroc[n] + small_num);
                                    if(!totroc[n])
                                        newden[sp][n][k][ij] = currentden[sp][n][k][ij];
                                }
                                    
                                
                                    
                                orig_newden = newden[sp][n][k][ij];

                                if(bm->track_contaminants) {
                                    spSpeed = FunctGroupArray[sp].speciesParams[Speed_id];
                                    Get_ContamMoveEffects(bm, sp, n, ij, k);
                                    spSpeed *= FunctGroupArray[sp].C_move_corr[n];
                                }
                                // This needs to be a minimum (so never goes negative), but we need to multiply with vertdistrib AFTER this
                                // step so that distinguish horizontal and vertical movement limitations
                                newden[sp][n][k][ij] = min(1.0,(spSpeed * dt / bm->width)) * (newden[sp][n][k][ij] - currentden[sp][n][k][ij])
                                    + currentden[sp][n][k][ij];
                                newden[sp][n][k][ij] *= vertdistrib;
                                 
                                /*
                                if(sp == bm->which_check) {
                                    fprintf(llogfp, "Time: %e %s-%d box %d-%d newden: %.20e ", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, newden[sp][n][k][ij]);
                                    fprintf(llogfp, "currentden: %.20e orig_newden: %.20e ", currentden[sp][n][k][ij], orig_newden);
                                    fprintf(llogfp, "spSpeed  = %.20e,  dt = %.20e, bm->width = %.20e, vertdistrib = %.20e ", spSpeed, dt, bm->width, vertdistrib);
                                    fprintf(llogfp, "spawnmove = %.20e roc = %.20e totroc = %.20e (age_mat: %d roc-age_mat: %.20e totroc-age_mat: %.20e)\n", spawnmove, roc[ij][n], totroc[n], age_mat, roc[ij][age_mat], totroc[age_mat]);
                                }
                                */

                                if(newden[sp][n][k][ij]  < 0){
										printf("Error in Ecology_Total_Verts_And_Migration\n");
										printf("newden[%s][%d][%d][%d] = %.20e\n", FunctGroupArray[sp].groupCode, n, k, ij, newden[sp][n][k][ij]);
										printf("currentden[%s][%d][%d][%d] = %.20e orig_newden = %.20e\n",
											   FunctGroupArray[sp].groupCode, n, k, ij, currentden[sp][n][k][ij], orig_newden);
										printf("(spSpeed * dt / bm->width) = %.20e\n", (spSpeed * dt / bm->width));
										printf("spSpeed  = %.20e,  dt = %.20e, bm->width = %.20e, vertdistrib = %.20e\n", spSpeed, dt, bm->width, vertdistrib);
										printf("spawnmove = %.20e roc = %.20e totroc = %.20e (age_mat: %d roc-age_mat: %.20e totroc-age_mat: %.20e)\n", spawnmove, roc[ij][n], totroc[n], age_mat, roc[ij][age_mat], totroc[age_mat]);
										quit("");
                                }

                                break;
                            case sticky_ddepend:
                                /* FIX -- may want to have depth based on roc too not just always at optimal,
                                    otherwise with conditions change may not see distribution changes */
                                vertdistrib = tempdistrib[k][stage];
                                /* Find other migration pressure */
    							spawnmove = this_HowFar * (FunctGroupArray[sp].distrib[ij][next_qrt][stage] - FunctGroupArray[sp].distrib[ij][qrt][stage]) + FunctGroupArray[sp].distrib[ij][qrt][stage];
                            
                                /* For animals (e.g. dolphins) where stay with mother
                                until mature have the juveniles stay with mother via
                                basing their allocation on that of the older age group(s).
                                Also use averaged sized individual for comparison purposes */
                                if ((flagmother > 0) && (n < age_mat)) {

                                    if ((roc[ij][age_mat] / roc_wgt) > (k_roc_food * VERTinfo[sp][n][SN_id]))
                                        newden[sp][n][k][ij] = spawnmove * vertdistrib * boxden[ij][n];
                                    else {
                                        newden[sp][n][k][ij] = spawnmove * leftden[sp][n] * roc[ij][age_mat] / (totroc[age_mat] + small_num);
                                        if(!totroc[age_mat])
                                            newden[sp][n][k][ij] = currentden[sp][n][k][ij];

                                        if(bm->track_contaminants) {
                                            spSpeed = FunctGroupArray[sp].speciesParams[Speed_id];
                                            Get_ContamMoveEffects(bm, sp, n, ij, k);
                                            spSpeed *= FunctGroupArray[sp].C_move_corr[n];
                                        }

                                        // This needs to be a minimum (so never goes negative), but we need to multiply with vertdistrib AFTER this
                                        // step so that distinguish horizontal and vertical movement limitations
                                        newden[sp][n][k][ij] = min(1.0, (spSpeed * dt / bm->width)) * (newden[sp][n][k][ij] - currentden[sp][n][k][ij])
                                                + currentden[sp][n][k][ij];
                                        newden[sp][n][k][ij] *= vertdistrib;
                                    }
                                    
                                    /*
                                    fprintf(llogfp,"Time: %e %s-%d in %d-%d flagmother newden: %e spawnmove: %e vertdistrib: %e boxden: %e leftden: %e roc: %e totroc: %e, roc_wgt: %e k_roc_food: %e VERTinfo-SN: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k,  newden[sp][n][k][ij], spawnmove, vertdistrib, boxden[ij][n], leftden[sp][n], roc[ij][age_mat], totroc[age_mat], roc_wgt, k_roc_food, VERTinfo[sp][n][SN_id]);
                                     */

                                } else {
                                    if ((roc[ij][n] / roc_wgt) > (k_roc_food * VERTinfo[sp][n][SN_id])) {
                                        newden[sp][n][k][ij] = spawnmove * vertdistrib * boxden[ij][n];
                                    } else {
                                        newden[sp][n][k][ij] = spawnmove * leftden[sp][n] * roc[ij][n] / (totroc[n] + small_num);
                                        if(!totroc[n])
                                            newden[sp][n][k][ij] = currentden[sp][n][k][ij];

                                        if(bm->track_contaminants) {
                                            spSpeed = FunctGroupArray[sp].speciesParams[Speed_id];
                                            Get_ContamMoveEffects(bm, sp, n, ij, k);
                                            spSpeed *= FunctGroupArray[sp].C_move_corr[n];
                                        }

                                        // This needs to be a minimum (so never goes negative), but we need to multiply with vertdistrib AFTER this
                                        // step so that distinguish horizontal and vertical movement limitations
                                        newden[sp][n][k][ij] = min(1.0, (spSpeed * dt / bm->width)) * (newden[sp][n][k][ij] - currentden[sp][n][k][ij])
                                                + currentden[sp][n][k][ij];
                                        newden[sp][n][k][ij] *= vertdistrib;
                                    }
                                    
                                    /*
                                    fprintf(llogfp,"Time: %e %s-%d in %d-%d newden: %e spawnmove: %e vertdistrib: %e boxden: %e currentden: %e leftden: %e roc: %e totroc: %e, roc_wgt: %e k_roc_food: %e VERTinfo-SN: %e speed: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k,  newden[sp][n][k][ij], spawnmove, vertdistrib, boxden[ij][n], currentden[sp][n][k][ij], leftden[sp][n], roc[ij][n], totroc[n], roc_wgt, k_roc_food, VERTinfo[sp][n][SN_id], min(1.0, (spSpeed * dt / bm->width)));
                                     */
                                }
                                    
                                    

                                break;
                            case sedentary_move:
                                vertdistrib = tempdistrib[k][stage];
                                newden[sp][n][k][ij] = vertdistrib * boxden[ij][n];
                                break;
                            case perscribed_move:
                                /* Used prescribed migration routes */
                                vertdistrib = tempdistrib[k][stage];

    							newden[sp][n][k][ij] = vertdistrib * (this_HowFar * (FunctGroupArray[sp].distrib[ij][next_qrt][stage] - FunctGroupArray[sp].distrib[ij][qrt][stage]) + FunctGroupArray[sp].distrib[ij][qrt][stage]);

                                if (bm->flag_move_habdepend) {
                                    newden[sp][n][k][ij] *= bm->refuge_status[sp][ij][stage];
                                }
                                    
                                break;
                            case homerange_move:
                                /* Use home ranges

                                    This distributes individuals across home-range based on weighted averages
                                    (where weights are areas of boxes in the home range). The individuals are
                                    drawn from the matrix that keeps track of the numbers of animals in each
                                    home range.
                                 
                                    Note HomeRangeTotal is proportion of the total population in each home range
                                    whereas rangewgt is the proportion of those in home range x in the current cell
                                    */
                                vertdistrib = tempdistrib[k][stage];

                                newden[sp][n][k][ij] = 0;
                                for (rij = 0; rij < bm->boxes[ij].HomeRangeInfo[sp].n; rij++) {
                                    rangeid = bm->boxes[ij].HomeRangeInfo[sp].ids[rij];
                                    newden[sp][n][k][ij] += vertdistrib * bm->HomeRangeTotal[sp][n][rangeid] * bm->boxes[ij].HomeRangeInfo[sp].rangewgt[rij];
                                }
                                if (bm->flag_move_habdepend) {
                                    newden[sp][n][k][ij] *= bm->refuge_status[sp][ij][stage];
                                }
                                break;
                            default:
                                quit("No such ddepend flag value (%d) for %s\n", sp_ddepend_move, FunctGroupArray[sp].groupCode);
                                break;
                            }

							/* Do a check to see how we are travelling so far */
							if(newden[sp][n][k][ij]  < 0){
								quit("Vertebrate movement. Density is less than 0 for group %s, cohort %d in box %d:%d, sp_ddepend_move = %d\n",
										FunctGroupArray[sp].groupCode, n, ij, k, sp_ddepend_move);
							}
                            
                            /* Noise and light pollution avoidance */
                            if (FunctGroupArray[sp].isLightEffected) {
                                current_enviro = bm->boxes[ij].tr[k][Light_Pollution_i];
                                if (current_enviro > 0) {
                                    newden[sp][n][k][ij] *= (FunctGroupArray[sp].speciesParams[light_coefft_id] / (current_enviro + small_num));
                                }
                            }
                            
                            if (FunctGroupArray[sp].isNoiseEffected) {
                                current_enviro = bm->boxes[ij].tr[k][Noise_Pollution_i];
                                if (current_enviro > 0) {
                                    newden[sp][n][k][ij] *= (FunctGroupArray[sp].speciesParams[noise_coefft_id] / (current_enviro + small_num));
                                }
                            }

							/**
                            if(sp ==64) {
                                fprintf(llogfp,"Time %e %s-%d box%d-%d before enviro_depend newden: %e\n",
                                        bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, newden[sp][n][k][ij]);
                                
                            }
                            **/
                            
                            cells_checked++;
                            numScalar_final = 1.0;
							if (enviro_depend) {
								/* If temperature dependent check to see if temperatures suitable here.
								 If not zero the entry. Similarly for salinity and oxygen.
								 */

                                numScalar = 1.0;
                                current_enviro = bm->boxes[ij].tr[k][Temp_i];
                                K_temp_const_sp = FunctGroupArray[sp].speciesParams[K_temp_const_id];
                                numScalar = Get_Enviro_Move_Scalar(temp_sensitive_sp, current_enviro, K_temp_const_sp, min_temp_sp, max_temp_sp, sp, 1, bm->dayt, llogfp);
                                newden[sp][n][k][ij] *= numScalar;
                                numScalar_final *= numScalar;
                                
                                numScalar = 1.0;
								current_enviro = bm->boxes[ij].tr[k][Salinity_i];
                                K_salt_const_sp = FunctGroupArray[sp].speciesParams[K_salt_const_id];
                                numScalar = Get_Enviro_Move_Scalar(salt_sensitive_sp, current_enviro, K_salt_const_sp, min_salt_sp, max_salt_sp, sp, 2, bm->dayt, llogfp);
                                newden[sp][n][k][ij] *= numScalar;
                                numScalar_final *= numScalar;

                                numScalar = 1.0;
								current_enviro = bm->boxes[ij].tr[k][Oxygen_i];
                                K_o2_const_sp = FunctGroupArray[sp].speciesParams[K_o2_const_id];
                                numScalar = Get_Enviro_Move_Scalar(bm->flagO2depend, current_enviro, K_o2_const_sp, min_O2_sp, 10000000000.0, sp, 3, bm->dayt, llogfp);
                                newden[sp][n][k][ij] *= numScalar;
                                numScalar_final *= numScalar;

								// If ice dependent and no ice present then not present
								if(bm->ice_on) {
									some_ice = Get_Ice_Presence(bm, sp, stage, ij, k, bm->ICE_HABITATlike);
									if(!some_ice){
										newden[sp][n][k][ij] = 0.0;
									}
								}
								/**
								//if((bm->dayt > bm->checkstart) && (sp == bm->which_check)){
                                if(sp ==64) {
									fprintf(llogfp,"Time %e %s-%d box%d-%d enviro_depend: %d newden after enviro %e as current_enviro: %e min_O2_sp: %e\n",
											bm->dayt, FunctGroupArray[sp].groupCode, n, k, ij, enviro_depend, newden[sp][n][k][ij], current_enviro,  min_O2_sp);

								}
								**/

							}
                            
                            if(bm->track_contaminants) {
                                // Contaminant avoidance
                                numScalar = Avoid_Contaminants(bm, sp, n, ij, k);
                                newden[sp][n][k][ij] *= numScalar;
                                numScalar_final *= numScalar;
                            }
                            
                            if(bm->flagenviro_warn && (numScalar_final != 1.0)) {
                                cells_impacted++;
                            }
						}
					}
				}
			}

            if(bm->flagenviro_warn & cells_impacted) {
                fprintf(llogfp, "Time: %e %s is environmemtally constrained in %d of %d cells (box*layer*cohort combos)\n", bm->dayt, FunctGroupArray[sp].groupCode, cells_impacted, cells_checked);
            }
            
            /* If tidal deal with that now */
			if (bm->tidal) {
				/* If tidal move channel lovers into deeper water on ebb tide.
				 Base distribution should put them on flats in flood tide
				 */
				if (flagchannel) {
					for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
						stage = FunctGroupArray[sp].cohort_stage[n];
						for (ij = 0; ij < bm->nbox; ij++) {
							if (bm->boxes[ij].type != BOUNDARY && bm->boxes[ij].type != LAND) {

								/* Find channels - any with depth > min_channel_depth */
								nbox_spread = 0.0;
								if (bm->boxes[ij].current_botz < bm->min_channel_depth) {
									for (adbox = 0; adbox < bm->boxes[ij].nconn; adbox++) {
										chkbox = bm->boxes[ij].ibox[adbox];
										if (bm->boxes[chkbox].current_botz > bm->min_channel_depth) {
											nbox_spread += (bm->boxes[chkbox].area * bm->boxes[chkbox].current_botz);
										}
									}
									/* Move out into the channel - based on size of channel boxes */
									if (nbox_spread > 0.0) {
										chkbox = 0;
										for (adbox = 0; adbox < bm->boxes[ij].nconn; adbox++) {
											chkbox = bm->boxes[ij].ibox[adbox];
											for (k = 0; k < bm->boxes[chkbox].nz; k++) {
												newden[sp][n][k][chkbox] += newden[sp][n][k][ij] * bm->boxes[chkbox].area * bm->boxes[chkbox].dz[k]
														* tempdistrib[k][stage] / nbox_spread;
											}
										}
										/* Empty the shallows and flats */
										for (k = 0; k < bm->boxes[chkbox].nz; k++) {
											newden[sp][n][k][ij] = 0;
										}
									}
								}
							}
						}
					}
				}
			}
            
			/* Do final summation (in all cases) */
			for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				for (ij = 0; ij < bm->nbox; ij++) {
					if (bm->boxes[ij].type == LAND) {
						if( FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){

							/* Get stock id */
							stock_id = bm->group_stock[sp][ij][0];

							/* Total up the new proportions just to make sure */
							totboxden[n] += newden[sp][n][0][ij];

							/* Get new allocation per stock */
							init_stock_struct_prop[sp][n][stock_id] += newden[sp][n][0][ij];
						}

					}else if (bm->boxes[ij].type != BOUNDARY) {
						for (k = 0; k < bm->boxes[ij].nz; k++) {
							/* Get stock id */
							stock_id = bm->group_stock[sp][ij][k];

							/* Total up the new proportions just to make sure */
							totboxden[n] += newden[sp][n][k][ij];

							/* Get new allocation per stock */
							init_stock_struct_prop[sp][n][stock_id] += newden[sp][n][k][ij];
						}
					}
				}
				/* Replicate old bec_dev results on existing models. We will remove this asap! */
				if(bm->flag_replicated_old == FALSE){
					/* Normalise new stock prop */
					for (k = 0; k < FunctGroupArray[sp].numStocks; k++) {
						init_stock_struct_prop[sp][n][k] /= (totboxden[n] + small_num);
					}
				}

				/* Normalise final distributions */
				totboxden[n] = 0;
				for (ij = 0; ij < bm->nbox; ij++) {
					if (bm->boxes[ij].type == LAND){
						if( FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){


							stock_id = bm->group_stock[sp][ij][0];

							if (init_stock_struct_prop[sp][n][stock_id] == 0) {
								// Had to allow for case that this could be zero as evolution can see a genotype disappear
								newden[sp][n][0][ij] = 0.0;
							} else {
								newden[sp][n][0][ij] = newden[sp][n][0][ij] * bm->stock_struct_prop[sp][n][stock_id] / (init_stock_struct_prop[sp][n][stock_id]
									+ small_num);
							}
                            
							if(newden[sp][n][0][ij]  < 0){
								printf("newDen - %e, stock structure = %e, init stock sturcture = %e\n", newden[sp][n][0][ij], bm->stock_struct_prop[sp][n][stock_id], init_stock_struct_prop[sp][n][stock_id]);
								quit("Vertebrate movement. Density is less than 0 for group %s, cohort %d in land box %d\n", FunctGroupArray[sp].groupCode, n, ij);
							}

							totboxden[n] += newden[sp][n][0][ij];

							if(totboxden[n] < 0){
								quit("Total box density is less than 0\n");
							}
						}

					}else if (bm->boxes[ij].type != BOUNDARY) {
						for (k = 0; k < bm->boxes[ij].nz; k++) {
							stock_id = bm->group_stock[sp][ij][k];

							if (init_stock_struct_prop[sp][n][stock_id] == 0) {
								// Had to allow for case that this could be zero as evolution can see a genotype disappear
								newden[sp][n][k][ij] = 0.0;
							} else {
								newden[sp][n][k][ij] = newden[sp][n][k][ij] * bm->stock_struct_prop[sp][n][stock_id] / (init_stock_struct_prop[sp][n][stock_id]
									+ small_num);
							}

							if(newden[sp][n][k][ij]  < 0){
								printf("newDen - %e, stock structure = %e, init stock sturcture = %e\n", newden[sp][n][k][ij], bm->stock_struct_prop[sp][n][stock_id], init_stock_struct_prop[sp][n][stock_id]);
								quit("Vertebrate movement. Density is less than 0 for group %s, cohort %d in box %d:%d\n", FunctGroupArray[sp].groupCode, n, ij, k);
							}

							totboxden[n] += newden[sp][n][k][ij];
                            
                            /*
                            if(sp == 64) {
                                fprintf(llogfp, "Time: %e box%d-%d %s-%d newden: %e\n", bm->dayt, ij, k, FunctGroupArray[sp].groupCode, n, newden[sp][n][k][ij]);
                            }
                             */

							if(totboxden[n] < 0){
								quit("Total box density is less than 0\n");
							}
						}
					}
				}

                
				/* Most likely need to rescale is environmental drivers invalidating some cells */
				for (ij = 0; ij < bm->nbox; ij++) {
					if (bm->terrestrial_on && bm->boxes[ij].type == LAND){
						if( FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){

							newden[sp][n][0][ij] /= (totboxden[n] + small_num);
						}
					}else if (bm->boxes[ij].type != BOUNDARY) {
						for (k = 0; k < bm->boxes[ij].nz; k++) {
							newden[sp][n][k][ij] /= (totboxden[n] + small_num);

							/**
							if((bm->dayt > bm->checkstart) && (sp == bm->which_check)){
								fprintf(llogfp,"Time %e %s-%d box%d-%d normalised newden %e totboxden: %e\n",
										bm->dayt, FunctGroupArray[sp].groupCode, n, k, ij, newden[sp][n][k][ij], totboxden[n]);

							}
							**/

						}
					}
				}

				/* Add some checks to make sure our new density is positive */
				for (ij = 0; ij < bm->nbox; ij++) {
					if (bm->boxes[ij].type == LAND ){
						if( FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){
							if(newden[sp][n][0][ij]  < 0){
								quit("Vertebrate movement. Density is less than 0 for group %s, cohort %d in land box %d\n", FunctGroupArray[sp].groupCode, n, ij);
							}
						}
					}else if (bm->boxes[ij].type != BOUNDARY) {
						for (k = 0; k < bm->boxes[ij].nz; k++) {
							if(newden[sp][n][k][ij]  < 0){
								quit("Vertebrate movement. Density is less than 0 for group %s, cohort %d in box %d:%d\n", FunctGroupArray[sp].groupCode, n, ij, k);
							}
						}
					}
				}
			}
            
            /* For those species bearing live young update the recruit location
			 matrix to match adult distribution (for use in Vertebrate_Reproduction()) */
			for (ngene = 0; ngene < FunctGroupArray[sp].numGeneTypes; ngene++) {
				totad[ngene] = 1.0;
                
                update_larval_distrib = 0;
                if (bearlive || (FunctGroupArray[sp].recruitType == at_parent_location) || (FunctGroupArray[sp].recruitType == larval_dispersal)) {
                    update_larval_distrib = 1;
                }
                if(update_larval_distrib && bm->enviro_independ_larvae)
                    update_larval_distrib = 0;
                
                /*
                 if(!sp) {
                    fprintf(llogfp,"Time: %e, %s ngene: %d StartDay to check: %d\n", bm->dayt, FunctGroupArray[sp].groupCode, ngene, EMBRYO[sp].StartDay[ngene][EMBRYO[sp].next_recruit]);
                }
                */
                /* Due to timing of when calcualiton for recruits done vs spawning if want to reflect conditions at time of recruiting need to use StartDay but appreciate there could be up to a year lag in application depending on time between spawning and recruitment. Or if want to reflect larval conditions near spawning use the spawning day conditions so use next_spawn_any_age */
                
                if(bm->flag_recruit_effect) {
                    test_day = EMBRYO[sp].StartDay[ngene][EMBRYO[sp].next_recruit];
                } else {
                    test_day = EMBRYO[sp].next_spawn_any_age;
                }
                check_day = bm->dayt;
                
				if ((update_larval_distrib || sp_enviro_depend) && (check_day == test_day) && (bm->t / 86400.0 > 0.0)) {
					totad[ngene] = 0.0;
					for (ij = 0; ij < bm->nbox; ij++) {
                        
                        if( update_larval_distrib )
                            bm->recruit_hdistrib[ngene][ij][sp] = 0.0;
                        
                        if (bm->terrestrial_on == TRUE && bm->boxes[ij].type == LAND) {
        					if(FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){
        						if( update_larval_distrib ) {
									for(bcohort = age_mat; bcohort < FunctGroupArray[sp].numCohorts; bcohort++){
										n = (FunctGroupArray[sp].numGeneTypes * bcohort) + ngene;

										/* Sum over current distribution of adult age groups */
										bm->recruit_hdistrib[ngene][ij][sp] += newden[sp][n][0][ij];
										totad[ngene] += newden[sp][n][0][ij];

										//fprintf(bm->logFile, "update_larval_distrib = %d, bm->recruit_hdistrib[%d][%d][%d] = %e\n",
										//	update_larval_distrib, ngene, ij, sp, bm->recruit_hdistrib[ngene][ij][sp]);
									}
								} else {
									bm->recruit_hdistrib[ngene][ij][sp] =  bm->recruit_hdistrib_orig[ngene][ij][sp];
									totad[ngene] += bm->recruit_hdistrib_orig[ngene][ij][sp];
								}
        					}
                        }
						if (bm->boxes[ij].type != BOUNDARY){// && bm->boxes[ij].type != LAND) {
							for (k = 0; k < bm->boxes[ij].nz; k++) {

                                temp_effect = 1.0;
                                current_enviro = bm->boxes[ij].tr[k][Temp_i];
                                K_temp_const_sp = FunctGroupArray[sp].speciesParams[K_temp_const_id];
                                temp_effect = Get_Enviro_Move_Scalar(temp_sensitive_sp, current_enviro, K_temp_const_sp, min_spawntemp_sp, max_spawntemp_sp, sp, 1, bm->dayt, llogfp);
                                
                                salt_effect = 1.0;
                                current_enviro = bm->boxes[ij].tr[k][Salinity_i];
                                K_salt_const_sp = FunctGroupArray[sp].speciesParams[K_salt_const_id];
                                salt_effect = Get_Enviro_Move_Scalar(salt_sensitive_sp, current_enviro, K_salt_const_sp, min_spawnsalt_sp, max_spawnsalt_sp, sp, 2, bm->dayt, llogfp);

                                o2_effect = 1.0;
                                current_enviro = bm->boxes[ij].tr[k][Oxygen_i];
                                K_o2_const_sp = FunctGroupArray[sp].speciesParams[K_o2_const_id];
                                o2_effect = Get_Enviro_Move_Scalar(bm->flagO2depend, current_enviro, K_o2_const_sp, min_O2_sp, 10000000000.0, sp, 3, bm->dayt, llogfp);

								// If ice dependent and no ice present then not present
								ice_effect = 1.0;
								if(bm->ice_on) {
									some_ice = Get_Ice_Presence(bm, sp, adult_id, ij, k, bm->ICE_HABITATlike);
									if(!some_ice){
										ice_effect = 0.0;
									}
								}
                                
                                /* Noise and light pollution avoidance */
                                light_effect = 1.0;
                                if (FunctGroupArray[sp].isLightEffected) {
                                    current_enviro = bm->boxes[ij].tr[k][Light_Pollution_i];
                                    if (current_enviro > 0) {
                                        light_effect = (FunctGroupArray[sp].speciesParams[light_coefft_id] / (current_enviro + small_num));
                                    }
                                }
                                
                                noise_effect = 1.0;
                                if (FunctGroupArray[sp].isNoiseEffected) {
                                    current_enviro = bm->boxes[ij].tr[k][Noise_Pollution_i];
                                    if (current_enviro > 0) {
                                        noise_effect = (FunctGroupArray[sp].speciesParams[noise_coefft_id] / (current_enviro + small_num));
                                    }
                                }
                                

                                if( update_larval_distrib ) {
                                    for(bcohort = age_mat; bcohort < FunctGroupArray[sp].numCohorts; bcohort++){
                                        n = (FunctGroupArray[sp].numGeneTypes * bcohort) + ngene;
									
                                        /* Sum over current distribution of adult age groups */
                                        bm->recruit_hdistrib[ngene][ij][sp] += newden[sp][n][k][ij] * temp_effect * salt_effect * o2_effect * ice_effect;
                                        totad[ngene] += newden[sp][n][k][ij] * temp_effect * salt_effect * o2_effect * ice_effect * noise_effect * light_effect;
                                    }
                                    
                                    if(!totad[ngene]) {  // If no adults about set back to the prescribed distribution
                                        adstage = FunctGroupArray[sp].cohort_stage[age_mat];
                                        bm->recruit_hdistrib[ngene][ij][sp] = FunctGroupArray[sp].distrib[ij][qrt][adstage];
                                    }
                                    
                                    
								} else {
                                    bm->recruit_hdistrib[ngene][ij][sp] =  bm->recruit_hdistrib_orig[ngene][ij][sp] * temp_effect * salt_effect * o2_effect * ice_effect;
                                    totad[ngene] += bm->recruit_hdistrib_orig[ngene][ij][sp] * temp_effect * salt_effect * o2_effect * ice_effect * noise_effect * light_effect;
                                }
                                
                                /**
                                if(sp == bm->which_check){
                                    fprintf(llogfp,"Time: %e, %s box-%d rechdistrib: %e (orig: %e, temp_effect: %e, salt_effect: %e, o2_effect: %e, ice_effect: %e, newden: %e totad: %e update_larval_distrib:%d)\n",
                                            bm->dayt, FunctGroupArray[sp].groupCode, ij, bm->recruit_hdistrib[ngene][ij][sp], bm->recruit_hdistrib_orig[ngene][ij][sp], temp_effect, salt_effect, o2_effect, ice_effect, newden[sp][n][k][ij], totad[ngene], update_larval_distrib);
                                }
                                **/
                                
                                
							}
						}
					}

                    /* Normalise if appropriate */
                    if(bm->norm_larval_distrib) {
                        for (ij = 0; ij < bm->nbox; ij++) {
                            bm->recruit_hdistrib[ngene][ij][sp] /= (totad[ngene] + small_num);
                            
                            /**
                            if(sp == bm->which_check){
                                fprintf(llogfp,"Time: %e, %s box-%d rechdistrib: %e (orig: %e)\n", bm->dayt, FunctGroupArray[sp].groupCode, ij, bm->recruit_hdistrib[ngene][ij][sp], bm->recruit_hdistrib_orig[ngene][ij][sp]);
                            }
                            **/
                            

                        }
                        updated_already = 1;
                    }
                    
					/* Calculate the larval dispersion matrix  - the . */
					if (FunctGroupArray[sp].recruitType == larval_dispersal)
						Larval_Dispersal(bm, sp, llogfp);
				}
			}

            /* Initialise the sum */
			for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				for (k = 0; k < FunctGroupArray[sp].numStocks; k++) {
					init_stock_struct_prop[sp][n][k] = 0.0;
				}
			}

			/* If appropriate initialise box 0 for migrant storage
			 - so can be read in output file */
			if (spmigrate) {
				for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
					sn = FunctGroupArray[sp].structNTracers[n];
					rn = FunctGroupArray[sp].resNTracers[n];
					den = FunctGroupArray[sp].NumsTracers[n];

					bm->boxes[0].tr[0][sn] = 0;
					bm->boxes[0].tr[0][rn] = 0;
					bm->boxes[0].tr[0][den] = 0;
				}
			}
			finalmig = 0;
			avgsn = 0;
			avgrn = 0;
			spupdatemig = 0;

			/* Final movement allocations - including migration out of model domain (if any) and
			 normalisation of any local recruitment */
			for (ij = 0; ij < bm->nbox; ij++) {
				if (bm->terrestrial_on == TRUE && bm->boxes[ij].type == LAND) {
					if(FunctGroupArray[sp].habitatCoeffs[LAND_BASED] > 0){

						for (n = 0; n < FunctGroupArray[sp].numGeneTypes; n++) {
							/* Normalise localised recruitment if necessary */
							if (bm->norm_larval_distrib && !updated_already && ((bearlive || sp_enviro_depend || (FunctGroupArray[sp].recruitType == at_parent_location))
									|| (!enviro_depend && (totad[n] != 1.0)))
									&& (bm->dayt == EMBRYO[sp].StartDay[n][EMBRYO[sp].next_recruit]) && (bm->t / 86400.0 > 0.0)) {
								/* If not temperature dependent (when want to see effect of temperature potentially
								 hitting recruits differentially), normalise result - with regard to total population.
								 Shouldn't need to renormalise for stocks as already working off stock normalised basis
								 and any skew due to temperature effects is desired and shouldn't be normalised away,
								 but just to be safe for now */

								bm->recruit_hdistrib[n][ij][sp] = bm->recruit_hdistrib[n][ij][sp] / (totad[n] + small_num);
							}
						}

						stock_id = bm->group_stock[sp][ij][0];

						for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {

							sn = FunctGroupArray[sp].structNTracers[n];
							rn = FunctGroupArray[sp].resNTracers[n];
							den = FunctGroupArray[sp].NumsTracers[n];

							/* Update/assign new vertebrate sn and rn pool values */
							totdenom = 0;
                            
                           if (!bm->flaghomog_sp) {
                                /* If not homogenising size across group/species disribution,
                                but allowing for differentiation and local memory. Very hard
                                to track individual movements so take new value as weighted
                                mean of old residents' size and the size of the new entrants
                                (assuming the new ones have size matching average across
                                the entire stock) */
                                totdenom = currentden[sp][n][0][ij] + totden[sp][n] * newden[sp][n][0][ij] + small_num;

                                bm->boxes[ij].tr[0][sn] = (bm->boxes[ij].tr[0][sn] * currentden[sp][n][0][ij] + VERTinfo[sp][n][SN_id] * totden[sp][n]
                                    * newden[sp][n][0][ij]) / totdenom;
                                bm->boxes[ij].tr[0][rn] = (bm->boxes[ij].tr[0][rn] * currentden[sp][n][0][ij] + VERTinfo[sp][n][RN_id] * totden[sp][n]
                                    * newden[sp][n][0][ij]) / totdenom;

                            } else {
                                /* If homogenising growth/size to reflect random movement of individuals
                                within the global distribution of the group/species over the entire
                                domain of the stock, set SN and RN to that mean value now */
                                bm->boxes[ij].tr[0][sn] = VERTinfo[sp][n][SN_id];
                                bm->boxes[ij].tr[0][rn] = VERTinfo[sp][n][RN_id];
                            }

                            if ((bm->boxes[ij].tr[0][sn] < 0.0) || (bm->boxes[ij].tr[0][rn] < 0.0)) {
                                fprintf(llogfp,"Time: %e, %s-%d in box%d-%d has newsn: %e, newrn:%e, with currentden: %e VERTinfo[sn]: %e, VERTinfo[rn]: %e, totden: %e, newden: %e, totdenom: %e\n",
                                    bm->dayt, FunctGroupArray[sp].groupCode, n, bm->current_box, bm->current_layer,
                                    bm->boxes[ij].tr[0][sn], bm->boxes[ij].tr[0][rn], currentden[sp][n][0][ij],
                                    VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id], totden[sp][n], newden[sp][n][0][ij], totdenom);
                                printf("Time: %e, %s-%d in box%d-%d has newsn: %e, newrn:%e, with currentden: %e VERTinfo[sn]: %e, VERTinfo[rn]: %e, totden: %e, newden: %e, totdenom: %e\n",
                                    bm->dayt, FunctGroupArray[sp].groupCode, n, bm->current_box, bm->current_layer,
                                    bm->boxes[ij].tr[0][sn], bm->boxes[ij].tr[0][rn], currentden[sp][n][0][ij],
                                    VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id], totden[sp][n], newden[sp][n][0][ij], totdenom);
                                
                                fprintf(llogfp, "LAND ERROR Time: %e %s-%d box%d-%d this_tot_biom: %.20e, newden_sum-%d: %.20e, den: %.20e, totden: %.20e, newden: %.20e, SN-%d: %.20e, RN-%d: %.20e (vs SNinit %.20e, RNinit %.20e)\n", bm->dayt,
                                    FunctGroupArray[sp].groupCode, n, ij, 0, this_tot_biom, n,
                                    newden_sum[n], bm->boxes[ij].tr[0][den], totden[sp][n],
                                    newden[sp][n][0][ij], n, bm->boxes[ij].tr[0][sn], n,
                                    bm->boxes[ij].tr[0][rn], VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id]);
                                
                                printf("LAND ERROR Time: %e %s-%d box%d-%d this_tot_biom: %.20e, newden_sum-%d: %.20e, den: %.20e, totden: %.20e, newden: %.20e, SN-%d: %.20e, RN-%d: %.20e (vs SNinit %.20e, RNinit %.20e)\n", bm->dayt,
                                    FunctGroupArray[sp].groupCode, n, ij, 0, this_tot_biom, n,
                                    newden_sum[n], bm->boxes[ij].tr[0][den], totden[sp][n],
                                    newden[sp][n][0][ij], n, bm->boxes[ij].tr[0][sn], n,
                                    bm->boxes[ij].tr[0][rn], VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id]);
                                
                                    quit("%s-%d had negative size or numbers after movement\n", FunctGroupArray[sp].groupCode, n);
                            }

                            /* Allocate vertebrates based on preferred habitat, feed conditions
							 or known migration paths - that is update numbers in current cell */

                            newden_sum[n] += newden[sp][n][0][ij];
                            this_tot_biom += totden[sp][n] * newden[sp][n][0][ij] * (bm->boxes[ij].tr[0][sn] + bm->boxes[ij].tr[0][rn]);
                            bm->boxes[ij].tr[0][den] = totden[sp][n] * newden[sp][n][0][ij];

                            if((bm->boxes[ij].tr[0][den] < 0) || (!_finite(bm->boxes[ij].tr[0][den]))){
                                printf("%e %s-%d land box%d den: %.20e, totden: %.20e, newden: %.20e\n", bm->dayt,
                                FunctGroupArray[sp].groupCode, n, ij, bm->boxes[ij].tr[0][den], totden[sp][n], newden[sp][n][0][ij]);
                                quit("Numbers of %s%d in land box %d are less than 0 or nan after movement.\n", FunctGroupArray[sp].groupCode, n, ij);
                            }
                            
							if (totden[sp][n] > bm->min_dens) {
								FunctGroupArray[sp].allgone[n] = 0;
							}

							/**
							if((do_debug2) && (sp == bm->which_check)){
								fprintf(llogfp, "LAND END Time: %e %s-%d box%d-%d this_tot_biom: %.20e, newden_sum-%d: %.20e, den: %.20e, totden: %.20e, newden: %.20e, SN-%d: %.20e, RN-%d: %.20e (vs SNinit %.20e, RNinit %.20e)\n", bm->dayt,
										FunctGroupArray[sp].groupCode, n, ij, k, this_tot_biom, n,
										newden_sum[n], bm->boxes[ij].tr[k][den], totden[sp][n],
										newden[sp][n][k][ij], n, bm->boxes[ij].tr[k][sn], n,
										bm->boxes[ij].tr[k][rn], VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id]);
							}
							**/

							init_stock_struct_prop[sp][n][stock_id] += bm->boxes[ij].tr[0][den];

							bm->totbiom[sp] += (bm->boxes[ij].tr[0][sn] + bm->boxes[ij].tr[0][rn]) * bm->boxes[ij].tr[0][den];
							bm->targetspbiom[sp][ij] += (bm->boxes[ij].tr[0][sn] + bm->boxes[ij].tr[0][rn]) * bm->boxes[ij].tr[0][den];

						}
					}
				} else if (bm->boxes[ij].type != BOUNDARY) {
					for (n = 0; n < FunctGroupArray[sp].numGeneTypes; n++) {
						/* Normalise localised recruitment if necessary */
						if (bm->norm_larval_distrib && !updated_already && ((bearlive || sp_enviro_depend || (FunctGroupArray[sp].recruitType == at_parent_location))
								|| (!enviro_depend && (totad[n] != 1.0))) && (bm->dayt == EMBRYO[sp].StartDay[n][EMBRYO[sp].next_recruit]) && (bm->t / 86400.0 > 0.0)) {
							/* If not temperature dependent (when want to see effect of temperature potentially
							 hitting recruits differentially), normalise result - with regard to total population.
							 Shouldn't need to renormalise for stocks as already working off stock normalised basis
							 and any skew due to temperature effects is desired and shouldn't be normalised away,
							 but just to be safe for now */
							bm->recruit_hdistrib[n][ij][sp] = bm->recruit_hdistrib[n][ij][sp] / (totad[n] + small_num);
                            
                            //fprintf(llogfp,"Time: %e %s ngene: %d box%d recruit_hdistrib: %e totad: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, bm->recruit_hdistrib[n][ij][sp], totad[n]);
						}
					}

					for (k = 0; k < bm->boxes[ij].nz; k++) {
						stock_id = bm->group_stock[sp][ij][k];

						for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {

							sn = FunctGroupArray[sp].structNTracers[n];
							rn = FunctGroupArray[sp].resNTracers[n];
							den = FunctGroupArray[sp].NumsTracers[n];
                            stage = FunctGroupArray[sp].cohort_stage[n];

							if (MIGRATION[sp].ActualMigrator[stage] > 0) {
								for (qid = 0; qid < spmigrate; qid++) {
                                    stagger_return = MIGRATION[sp].Stagger[qid][return_stagger_id];

                                    /**
                                    //if(do_debug2){
                                    if (sp == 35) {
                                        fprintf(bm->logFile, "Time: %e %s-%d box%d-%d stage: %d (num_in_queue: %d spmigrate: %d qid: %d) leave_period: %d, Leave_Now: %d ComplexMigrator: %d cohort_migrating: %d\n", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k, stage, MIGRATION[sp].num_in_queue, spmigrate, qid, MIGRATION[sp].Leave_Period[qid], MIGRATION[sp].Leave_Now[qid], FunctGroupArray[sp].isComplexMigrator, MIGRATION[sp].cohort_migrating[n][qid]);
                                    }
                                     **/
                                    
                                    if (MIGRATION[sp].Leave_Period[qid] > 0) {  // Only execute for cohorts that are supposed to start this migration
                                        
                                        /**
                                        //if(do_debug2){
                                        if (sp == 33) {
                                            fprintf(bm->logFile, "Time: %e %s-%d stage: %d Leave_Now = %d period: %d qid: %d\n",
                                                    bm->dayt, FunctGroupArray[sp].groupCode, n, stage, MIGRATION[sp].Leave_Now[qid], MIGRATION[sp].Leave_Period[qid], qid);
                                        }
                                        **/

                                        if ((bm->dayt < MIGRATION[sp].Leave_Now[qid]) && (FunctGroupArray[sp].isComplexMigrator == FALSE))
                                            break;
                                        
                                        
                                        //if (sp == 64)
                                        //    fprintf(bm->logFile, "Time: %e %s-%d box%d-%d made it past the break\n", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k);
                                        
                                        if ((bm->dayt >= MIGRATION[sp].Leave_Now[qid]) && (bm->dayt < (MIGRATION[sp].Leave_Now[qid] + MIGRATION[sp].Leave_Period[qid])) && (bm->t / 86400.0 > 0.0) && (MIGRATION[sp].cohort_migrating[n][qid] > 0)) {

											migtime2 = Calculate_Migration_Proportion(bm, llogfp, dt, sp,
													MIGRATION[sp].Leave_Now[qid], MIGRATION[sp].Leave_Period[qid], MIGRATION[sp].Box[ij][qid]);
                                            
                                            /**
                                            //if(do_debug2){
                                                fprintf(bm->logFile, "Time: %e qid %d %s-%d box %d k: %d migtime2 = %e MigIO: %e\n", bm->dayt, qid, FunctGroupArray[sp].groupCode, n, ij, k, migtime2, MIGRATION[sp].Box[ij][qid]);
                                            //}
                                            **/
                                            

                                            if(!migtime2)  // None migrating so skip ahead
                                                continue;
                                            
											/* Calculate proportion of the tot numbers that will
											 migrate out of the system this timestep */


											if(newden[sp][n][k][ij] < 0){
												warn("before migration newden is less than 0. Box %d;%d group %s:%d\n", ij, ij, FunctGroupArray[sp].groupCode, n);
												quit("");
											}
											/* newden = proportion of total numbers in this box/layer for this group */
											/* mignum = proportion of this box that are migrating in this time step */

											migProp = migtime2;
											mignum = migProp * newden[sp][n][k][ij];   // So the proportion of the proportion of the population in the cell that leaves

                                            /**
											//if(do_debug2){
                                            if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                                                fprintf(bm->logFile, "Time: %e %s-%d (stage %d) qid: %d Box-%d-%d newden: %e mignum: %e migProp: %e\n",
														bm->dayt, FunctGroupArray[sp].groupCode, n, stage, qid, ij, k, newden[sp][n][k][ij], mignum, migProp);
											}
											**/

											newden[sp][n][k][ij] -= mignum;

											if(newden[sp][n][k][ij] < 0 ){
												warn("after migration back into box %d:%d numbers for group %s:%d are less than 0.\n",
														ij, k,FunctGroupArray[sp].groupCode, n);
												warn("migProp = %e, mignum- %e, newden = %e\n", migProp, mignum, newden[sp][n][k][ij]);
												warn("away = %d, period = %e, IOBox = %e\n", MIGRATION[sp].Leave_Now[qid], MIGRATION[sp].Leave_Period[qid], MIGRATION[sp].Box[ij][qid]);

												fprintf(stderr, "MigrateAway[%d][%d][%d] = %d\n", sp, stage, qid, MIGRATION[sp].Leave_Now[qid]);
												fprintf(stderr, "MigratePeriod[%d][%d][%d] = %d\n",  sp, stage, qid, MIGRATION[sp].Leave_Period[qid]);
												fprintf(stderr, "MigIOBox[%d][%d][%d][%d]) = %e\n", sp, ij, stage, qid, MIGRATION[sp].Box[ij][qid]);
											}


											/* Update the Migration array to take account of the new
											 immigrants */
                                            totmig = MIGRATION[sp].DEN[n][qid] + (mignum * totden[sp][n]);

                                            MIGRATION[sp].num_stagger[qid] = 0;
                                            if(FunctGroupArray[sp].multiyr_mig) {
                                                sp_Migrate_Years = (int) (MIGRATION[sp].MinYearsAway[qid]);
                                                if ((sp_Migrate_Years > 1) && (stagger_return)) {
                                                    MIGRATION[sp].num_stagger[qid] = MIGRATION[sp].Stagger[qid][stagger_years_id];
                                                }
                                            }
                                            
                                            /**
                                            //if (do_debug2) {
                                            if ((sp == 33) || ((sp > 8) && (sp < 12))) {
                                                fprintf(llogfp, "Time: %e %s stage %d qid: %d, multiyr_mig: %d, sp_Migrate_Years: %d, stagger_return: %d, totmig: %e as MIG-den: %e mignum: %e, totden: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, stage, qid, FunctGroupArray[sp].multiyr_mig, sp_Migrate_Years, stagger_return, totmig, MIGRATION[sp].DEN[n][qid], mignum, totden[sp][n]);
                                            }
                                            **/
                                            
                                            for (agec = 0; agec < FunctGroupArray[sp].ageClassSize; agec++) {
                                                MIGRATION[sp].pop_ratio[qid][n][agec] = MIGRATION[sp].current_pop_ratio[n][agec];
                                            }
                                            
                                            // All come back together
                                            MIGRATION[sp].SN[n][qid] = (MIGRATION[sp].SN[n][qid] * MIGRATION[sp].DEN[n][qid] + bm->boxes[ij].tr[k][sn] * (mignum * totden[sp][n])) / (totmig + small_num);
                                            MIGRATION[sp].RN[n][qid] = (MIGRATION[sp].RN[n][qid] * MIGRATION[sp].DEN[n][qid] + bm->boxes[ij].tr[k][rn] * (mignum * totden[sp][n])) / (totmig + small_num);
                                            MIGRATION[sp].DEN[n][qid] = totmig;
                                            
											/**
											if(do_debug2){
												fprintf(llogfp, "Time: %e, sp %s (cohort %d), qid: %d totmig = %e, totden[sp][n] = %e ",bm->dayt, FunctGroupArray[sp].groupCode, n, qid, totmig, totden[sp][n]);
												fprintf(bm->logFile, "migProp = %e, migrationDEN = %e, mignum = %e, totden[sp][n]= %e migSN: %e migRN: %e\n", migProp, MIGRATION[sp].DEN[n][qid], mignum, totden[sp][n],  MIGRATION[sp].SN[n][qid],  MIGRATION[sp].RN[n][qid]);
											}
											**/
                                            
                                            finalmig += totmig;
											avgsn = (avgsn * (finalmig - totmig) + MIGRATION[sp].SN[n][qid] * totmig) / (finalmig + small_num);
											avgrn = (avgrn * (finalmig - totmig) + MIGRATION[sp].RN[n][qid] * totmig) / (finalmig + small_num);

											/**
											//if(do_debug2){
                                            if ((sp == 33) || ((sp > 8) && (sp < 12))) {
												 fprintf(llogfp, "Time: %e, sp %s (cohort %d), qid: %d totmig = %e, totden[sp][n] = %e migProp = %e, migration = %e, mignum = %e, totden[sp][n]= %e\n",bm->dayt, FunctGroupArray[sp].groupCode, n, qid, totmig, totden[sp][n], migProp, MIGRATION[sp].DEN[n][qid], mignum, totden[sp][n]);

                                                fprintf(llogfp, "Time: %e, %d:%d, sp %s (cohort %d), qid: %d num leaving: %e (%e of %e) - migrationDEN: %e (avgsn: %e, avgrn: %e, finalmig: %e), newDen = %e\n", bm->dayt, ij, k, FunctGroupArray[sp].groupCode, n, qid,  mignum * totden[sp][n], mignum, totden[sp][n], MIGRATION[sp].DEN[n][qid], MIGRATION[sp].SN[n][qid], MIGRATION[sp].RN[n][qid], finalmig, newden[sp][n][k][ij]);

                                            }
											**/

											mig_done++;
										} else if (bm->dayt == (MIGRATION[sp].Leave_Now[qid] + MIGRATION[sp].Leave_Period[qid] + 1)) {
											spupdatemig++;
										}
									}
								}
							}

							/* Update/assign new vertebrate sn and rn pool values */
							oldsn = bm->boxes[ij].tr[k][sn];
                            if (!bm->flaghomog_sp) {
                                /* If not homogenising size across group/species disribution,
                                but allowing for differentiation and local memory. Very hard
                                to track individual movements so take new value as weighted
                                mean of old residents' size and the size of the new entrants
                                (assuming the new ones have size matching average across
                                the entire stock) */
                                totdenom = currentden[sp][n][k][ij] + totden[sp][n] * newden[sp][n][k][ij] + small_num;

                                bm->boxes[ij].tr[k][sn] = (bm->boxes[ij].tr[k][sn] * currentden[sp][n][k][ij] + VERTinfo[sp][n][SN_id] * totden[sp][n]
                                    * newden[sp][n][k][ij]) / totdenom;
                                bm->boxes[ij].tr[k][rn] = (bm->boxes[ij].tr[k][rn] * currentden[sp][n][k][ij] + VERTinfo[sp][n][RN_id] * totden[sp][n]
                                    * newden[sp][n][k][ij]) / totdenom;

                            } else {
                                /* If homogenising growth/size to reflect random movement of individuals
                                    within the global distribution of the group/species over the entire
                                    domain of the stock, set SN and RN to that mean value now */
                                bm->boxes[ij].tr[k][sn] = VERTinfo[sp][n][SN_id];
                                bm->boxes[ij].tr[k][rn] = VERTinfo[sp][n][RN_id];

                            }

                            if ((bm->boxes[ij].tr[k][sn] < 0.0) || (bm->boxes[ij].tr[k][rn] < 0.0)) {
                                fprintf(llogfp,"Time: %e, %s-%d in box%d-%d has newsn: %e, newrn:%e, with currentden: %e VERTinfo[sn]: %e, VERTinfo[rn]: %e, totden: %e, newden: %e, totdenom: %e\n",
                                    bm->dayt, FunctGroupArray[sp].groupCode, n, bm->current_box, bm->current_layer,
                                    bm->boxes[ij].tr[k][sn], bm->boxes[ij].tr[k][rn], currentden[sp][n][k][ij],
                                    VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id], totden[sp][n], newden[sp][n][k][ij], totdenom);
                                printf("Time: %e, %s-%d in box%d-%d has newsn: %e, newrn:%e, with currentden: %e VERTinfo[sn]: %e, VERTinfo[rn]: %e, totden: %e, newden: %e, totdenom: %e\n",
                                    bm->dayt, FunctGroupArray[sp].groupCode, n, bm->current_box, bm->current_layer,
                                    bm->boxes[ij].tr[k][sn], bm->boxes[ij].tr[k][rn], currentden[sp][n][k][ij],
                                    VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id], totden[sp][n], newden[sp][n][k][ij], totdenom);
                                
                                fprintf(llogfp, "ERROR Time: %e %s-%d box%d-%d this_tot_biom: %.20e, newden_sum-%d: %.20e, den: %.20e, totden: %.20e, newden: %.20e, SN-%d: %.20e, RN-%d: %.20e (vs SNinit %.20e, RNinit %.20e)\n", bm->dayt,
                                    FunctGroupArray[sp].groupCode, n, ij, k, this_tot_biom, n,
                                    newden_sum[n], bm->boxes[ij].tr[k][den], totden[sp][n],
                                    newden[sp][n][k][ij], n, bm->boxes[ij].tr[k][sn], n,
                                    bm->boxes[ij].tr[k][rn], VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id]);
                                
                                printf("ERROR Time: %e %s-%d box%d-%d this_tot_biom: %.20e, newden_sum-%d: %.20e, den: %.20e, totden: %.20e, newden: %.20e, SN-%d: %.20e, RN-%d: %.20e (vs SNinit %.20e, RNinit %.20e)\n", bm->dayt,
                                    FunctGroupArray[sp].groupCode, n, ij, k, this_tot_biom, n,
                                    newden_sum[n], bm->boxes[ij].tr[k][den], totden[sp][n],
                                    newden[sp][n][k][ij], n, bm->boxes[ij].tr[k][sn], n,
                                    bm->boxes[ij].tr[k][rn], VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id]);
                                
                                quit("Time: %e box%d-%d %s-%d had negative size or numbers after movement\n", bm->dayt, FunctGroupArray[sp].groupCode, n, ij, k);
                            }

                            /* Allocate vertebrates based on preferred habitat, feed conditions
                            or known migration paths - that is update numbers in current cell */

                            newden_sum[n] += newden[sp][n][k][ij];
                            this_tot_biom += totden[sp][n] * newden[sp][n][k][ij] * (bm->boxes[ij].tr[k][sn] + bm->boxes[ij].tr[k][rn]);
                            bm->boxes[ij].tr[k][den] = totden[sp][n] * newden[sp][n][k][ij];

                            if((bm->boxes[ij].tr[k][den] < 0) || (!_finite(bm->boxes[ij].tr[k][den]))){
                                printf("%e %s-%d movement box%d-%d den: %.20e, totden: %.20e, newden: %.20e\n", bm->dayt,
                                FunctGroupArray[sp].groupCode, n, ij, k, bm->boxes[ij].tr[k][den], totden[sp][n], newden[sp][n][k][ij]);
                                quit("Numbers of %s%d in box %d:%d are less than 0 or nan after movement.\n", FunctGroupArray[sp].groupCode, n, ij, k);
                            }
                                
							if (totden[sp][n] > bm->min_dens) {
								FunctGroupArray[sp].allgone[n] = 0;
							}

							/**
							if((do_debug2) && (sp == bm->which_check)){

								fprintf(llogfp, "END Time: %e %s-%d box%d-%d this_tot_biom: %.20e, newden_sum-%d: %.20e, den: %.20e, totden: %.20e, newden: %.20e, SN-%d: %.20e, RN-%d: %.20e (vs SNinit %.20e, RNinit %.20e)\n", bm->dayt,
										FunctGroupArray[sp].groupCode, n, ij, k, this_tot_biom, n,
										newden_sum[n], bm->boxes[ij].tr[k][den], totden[sp][n],
										newden[sp][n][k][ij], n, bm->boxes[ij].tr[k][sn], n,
										bm->boxes[ij].tr[k][rn], VERTinfo[sp][n][SN_id], VERTinfo[sp][n][RN_id]);
							}
							**/

							/* Update home range information for those species using home ranges */
							if (sp_ddepend_move == homerange_move) {
								for (rij = 0; rij < bm->boxes[ij].HomeRangeInfo[sp].n; rij++) {
									rangeid = bm->boxes[ij].HomeRangeInfo[sp].ids[rij];

									/* If this is the first step in the iteration over layers and cohorts
									 then initialise the counter
									 */
									if ((n == 0) && (k == 0)) {
										bm->boxes[ij].HomeRangeInfo[sp].rangenum[n][rij] = 0.0;
									}

									prop_range = 0;
									for (prij = 0; prij < bm->boxes[ij].HomeRangeInfo[sp].n; prij++) {
										rrid = bm->boxes[ij].HomeRangeInfo[sp].ids[prij];
										prop_range += bm->HomeRangeTotal[sp][n][rrid] * bm->boxes[ij].HomeRangeInfo[sp].rangewgt[prij];
									}

									bm->boxes[ij].HomeRangeInfo[sp].rangenum[n][rij] += bm->boxes[ij].tr[k][den] * bm->HomeRangeTotal[sp][n][rangeid]
											* bm->boxes[ij].HomeRangeInfo[sp].rangewgt[rij] / (prop_range + small_num);
								}
							}

							init_stock_struct_prop[sp][n][stock_id] += bm->boxes[ij].tr[k][den];

							bm->totbiom[sp] += (bm->boxes[ij].tr[k][sn] + bm->boxes[ij].tr[k][rn]) * bm->boxes[ij].tr[k][den];
							bm->targetspbiom[sp][ij] += (bm->boxes[ij].tr[k][sn] + bm->boxes[ij].tr[k][rn]) * bm->boxes[ij].tr[k][den];

						}
					}
				}
			}
            
            //fprintf(llogfp,"%s move2 now has next_larvae set to %d\n", FunctGroupArray[sp].groupCode, EMBRYO[sp].next_larvae);
            //printf("%s move2 now has next_larvae set to %d\n", FunctGroupArray[sp].groupCode, EMBRYO[sp].next_larvae);
            
			/* Finalise migration now all boxes iterated through */
            for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
                stage = FunctGroupArray[sp].cohort_stage[n];
                if (MIGRATION[sp].ActualMigrator[stage] > 0) {
					dynsn = VERTinfo[sp][n][SN_id];
					dynrn = VERTinfo[sp][n][RN_id];

					if (!spupdatemig) {
						avgsn = dynsn;
						avgrn = dynrn;
					}

					/* If assuming migrants just emerge into the model domain at the correct size */
					if (!bm->flagavgmig && spupdatemig) {
						avgsn = 0;
						avgrn = 0;
						/*
						for (i = 0; i < spmigrate; i++) {
							Migration[sp][i][n][SN_id] = KMIG[sp][n][SN_id];
							Migration[sp][i][n][RN_id] = KMIG[sp][n][RN_id];
						}
						*/
                        
                        // TODO: Fix for multiyr case
						for (qid = 0; qid < spmigrate; qid++) {
							if (MIGRATION[sp].DEN[n][qid] > 0) {
								avgsn = MIGRATION[sp].SN[n][qid];
								avgrn = MIGRATION[sp].RN[n][qid];
								break;
							}
						}
					}

					/* Store migrants in box 0 layer 0 so can look at it in netcdf output file
					 - initialised above and then give average values for size and total numbers */
					sn = FunctGroupArray[sp].structNTracers[n];
					rn = FunctGroupArray[sp].resNTracers[n];
					den = FunctGroupArray[sp].NumsTracers[n];

					finalmig = 0;

					for (qid = 0; qid < spmigrate; qid++) {
						finalmig += MIGRATION[sp].DEN[n][qid];
					}

					bm->boxes[0].tr[0][sn] = avgsn;
					bm->boxes[0].tr[0][rn] = avgrn;
					bm->boxes[0].tr[0][den] += finalmig;

					stage = FunctGroupArray[sp].cohort_stage[n];

					/**
					if (do_debug2) {
						if(finalmig > 0){
							fprintf(llogfp, "Time: %e setting %s-%d-mig sn = %e, rn = %e, finalmig = %e (totmigDEN: %e, totden: %e), spupdatemig= %d\n", bm->dayt, FunctGroupArray[sp].groupCode, n, avgsn, avgrn, finalmig, bm->boxes[0].tr[0][den], totden[sp][n], spupdatemig);
						}
					}
					**/
                    
				}
			}

			/* Store population sizes and check stock structure */
			for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
				VERTabund_check[sp][n] = totden[sp][n];
			}

		}
        
        if(bm->track_contaminants && FunctGroupArray[sp].isVertebrate){
            for (n = 0; n < FunctGroupArray[sp].numCohortsXnumGenes; n++) {
                Move_Vert_Contaminated(bm, sp, n, currentden);
            }
        }
 	}
    
    /**
    if ((bm->which_check <= bm->K_num_tot_sp)){
        if (FunctGroupArray[bm->which_check].isVertebrate == TRUE) {
            for (ij = 0; ij < bm->nbox; ij++) {
                if (bm->boxes[ij].type != BOUNDARY) {
                    for (k = 0; k < bm->boxes[ij].nz; k++) {
                        for (n = 0; n < FunctGroupArray[bm->which_check].numCohortsXnumGenes; n++) {
                            den = FunctGroupArray[bm->which_check].NumsTracers[n];
                        
                            fprintf(llogfp, "END END Time: %e, %s-%d box%d-%d totden: %e, den: %e (newden: %e)\n", bm->dayt, FunctGroupArray[bm->which_check].groupCode, n, ij, k, totden[bm->which_check][n], bm->boxes[ij].tr[k][den], newden[bm->which_check][n][k][ij]);
                        }
                    }
                }
            }
        }
    }
    **/
    
    i_free1d(mig_returners);

	i_free2d(counted);
	free3d(preyamt);
	free2d(boxden);
	free4d(currentden);
	free2d(leftden);
	free1d(totboxden);
	free1d(totroc);
	free1d(totad);
	free1d(newden_sum);


	if (bm->debug && (mig_done && ((bm->debug == debug_migrate) || (bm->debug == debug_general)) && (bm->dayt > bm->checkstart)))
		Check_Gape(bm, llogfp);

	return;
}

/**
 *	\brief This routine calculates any movements by invertebrates
 *	(horizontal or vertical).
 *
 *	Incudes vertical migration for pelagic groups and broader geographic
 *	movements (currently on prescribed) for lobsters and age structured
 *	vertebrates (cephalopods and prawns)
 *
 * Basic algorithm for migration out of the model:
 *
 * For each migrating invertebrate group
 * Calculate the total biomass in the model
 * For each non-boundary box calculate the new group density in that box based on the prescribed movement and migration
 * Calculate the new biomass in each box as the total biomass * new biomass proportion in each box.
 *
 * Migration into the model
 *
 *
 */

void Ecology_Invert_Migration(MSEBoxModel *bm, double dt, FILE *llogfp) {
	int fgIndex;
	int ij, k, day_part, pid, sp, flagsp, qid, sp_ddepend_move, sp_geo_move, spmigrate, spmigrate_done, cohort, flagcontract_sp, stage, maxk, stagger_return;
    int temp_sensitive_sp, salt_sensitive_sp;
	double amt, current_enviro, min_temp_sp, max_temp_sp, migperiod, FSM_sp, FSMG_sp, migtime, migbiom, migbiom_basic, FSMG_grow, totamt, min_O2_sp, min_salt_sp, max_salt_sp, contract_sp, pH_scale, K_temp_const_sp, K_salt_const_sp, K_o2_const_sp, numScalar, stagger_scalar;
    //double min_spawnsalt_sp, max_spawnsalt_sp, min_spawntemp_sp, max_spawntemp_sp; - TODO: Shouldn't these be used?
    //double origamt;
    //double step1, step2;
    double migtime2;
    int qrt, next_qrt, this_HowFar, agec, sp_Migrate_Years;
	//int sp_debug;
    // do_debug;
	double totboxden[invert_biosum + 1];
	int enviro_depend = 0;
	double ****currentden;
	double some_ice, midpoint;
	double ldayt = bm->t / 86400.0;
    
    if (bm->flagtempdepend || bm->flagsaltdepend || bm->flagO2depend)
    	enviro_depend = 1;

    //printf("Creating invert migration arrays\n");

	currentden = Util_Alloc_Init_4D_Double(bm->nbox, bm->wcnz, bm->K_num_max_cohort * bm->K_num_max_genetypes, bm->K_num_tot_sp, 0.0);
	current_enviro = 0.0;

    /*
	if (bm->debug && ((bm->debug == debug_migrate) || ((bm->debug > debug_eat) || ((bm->debug > debug_spawn) && (bm->debug < debug_biom)))) && (bm->dayt
			> (bm->checkstart - 1)))
		do_debug = 1;
	else
		do_debug = 0;
     */
    
	/* If the fish are also moving then the Q10 calcs will have been done then - else do it now */
	if (!bm->fishmove){
		midpoint = bm->boxes[1].inside.y;

		Parameter_Q10(bm, &bm->boxes[1], ldayt, 1, 0, bm->boxes[1].nz - 1, midpoint, WC, llogfp);
	}

	if (verbose)
		printf("Dealing with invertebrate movement\n");

	if (bm->flagday)
		day_part = 0;
	else
		day_part = 1;

	/* Initialise local arrays */
	for (sp = 0; sp < bm->K_num_tot_sp; sp++) {
		if (FunctGroupArray[sp].isVertebrate == FALSE && FunctGroupArray[sp].isImpacted == TRUE) {
			bm->totbiom[sp] = 0.0;
			for (ij = 0; ij < bm->nbox; ij++) {
				bm->targetspbiom[sp][ij] = 0.0;
			}
		}
	}

	/* Determine the new distribution for the diel vertical migrating invertebrates */
	for (fgIndex = 0; fgIndex < bm->K_num_tot_sp; fgIndex++) {
		sp = fgIndex;
        
        flagsp = (int) (FunctGroupArray[sp].speciesParams[flag_id]);
        sp_ddepend_move = (int) (FunctGroupArray[sp].speciesParams[ddepend_move_id]);
        min_temp_sp = FunctGroupArray[sp].speciesParams[min_move_temp_id];
        max_temp_sp = FunctGroupArray[sp].speciesParams[max_move_temp_id];
        min_salt_sp = FunctGroupArray[sp].speciesParams[min_move_salt_id];
        max_salt_sp = FunctGroupArray[sp].speciesParams[max_move_salt_id];
        min_O2_sp = FunctGroupArray[sp].speciesParams[min_O2_id];

        temp_sensitive_sp = (int)(FunctGroupArray[sp].speciesParams[flagtempsensitive_id]);
        salt_sensitive_sp = (int)(FunctGroupArray[sp].speciesParams[flagSaltSensitive_id]);
        
        if (FunctGroupArray[sp].numMoveEntries != 4) {
            this_HowFar = FunctGroupArray[sp].HowFar;
        } else {
            this_HowFar = bm->HowFar;
        }
        
        // For non-mobile invertebrates constrain them to initial distributions
        if(bm->flagconstrain_epiwander && (FunctGroupArray[fgIndex].habitatType == EPIFAUNA) && !FunctGroupArray[fgIndex].sp_geo_move) {
            pid = FunctGroupArray[fgIndex].totNTracers[0];
            for (ij = 0; ij < bm->nbox; ij++) {
                if (!FunctGroupArray[sp].distrib[ij][0][0])
                    bm->boxes[ij].epi[pid] = 0.0;
            }
        }
        
        // Put in environmental limitations for non-mobile groups
        if (enviro_depend && flagsp && (FunctGroupArray[fgIndex].sp_geo_move == FALSE)) {
            /* If temperature dependent check to see if temperatures suitable here.
               If not zero the entry. Simialrly for salinity and oxygen.
            */
            for (cohort = 0; cohort < FunctGroupArray[fgIndex].numCohortsXnumGenes; cohort++) {
                pid = FunctGroupArray[fgIndex].totNTracers[cohort];
                for (ij = 0; ij < bm->nbox; ij++) {
                    if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA)
                        maxk = 0;
                    else
                        maxk = bm->boxes[ij].nz;
                    
                    for (k = 0; k < maxk; k++) {
                        /* Noise and light pollution avoidance */
                        if (FunctGroupArray[sp].isLightEffected) {
                            current_enviro = bm->boxes[ij].tr[k][Light_Pollution_i];
                            if (current_enviro > 0) {
                                if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA)
                                    bm->boxes[ij].epi[pid] *= (FunctGroupArray[sp].speciesParams[light_coefft_id] / (current_enviro + small_num));
                                else
                                    bm->boxes[ij].tr[k][pid] *= (FunctGroupArray[sp].speciesParams[light_coefft_id] / (current_enviro + small_num));
                            }
                        }
                        
                        if (FunctGroupArray[sp].isNoiseEffected) {
                            current_enviro = bm->boxes[ij].tr[k][Noise_Pollution_i];
                            if (current_enviro > 0) {
                                if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA)
                                    bm->boxes[ij].epi[pid] *= (FunctGroupArray[sp].speciesParams[noise_coefft_id] / (current_enviro + small_num));
                                else
                                    bm->boxes[ij].tr[k][pid] *= (FunctGroupArray[sp].speciesParams[noise_coefft_id] / (current_enviro + small_num));
                            }
                        }

                        /* Other physical environment */
                        numScalar = 1.0;
                        current_enviro = bm->boxes[ij].tr[k][Temp_i];
                        K_temp_const_sp = FunctGroupArray[sp].speciesParams[K_temp_const_id];
                        numScalar = Get_Enviro_Move_Scalar(temp_sensitive_sp, current_enviro, K_temp_const_sp, min_temp_sp, max_temp_sp, sp, 1, bm->dayt, llogfp);
                        if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA) {
                            bm->boxes[ij].epi[pid] *= numScalar;
                        } else {
                            bm->boxes[ij].tr[k][pid] *= numScalar;
                        }

                        numScalar = 1.0;
                        current_enviro = bm->boxes[ij].tr[k][Salinity_i];
                        K_salt_const_sp = FunctGroupArray[sp].speciesParams[K_salt_const_id];
                        numScalar = Get_Enviro_Move_Scalar(salt_sensitive_sp, current_enviro, K_salt_const_sp, min_salt_sp, max_salt_sp, sp, 2, bm->dayt, llogfp);
                        if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA) {
                            bm->boxes[ij].epi[pid] *= numScalar;
                        } else {
                            bm->boxes[ij].tr[k][pid] *= numScalar;
                        }

                        numScalar = 1.0;
                        current_enviro = bm->boxes[ij].tr[k][Oxygen_i];
                        K_o2_const_sp = FunctGroupArray[sp].speciesParams[K_o2_const_id];
                        numScalar = Get_Enviro_Move_Scalar(bm->flagO2depend, current_enviro, K_o2_const_sp, min_O2_sp, 10000000000.0, sp, 3, bm->dayt, llogfp);
                        if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA) {
                            bm->boxes[ij].epi[pid] *= numScalar;
                        } else {
                            bm->boxes[ij].tr[k][pid] *= numScalar;
                        }
                
                        // If ice dependent and no ice present then not present
                        if(bm->ice_on) {
                            some_ice = Get_Ice_Presence(bm, sp, cohort, ij, 0, bm->ICE_HABITATlike);
                            if(!some_ice){
                                if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA)
                                    bm->boxes[ij].epi[pid] = 0.0;
                                else
                                    bm->boxes[ij].tr[k][pid] = 0.0;
                            }
                        }
                        
                        if(bm->track_contaminants) {
                            // Contaminant avoidance
                            numScalar = Avoid_Contaminants(bm, sp, cohort, ij, k);
                            if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA) {
                                bm->boxes[ij].epi[pid] *= numScalar;
                            } else {
                                bm->boxes[ij].tr[k][pid] *= numScalar;
                            }
                        }
                    }
                }
            }
        }
        
        // Dedicated invertebrate movements
		if (flagsp && (FunctGroupArray[fgIndex].speciesParams[flag_id] == TRUE) && (FunctGroupArray[fgIndex].isVertebrate == FALSE) && (FunctGroupArray[fgIndex].isMobile == TRUE)) {
            
            spmigrate = MIGRATION[sp].num_in_queue;
            spmigrate_done = MIGRATION[sp].num_in_queue_done;
            sp_geo_move = FunctGroupArray[fgIndex].sp_geo_move;
            
            /* Make parameter adjustments due to acidification */
            flagcontract_sp = (int)FunctGroupArray[sp].speciesParams[flagcontract_tol_id];
            pH_scale = (FunctGroupArray[sp].pHcorr - 1.0);
           if( flagcontract_sp  && (pH_scale > 0.0)) {
                contract_sp = FunctGroupArray[sp].speciesParams[contract_tol_id];
                min_temp_sp += contract_sp * pH_scale;
                max_temp_sp -= contract_sp * pH_scale;
            }

            if ((sp_ddepend_move > sedentary_move) && (sp_ddepend_move != no_move))
                quit("No density- or forage- dependent movement for invertebrates yet, set ddepend_move flag to 0 or 1 for %s or set to 4 for no geographic movement\n", FunctGroupArray[sp].groupCode);
            
            /* Get the current season index */
            qrt = FunctGroupArray[sp].moveEntryIndex;
            next_qrt = FunctGroupArray[sp].next_moveEntryIndex;

			for (cohort = 0; cohort < FunctGroupArray[fgIndex].numCohortsXnumGenes; cohort++) {
				pid = FunctGroupArray[fgIndex].totNTracers[cohort];
				stage = FunctGroupArray[fgIndex].cohort_stage[cohort];
				FSM_sp = 1.0;
				FSMG_sp = 1.0;

				//sp_debug = do_debug;
				/* Sort this out now so we don't have to keep doing this test all though this function
				if (do_debug && (((bm->move_check < no_move_check) && (bm->move_check > bm->K_num_tot_sp - 1)) || (sp == bm->move_check))) {
					sp_debug = 2;
				}
                */
                
                /* Starting biomass check */
                totamt = 0.0;

                for (ij = 0; ij < bm->nbox; ij++) {
                    if (bm->boxes[ij].type != BOUNDARY && bm->boxes[ij].type != LAND) {
                        amt = 0;
                        if (FunctGroupArray[fgIndex].habitatType != EPIFAUNA) {
                            for (k = 0; k < bm->boxes[ij].nz; k++) {
                                amt += bm->boxes[ij].tr[k][pid];
                                totamt += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;

                                /*
                                if (sp_debug == 2) {
                                    fprintf(llogfp, "Time: %e, sp %s (%d)in box: %d layer: %d, starts with %e (%.20e)\n",
                                        bm->dayt, FunctGroupArray[sp].groupCode, pid, ij, k, amt, bm->boxes[ij].tr[k][pid]);
                                }
                                 */
                            }
                        } else {
                            amt += bm->boxes[ij].epi[pid];
                            totamt += bm->boxes[ij].epi[pid] * bm->boxes[ij].area;
								
                            /**
                            if (sp_debug == 2) {
                                fprintf(llogfp, "Time: %e, sp %s in box: %d epilayer starts with %e\n", bm->dayt, FunctGroupArray[sp].groupCode, ij, amt);
                            }
                            **/
                        }
                    }
                }

                //origamt = totamt;
                /*
                 if (sp_debug == 2) {
                    fprintf(llogfp, "Time: %e %s:%d total starting amt: %.20e ", bm->dayt, FunctGroupArray[sp].groupCode, cohort, totamt);
						fprintf(llogfp, "spmigrate = %d ", spmigrate);
						fprintf(llogfp, "sp_ddepend_move = %d ", sp_ddepend_move);
						fprintf(llogfp, "sp_geo_move = %d\n", sp_geo_move);

                }
                 */
                /* Store biomass so can scale movement distributions */
                totboxden[invert_biosum+cohort] = totamt;
            }

            for (cohort = 0; cohort < FunctGroupArray[fgIndex].numCohortsXnumGenes; cohort++) {
                /** Bring back migrants **/
                for (qid = spmigrate_done; qid < spmigrate; qid++) {
                    migperiod = MIGRATION[sp].Return_Period[qid];
                    FSM_sp = MIGRATION[sp].survival[qid];
                    FSMG_sp = MIGRATION[sp].growth[qid];
                    stagger_return = MIGRATION[sp].Stagger[qid][return_stagger_id];

                            
                    /**
                    if (sp_debug == 2) {
                        fprintf(llogfp, "Time: %e, %s-%d (stage %d) is moving with migrate qid %d: Return_Now: %d, migperiod: %e\n", bm->dayt, FunctGroupArray[sp].groupCode, cohort, stage, qid, MIGRATION[sp].Return_Now[qid], migperiod);
                    }
                    **/
                    
                    // Update for stagger - so more return in the next year if any stagger left
                    if (bm->dayt == (MIGRATION[sp].Return_Now[qid] + migperiod + 1.0)) {
                        if (MIGRATION[sp].num_stagger[qid] > 0) {
                            MIGRATION[sp].Return_Now[qid] += 365;
                            MIGRATION[sp].num_stagger[qid] -= 1;
                        }
                    }

                    /* Migration back into to model domain */
                    if ((bm->dayt >= MIGRATION[sp].Return_Now[qid]) && (bm->dayt < (MIGRATION[sp].Return_Now[qid] + migperiod)) && (bm->t / 86400.0 > 0.0)) {
                        /* Update numbers for returning migrants and then update overall size, based on contributions from returning migrants */
                        migtime = MIGRATION[sp].Return_Now[qid] - MIGRATION[sp].Leave_Now[qid];

                        /* Calculate the proportion that are coming back in this timesetp */
                        migtime2 = Calculate_Migration_Proportion_Back(bm, llogfp, dt, sp, MIGRATION[sp].Return_Now[qid], migperiod);

                        // Reduce prop returning if staggering (so some left for next stagger year)
                        if (MIGRATION[sp].num_stagger[qid] > 0) {
                            stagger_scalar = 1.0 / (double)(MIGRATION[sp].num_stagger[qid]);
                            migtime2 *= stagger_scalar;
                        }

                        /* Migrants coming in all years after the first year are
                            based on populations that migrated out of the model domain previously,
								 otherwise use in KMIGa (set up in biolsetup) */
                        migbiom_basic = MIGRATION[sp].DEN[cohort][qid] * migtime2;
                        MIGRATION[sp].DEN[cohort][qid] -= migbiom_basic;
                        /* Reset Migration matrix if all have returned or this migration period is over */
                        if (MIGRATION[sp].DEN[cohort][qid] < 0.0) {
                            MIGRATION[sp].DEN[cohort][qid] = 0.0;
                        }

                        /* Correct for losses while away */
                        migbiom = FSM_sp * migbiom_basic;

                        /* Adjust to account for growth during the intervening period */
                        FSMG_grow = 1.0 + (FSMG_sp * migtime / 364.0);
                        migbiom *= FSMG_grow;

                        totboxden[invert_biosum+cohort] += migbiom;

                        if ((bm->dayt + 2) > (MIGRATION[sp].Return_Now[qid] + migperiod)) {
                            MIGRATION[sp].DEN[cohort][qid] = 0.0;
                        }
                        
                        /*
                        if (sp_debug == 2) {
                            fprintf(llogfp, "Time: %e, %s-%d Migration %d Total biomass back into model = %e ",
                                bm->dayt, FunctGroupArray[sp].groupCode, cohort, qid, migbiom * bm->X_CN * mg_2_tonne);
                            fprintf(bm->logFile, "MIGRATION[sp].DEN[stage][qid] = %e\n", MIGRATION[sp].DEN[cohort][qid] * bm->X_CN * mg_2_tonne);
                        }
                        */
                    }
                }
            }

            
            for (cohort = 0; cohort < FunctGroupArray[fgIndex].numCohortsXnumGenes; cohort++) {
                /** Do any horizontal movement necessary **/
                /* Currently assumes prescribed migration. And deposits
                   the migrating individuals in lowest water column layer
                   and lets vertical movement routine below redistribute them.
                   Also note that reusing newden and totboxden arrays but as
                   no vertical layering or cohort loops required using on the
                   first cell in each of those dimensions (thus newden[n][0][0][ij],
                   totboxden[0]).
                         
                   TODO: Make this consistent with vertebrates and move animals at
                   approrpiate water column layers - have started this with the enviro checks
                */
                if (!sp_ddepend_move && sp_geo_move) {
                    totboxden[invert_propsum] = 0;

                    for (ij = 0; ij < bm->nbox; ij++) {
                        if (bm->boxes[ij].type != BOUNDARY) {

                            // Check to see if epifauna or water column dwellers in terms of locations to check for environmental conditions
                            if (FunctGroupArray[fgIndex].habitatType == EPIFAUNA)
                                maxk = 0;
                            else
                                maxk = bm->boxes[ij].nz;

                            /* Prescribed movement */
                            newden[sp][cohort][0][ij] = this_HowFar * (FunctGroupArray[sp].distrib[ij][next_qrt][cohort] - FunctGroupArray[sp].distrib[ij][qrt][cohort]) + FunctGroupArray[sp].distrib[ij][qrt][cohort];
								
                            /*
                            if(sp_debug == 2){
                                fprintf(llogfp,"day: %e, %s-newden[%d][%d]: %e, HowFar: %e, distrib%s-%d-%d-%d: %e, distrib%s-%d-%d-%d: %e\n",
                                    bm->dayt, FunctGroupArray[sp].groupCode, cohort, ij, newden[sp][cohort][0][ij], this_HowFar, FunctGroupArray[sp].groupCode, ij, next_qrt, cohort, FunctGroupArray[sp].distrib[ij][next_qrt][cohort], FunctGroupArray[sp].groupCode, ij, qrt, cohort, FunctGroupArray[sp].distrib[ij][qrt][cohort]);
                            }
                            */
                                
                            /* Do environmental checks - FIX - This needs to be tidied up in new code where
                               distinction between vertebrates and invertebrates reduced (talk to Bec)
                            */
                                
                            if (enviro_depend) {
                                /* If temperature dependent check to see if temperatures suitable here.
                                    If not zero the entry. Simialrly for salinity and oxygen.
                                    */
                                for (k = 0; k < maxk; k++) {
                                    /* Noise and light pollution avoidance */
                                    if (FunctGroupArray[sp].isLightEffected) {
                                        current_enviro = bm->boxes[ij].tr[k][Light_Pollution_i];
                                        if (current_enviro > 0) {
                                            newden[sp][cohort][k][ij] *= (FunctGroupArray[sp].speciesParams[light_coefft_id] / (current_enviro + small_num));
                                        }
                                    }
                                    
                                    if (FunctGroupArray[sp].isNoiseEffected) {
                                        current_enviro = bm->boxes[ij].tr[k][Noise_Pollution_i];
                                        if (current_enviro > 0) {
                                            newden[sp][cohort][k][ij] *= (FunctGroupArray[sp].speciesParams[noise_coefft_id] / (current_enviro + small_num));
                                        }
                                    }
                                    
                                    /* Other physical environment */
                                    numScalar = 1.0;
                                    current_enviro = bm->boxes[ij].tr[k][Temp_i];
                                    K_temp_const_sp = FunctGroupArray[sp].speciesParams[K_temp_const_id];
                                    numScalar = Get_Enviro_Move_Scalar(temp_sensitive_sp, current_enviro, K_temp_const_sp, min_temp_sp, max_temp_sp, sp, 1, bm->dayt, llogfp);
                                    newden[sp][cohort][k][ij] *= numScalar;
                                    
                                    if (temp_sensitive_sp && !numScalar) {
                                       warn("Group %s in box %d:%d in movement code is set to 0 as the current temperature (%f) is outside the allowed range %f - %f\n", FunctGroupArray[sp].groupCode, ij, k, current_enviro, min_temp_sp, max_temp_sp);
                                    }

                                    numScalar = 1.0;
                                    current_enviro = bm->boxes[ij].tr[k][Salinity_i];
                                    K_salt_const_sp = FunctGroupArray[sp].speciesParams[K_salt_const_id];
                                    numScalar = Get_Enviro_Move_Scalar(salt_sensitive_sp, current_enviro, K_salt_const_sp, min_salt_sp, max_salt_sp, sp, 2, bm->dayt, llogfp);
                                    newden[sp][cohort][k][ij] *= numScalar;
                                    
                                    if (salt_sensitive_sp && !numScalar) {
                                        warn("Group %s in box %d:%d in movement code is set to 0 as the salinity is outside the allowed range %e-%e\n", FunctGroupArray[sp].groupCode, ij, k, min_salt_sp, max_salt_sp);
                                    }

                                    numScalar = 1.0;
                                    current_enviro = bm->boxes[ij].tr[k][Oxygen_i];
                                    K_o2_const_sp = FunctGroupArray[sp].speciesParams[K_o2_const_id];
                                    numScalar = Get_Enviro_Move_Scalar(bm->flagO2depend, current_enviro, K_o2_const_sp, min_O2_sp, 10000000000.0, sp, 3, bm->dayt, llogfp);
                                    newden[sp][cohort][k][ij] *= numScalar;
                                    
                                    if (bm->flagO2depend && !numScalar) {
                                        warn("Group %s in box %d:%d in movement code is set to 0 as the oxygen is below the allowed min %e\n", FunctGroupArray[sp].groupCode, ij, k, min_O2_sp);
                                    }

                                    // If ice dependent and no ice present then not present
                                    if(bm->ice_on) {
                                        some_ice = Get_Ice_Presence(bm, sp, cohort, ij, 0, bm->ICE_HABITATlike);
                                        if(!some_ice){
                                            newden[sp][cohort][k][ij] = 0.0;
                                        }
                                    }
                                    
                                    if(bm->track_contaminants) {
                                        // Contaminant avoidance
                                        numScalar = Avoid_Contaminants(bm, sp, cohort, ij, k);
                                        newden[sp][cohort][k][ij] *= numScalar;
                                    }
                                }
                            }
                            /*
                            if(sp_debug == 2){
                                fprintf(llogfp,"%s enviro_depend: %d, flagtempdepend: %d, current_enviro: %e, min_temp_sp: %e, max_temp_sp: %e\n",
                                    FunctGroupArray[sp].groupCode, enviro_depend, bm->flagtempdepend, current_enviro, min_temp_sp, max_temp_sp);
                                fprintf(llogfp,"%s flagsaltdepend: %d, current_enviro: %e, min_salt_sp: %e, max_salt_sp: %e\n",
                                    FunctGroupArray[sp].groupCode, bm->flagsaltdepend, current_enviro, min_salt_sp, max_salt_sp);
                                fprintf(llogfp,"%s flagO2depend: %d,  min_O2_sp: %e\n",
                                    FunctGroupArray[sp].groupCode,  bm->flagO2depend, min_O2_sp);

                            }
                             */
                            
                            /* Total up the new proportions just to make sure */
                            totboxden[invert_propsum] += newden[sp][cohort][0][ij];

                            for (qid = spmigrate_done; qid < spmigrate; qid++) {
                                migperiod = MIGRATION[sp].Leave_Period[qid];

                                /* Migration out of model domain */
                                if ((bm->dayt >= MIGRATION[sp].Leave_Now[qid]) && (bm->dayt < (MIGRATION[sp].Leave_Now[qid] + migperiod)) && (bm->t / 86400.0 > 0.0) && (MIGRATION[sp].cohort_migrating[cohort][qid] > 0)) {

                                    /* Calculate the proportion that are leaving in this timesetp */
                                    migtime2 = Calculate_Migration_Proportion(bm, llogfp, dt, sp, MIGRATION[sp].Leave_Now[qid], migperiod, MIGRATION[sp].Box[ij][qid]);

                                    /* Calculate proportion of tot biomass that will
										 migrate out of the system this timestep */
                                    migbiom = newden[sp][cohort][0][ij] * migtime2;
                                    newden[sp][cohort][0][ij] -= migbiom;

                                    /* Update the Migration array to take account of the new
                                        immigrants */
                                    MIGRATION[sp].DEN[cohort][qid] += migbiom * totboxden[invert_biosum];
                                    
                                    MIGRATION[sp].num_stagger[qid] = 0;
                                    if(FunctGroupArray[sp].multiyr_mig) {
                                        sp_Migrate_Years = (int) (MIGRATION[sp].MinYearsAway[qid]);
                                        if ((sp_Migrate_Years > 1) && (stagger_return)) {
                                            MIGRATION[sp].num_stagger[qid] = MIGRATION[sp].Stagger[qid][stagger_years_id];
                                        }
                                    }                                
                                    
                                    for (agec = 0; agec < FunctGroupArray[sp].ageClassSize; agec++) {
                                        MIGRATION[sp].pop_ratio[qid][cohort][agec] = MIGRATION[sp].current_pop_ratio[cohort][agec];
                                    }
                                    
                                    /*
                                    if (sp_debug == 2){
                                        fprintf(llogfp, "%s-%d Migration %d Box:%d Biomass out of box = %e (migbiom: %e)\n",
                                            FunctGroupArray[sp].groupCode, cohort, qid, ij, migbiom * totboxden[invert_biosum], migbiom);
                                    }
                                     */
                                }
                            }
                        }
                    }

                    /*
                    if (sp_debug == 2) {
                        for (qid = 0; qid < spmigrate; qid++) {
                            fprintf(llogfp, "Time: %e, %s-%d Migration %d Total group biomass outside model is %e\n",
									bm->dayt, FunctGroupArray[sp].groupCode, stage, qid, MIGRATION[sp].DEN[cohort][qid] * bm->X_CN * mg_2_tonne);
                        }
                    }
                     */
                    
                    /* If something doesn't add up normalise */
                    if (totboxden[invert_propsum] != 1.0) {
                        for (ij = 0; ij < bm->nbox; ij++) {
                            if (bm->boxes[ij].type != BOUNDARY) {
                                newden[sp][cohort][0][ij] = newden[sp][cohort][0][ij] / (totboxden[invert_propsum] + small_num);
                            }
                        }
                    }

                    /* Allocate to new locations */
					if (FunctGroupArray[fgIndex].habitatType != EPIFAUNA) {
                        /* Animals allowed in the water column - including prawns */
                        for (ij = 0; ij < bm->nbox; ij++) {
                            if (bm->boxes[ij].type != BOUNDARY && bm->boxes[ij].type != LAND) {
                                /* As benthic invertebrates or water column	invertebrates
                                   with vertical movement still to happen put entire biomass
                                   in bottom-most water layer and set all other layers
                                   to zero - divide by volume so back in mgN m-3*/
                                bm->boxes[ij].tr[0][pid] = totboxden[invert_biosum+cohort] * newden[sp][cohort][0][ij] / (bm->boxes[ij].dz[0] * bm->boxes[ij].area + small_num);
								/*
                                if(sp_debug == 2){
                                    fprintf(llogfp,"%s has totboxden: %e, newden[%d][%d]: %e\n", FunctGroupArray[sp].groupCode, totboxden[invert_biosum], cohort, ij, newden[sp][cohort][0][ij]);
                                }
								*/

								for (k = 1; k < bm->boxes[ij].nz; k++)
                                    bm->boxes[ij].tr[k][pid] = 0;
                            }
                        }
                    } else {
                        /* Epibenthos */
                        for (ij = 0; ij < bm->nbox; ij++) {
                            if (bm->boxes[ij].type != BOUNDARY) {
                                bm->boxes[ij].epi[pid] = totboxden[invert_biosum+cohort] * newden[sp][cohort][0][ij] / (bm->boxes[ij].area + small_num);
                            }
                        }
                    }
                }

                /* Intermediate biomass check *
                if (sp_debug == 2) {
                    totamt = 0;
                    for (ij = 0; ij < bm->nbox; ij++) {
                        if (bm->boxes[ij].type != BOUNDARY && bm->boxes[ij].type != LAND) {
                            amt = 0;
                            for (k = 0; k < bm->boxes[ij].nz; k++) {
                                amt += bm->boxes[ij].tr[k][pid];
                                totamt += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
                                fprintf(llogfp, "Time: %e, sp %s in box: %d layer: %d, ends ddepend with %e (%.20e)\n",
                                    bm->dayt, FunctGroupArray[sp].groupCode, ij, k, amt, bm->boxes[ij].tr[k][pid]);
                            }
                        }
                    }

                    fprintf(llogfp, "Time: %e, %s total end biom: %e (%e of orig)\n", bm->dayt, FunctGroupArray[sp].groupCode, totamt, totamt / origamt);

                }
                 */
                /** For animals in the water column do any vertical movement necessary **/
                if (FunctGroupArray[fgIndex].habitatType != EPIFAUNA) {
                    for (ij = 0; ij < bm->nbox; ij++) {
                        if (bm->boxes[ij].type != BOUNDARY && bm->boxes[ij].type != LAND) {

                            amt = 0.0;

                            /* Calculate total in the local watercolumn */
                            for (k = 0; k < bm->boxes[ij].nz; k++){
                                amt += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;

                                if (!(_finite(bm->boxes[ij].tr[k][pid] ))) {
                                    fprintf(stderr, "Ecology_Invert_Migration - Tracer %s in Box %d, layer %d is infinite\n", Varname[pid], ij, k);
                                    abort();
                                }
                            }
                            /* Get vertical distribution - fo any non-mobile groups */
                            for (k = 0; k < bm->boxes[ij].nz; k++){
                                currentden[fgIndex][cohort][k][ij] = bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area / (amt + small_num);
                            }

                            /* Get vertical distribution - including environmental constraints */
                            Get_Vertical_Distribution(bm, ij, sp, currentden, enviro_depend, day_part, cohort, llogfp);

                            for (k = 0; k < bm->boxes[ij].nz; k++) {
                                /* Update stored vertdistrib value - so can condition catch timeseries if need be */
                                if (FunctGroupArray[sp].isImpacted == TRUE){
                                    bm->boxes[ij].vert_vdistrib[sp][stage][k] = tempdistrib[k][stage];
                                }

                                /* Redistribute accordingly */
                                bm->boxes[ij].tr[k][pid] = amt * tempdistrib[k][cohort] / (bm->boxes[ij].dz[k] * bm->boxes[ij].area + small_num);

                                if (!(_finite(bm->boxes[ij].tr[k][pid] ))) {
                                    printf("amt = %e,  tempdistrib[k][0] = %e, bm->boxes[ij].dz[k] = %e, bm->boxes[ij].area = %e \n",
                                            amt,  tempdistrib[k][cohort], bm->boxes[ij].dz[k], bm->boxes[ij].area);
                                    quit("Ecology_Invert_Migration - day: %e, box: %d, layer: %d %s set to %e.\n",
                                            bm->dayt, bm->current_box, bm->current_layer, FunctGroupArray[sp].groupCode,
                                            bm->boxes[ij].tr[k][pid] );
                                }

                                /**
                                if (sp_debug == 2) {
                                    fprintf(llogfp, "Time: %e, sp %s in box: %d layer: %d, ends redistrib with %.20e (amt: %.20e tempdistrib: %.20e)\n",
											bm->dayt, FunctGroupArray[sp].groupCode, ij, k, bm->boxes[ij].tr[k][pid], amt, tempdistrib[k][cohort]);
                                }
                                **/

                            }
                        }
                    }
                }

                /* Final biomass check *
                if (sp_debug == 2) {
                    totamt = 0;
                    for (ij = 0; ij < bm->nbox; ij++) {
                        if (bm->boxes[ij].type ==LAND){
                            amt = bm->boxes[ij].tr[0][pid];
                            totamt += bm->boxes[ij].tr[0][pid] * bm->boxes[ij].area;

                        } else if (bm->boxes[ij].type != BOUNDARY) {
                            amt = 0;
                            if (FunctGroupArray[fgIndex].habitatType != EPIFAUNA) {
                                for (k = 0; k < bm->boxes[ij].nz; k++) {
                                    amt += bm->boxes[ij].tr[k][pid];
                                    totamt += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
                                    fprintf(llogfp, "Time: %e, sp %s in box: %d layer: %d, ends with %e (%e, dz: %e, area: %e)\n",
                                        bm->dayt, FunctGroupArray[sp].groupCode, ij, k, amt, bm->boxes[ij].tr[k][pid], bm->boxes[ij].dz[k], bm->boxes[ij].area);
                                }
                            } else {
                                amt += bm->boxes[ij].epi[pid];
                                totamt += bm->boxes[ij].epi[pid] * bm->boxes[ij].area;
                            }
                        }
                    }

                    fprintf(llogfp, "Time: %e, %s total end biom: %e (%e of orig)\n", bm->dayt, FunctGroupArray[sp].groupCode, totamt, totamt / origamt);
				}
                 */
			}
		}
	}

	/* Update fisheries target groups */
	for(ij=0; ij<bm->nbox; ij++){
		if(bm->boxes[ij].type != BOUNDARY && bm->boxes[ij].type != LAND){
			/* Pelagic invertebrates */

			for(sp = 0; sp < bm->K_num_tot_sp; sp++){
				if(FunctGroupArray[sp].isVertebrate == FALSE && FunctGroupArray[sp].isImpacted == TRUE){
					for(cohort = 0; cohort < FunctGroupArray[sp].numCohortsXnumGenes; cohort++){
						pid = FunctGroupArray[sp].totNTracers[cohort];

						if(FunctGroupArray[sp].habitatType == WC){
							for(k=0; k<bm->boxes[ij].nz; k++){
								bm->totbiom[sp] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
								bm->targetspbiom[sp][ij] += bm->boxes[ij].tr[k][pid] * bm->boxes[ij].dz[k] * bm->boxes[ij].area;
							}
						}else if(FunctGroupArray[sp].habitatType == SED){
							for(k=0; k<bm->boxes[ij].sm.nz; k++){
								bm->totbiom[sp] += bm->boxes[ij].sm.tr[k][pid] * bm->boxes[ij].sm.dz[k] * bm->boxes[ij].area;
								bm->targetspbiom[sp][ij] += bm->boxes[ij].sm.tr[k][pid] * bm->boxes[ij].sm.dz[k] * bm->boxes[ij].area;
							}
						}else{
							bm->totbiom[sp] += bm->boxes[ij].epi[pid] * bm->boxes[ij].area;
							bm->targetspbiom[sp][ij] += bm->boxes[ij].epi[pid] * bm->boxes[ij].area;
						}
					}
				}
			}
		}
	}
	free4d(currentden);
	return;
}

/**
 *	\brief This routine introduces invading species by scaling existing trophic group.
 *
 *	Incudes scaling for vertebrate and invertebrate groups
 *
 */
void Ecology_Invading_Species(MSEBoxModel *bm, double dt, FILE *llogfp) {
	int ij, k, sk, den, n, curr_ind, last_ind, b, chkbox, nb, chrtstage, habsp, go_there, found_food, prey, pn, preystage, bk;
	double InvadeScalar = 0.0, InvadeHowFar = 0.0, step1 = 0.0, tot_scalar = 0.0, this_depth = 0.0,
        sp_like = 0.0, dist_scalar = 1.0;
    double sp_likeREEF, sp_likeFLAT, sp_likeSOFT, sp_likeCANYON, preyamt, this_scalar, dist;
    
	if ((bm->dayt < bm->InvaderStartDay) || (bm->dayt > bm->InvaderEndDay))
		return;
    
    if (verbose > 0)
        printf("Ecology_Invading_Species\n");
    
    /* Add the inital invaders */
    if (bm->InvadersEntering && (bm->dayt >= bm->InvaderStartDay)) {
        for (n = bm->minInvaderAge; n < bm->maxInvaderAge; n++) {
            den = FunctGroupArray[bm->InvaderIndex].NumsTracers[n];
            bm->boxes[bm->InvaderEntryBox].tr[bm->InvaderEntryLayer][den] = bm->InvaderStartNums[n];
            bm->InvadersEntering = 0;  // So not done again next time
        }
    }

	switch (bm->invading_sp_model) {
	case no_invader: /* Nothing to do so continue */
		break;
	case simple_invader: /* Simple invading species */
		if (FunctGroupArray[bm->InvaderIndex].isVertebrate == TRUE) {
			/* Invading species is a vertebrate so scale numbers in
			 appropriate cohorts. Do it only in first entry box as
			 explicit movement will move it from there
			 */
            for (n = bm->minInvaderAge; n < bm->maxInvaderAge; n++) {
                den = FunctGroupArray[bm->InvaderIndex].NumsTracers[n];
                for (k = 0; k < bm->boxes[bm->InvaderEntryBox].nz; k++) {
                    bm->boxes[bm->InvaderEntryBox].tr[k][den] *= (1.0 + bm->InvaderScalar);
                }
			}
		} else {
			/* Invading species is an invertebrate so scale biomass in first cell
			 and spill it to adjacent cells through time, if not explicitly
			 migrating already (done via InvadingArray, which is set up on read-in).
			 */
			step1 = (bm->dayt - bm->InvaderStartDay) / bm->Invadedt;
			InvadeHowFar = (bm->dayt - bm->InvaderStartDay) / (bm->InvaderSatDay - bm->InvaderStartDay);
			curr_ind = (int) (ceil(step1));
			if (curr_ind > bm->Invadendt)
				curr_ind = bm->Invadendt;
			last_ind = (int) (floor(step1));
			if (last_ind > bm->Invadendt)
				last_ind = bm->Invadendt;

			for (ij = 0; ij < bm->nbox; ij++) {
				if (bm->dayt < bm->InvaderSatDay) { /* Still spreading - below saturation */
					InvadeScalar = InvadeHowFar * (bm->InvadeArray[ij][curr_ind] - bm->InvadeArray[ij][last_ind]) + bm->InvadeArray[ij][curr_ind];
				} else
					/* At saturation so all increasing at same rate as inflow point */
					InvadeScalar = bm->InvaderScalar;
				for (k = 0; k < bm->boxes[ij].nz; k++) {
					bm->boxes[ij].tr[k][bm->InvaderPID] *= (1.0 + InvadeScalar);
				}
			}
		}
		break;
    case conditional_invader:  /* Based on depth, temperature and salinity preferences, habitat and prey */
        for (b = 0; b < bm->nbox; b++) {
            Util_Init_2D_Double(bm->invader_spread_scalars, bm->nbox, bm->wcnz, 0.0); // has to be here because the normalisation is over all boxes not just neigbouring boxes and then use that value to immediately go round and scale all the tracers
            
        	/* First get new entrants */
            if (b == bm->InvaderEntryBox) {
                for (k = 0; k < bm->boxes[b].nz; k++) {
                    if (FunctGroupArray[bm->InvaderIndex].isVertebrate == TRUE) {
                        /* Invading species is a vertebrate so scale numbers in appropriate cohorts. */
                        for (n = bm->minInvaderAge; n < bm->maxInvaderAge; n++) {
                            den = FunctGroupArray[bm->InvaderIndex].NumsTracers[n];
                            bm->boxes[bm->InvaderEntryBox].tr[k][den] *= (1.0 + bm->InvaderScalar);
                        }
                    } else {
                        /* Invading species is an invertebrate so scale biomass in first cell
                         and spill it to adjacent cells through time */
                        bm->boxes[b].tr[k][bm->InvaderPID] *= (1.0 + InvadeScalar);
                    }
                }
            }
            
            /* Now spread to nearby boxes with correct conditions */
            tot_scalar = 0.0;
            
            // Need to have one entry for the local box so they don't all bleed away
            this_scalar = bm->InvaderScalar;  // As a place holder for now - is just a relative weighting versus what flows to other boxes, which will be downscaled by distance to be moved
            for (k = 0; k < bm->boxes[b].nz; k++) {
            	bm->invader_spread_scalars[b][k] = this_scalar;
            }
            tot_scalar += this_scalar;
            
            // Now do neighbouring boxes
            for (chkbox = 0; chkbox < bm->boxes[b].nUniqueAdj; chkbox++) {
                nb = bm->boxes[b].uniqueAdjBoxes[chkbox];
                this_depth = bm->boxes[nb].botz;
                if ((this_depth <= (-1.0 * FunctGroupArray[bm->InvaderIndex].speciesParams[mindepth_id])) && (this_depth >= (-1.0 * bm->InvaderMaxDepth))) {
                    for (n = bm->minInvaderAge; n < bm->maxInvaderAge; n++) {
                        chrtstage = FunctGroupArray[bm->InvaderIndex].cohort_stage[n];

                        // Depth ok so check habitat
                        sp_like = 0;
                        if (FunctGroupArray[bm->InvaderIndex].isHabDepend > 0){
                            // Check geological habitats
                            sp_likeREEF = bm->HABITATlike[bm->InvaderIndex][chrtstage][bm->REEFcover_id] * bm->boxes[nb].reef;
                            sp_likeFLAT = bm->HABITATlike[bm->InvaderIndex][chrtstage][bm->FLATcover_id] * bm->boxes[nb].flat;
                            sp_likeSOFT = bm->HABITATlike[bm->InvaderIndex][chrtstage][bm->SOFTcover_id] * bm->boxes[nb].soft;
                            sp_likeCANYON = bm->HABITATlike[bm->InvaderIndex][chrtstage][bm->CANYONcover_id];
                            if ((sp_likeREEF > 0.0) || (sp_likeFLAT > 0.0) || (sp_likeSOFT > 0.0) || (sp_likeCANYON > 0.0))
                                sp_like = 1;
                            
                            // If that not enough check biogenic habitats
                            if(!sp_like) {
                                for(habsp = 0; habsp < bm->K_num_tot_sp; habsp++){
                                    if (FunctGroupArray[habsp].isCover == TRUE) {
                                        sp_like = bm->HABITATlike[bm->InvaderIndex][chrtstage][FunctGroupArray[habsp].coverID] * bm->coveramt[FunctGroupArray[habsp].coverID][nb];
                                        if (sp_like)
                                            break;
                                    }
                                }
                            }
                        } else {
                            sp_like = 1;
                        }
                        
                        if (sp_like) {  // Habitat found in potential new location
                            for (k = 0; k < bm->boxes[nb].nz; k++) {
                                // Then check the environment
                                go_there = Invade_Spread(bm, bm->InvaderIndex, llogfp, b, nb, k, &dist);
                                found_food = 0;
                                if (go_there) {  // Conditions suitable so check prey
                                    for (prey = 0; prey < bm->K_num_tot_sp; prey++) {
                                        if (FunctGroupArray[prey].habitatType == WC){
                                            switch (FunctGroupArray[prey].groupAgeType) {
                                                case AGE_STRUCTURED:
                                                    break;
                                                case AGE_STRUCTURED_BIOMASS:	/* Intentional follow through */
                                                case BIOMASS:
                                                    for (pn = 0; pn < FunctGroupArray[prey].numCohortsXnumGenes; pn++) {
                                                        preystage = FunctGroupArray[prey].cohort_stage[pn];
                                                        preyamt = bm->boxes[nb].tr[k][FunctGroupArray[prey].totNTracers[pn]] * bm->pSPVERTeat[bm->InvaderIndex] [prey][chrtstage][preystage];
                                                        if (preyamt) {
                                                            found_food = 1;
                                                            break;
                                                        }
                                                    }
                                                    break;
                                            }
                                        }
                                        
                                        if(!found_food) {  // On bother looking for other prey if haven't found anything already
                                            if (FunctGroupArray[prey].habitatType == SED){
                                                for (sk = 0; sk < bm->boxes[nb].sm.nz; sk++) {  // loop over sediment layers
                                                    preyamt = bm->boxes[nb].sm.tr[sk][FunctGroupArray[prey].totNTracers[0]];
                                                    if (preyamt) {
                                                        found_food = 1;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (!found_food) {
                                            if (FunctGroupArray[prey].habitatType == EPIFAUNA){
                                                for (pn = 0; pn < FunctGroupArray[prey].numCohortsXnumGenes; pn++) {
                                                    preystage = FunctGroupArray[prey].cohort_stage[pn];
                                                    preyamt = bm->boxes[nb].epi[FunctGroupArray[prey].totNTracers[pn]];
                                                    if (preyamt) {
                                                        found_food = 1;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (found_food)  // Break the count as found food at the new location
                                            break;
                                    }
                                }
                         
                                if (found_food ) {  // All a go so lets find out how much moves
                                    dist_scalar = bm->InvaderSpeed / dist;
                                    if(dist_scalar > 1.0)
                                        dist_scalar = 1.0;  // So can't all evacuate the box in one go as establishing in current box and spreading not just teleporting around the map
                                    this_scalar = bm->InvaderScalar * dist_scalar;   // dt already taken into account in calculation of bm->InvaderScalar
                                    bm->invader_spread_scalars[nb][k] = this_scalar;
                                    tot_scalar += this_scalar;
                                }else{
                                	bm->invader_spread_scalars[nb][k] = 0;
                                }
                            }
                        }
                    }
                }
            }
            
            // Normalise the scalars
            if (tot_scalar > 0.0) {
            	for (nb = 0; nb < bm->nbox; nb++) {
                	for (k = 0; k < bm->boxes[nb].nz; k++) {
                		bm->invader_spread_scalars[nb][k] /= tot_scalar;
                	}
                }

                // Now do the invader dispersal
                for (chkbox = 0; chkbox < bm->boxes[b].nUniqueAdj; chkbox++) {
                    nb = bm->boxes[b].uniqueAdjBoxes[chkbox];
                    for (k = 0; k < bm->boxes[nb].nz; k++) {
                        bk = k;
                        if(bk >= bm->boxes[nb].nz)
                            bk = bm->boxes[nb].nz - 1;
                        this_scalar = bm->invader_spread_scalars[nb][k];

                        // Proportion of numbers or biomass in local box b dispersing to destinaiton box nb
                        if (FunctGroupArray[bm->InvaderIndex].isVertebrate == TRUE) {
                            for (n = bm->minInvaderAge; n < bm->maxInvaderAge; n++) {
                                den = FunctGroupArray[bm->InvaderIndex].NumsTracers[n];
                                bm->boxes[nb].tr[k][den] += (this_scalar * bm->boxes[b].tr[bk][den]);
                            }
                        } else {
                            bm->boxes[nb].tr[k][bm->InvaderPID] += this_scalar * bm->boxes[b].tr[bk][bm->InvaderPID];
                        }
                    }
                }
                // Reset local numbers or biomass to reflect those that dispersed
                for (k = 0; k < bm->boxes[b].nz; k++) {
                    this_scalar = bm->invader_spread_scalars[b][k];
                    if (FunctGroupArray[bm->InvaderIndex].isVertebrate == TRUE) {
                        /* Invading species is a vertebrate so scale numbers in appropriate cohorts. */
                        for (n = bm->minInvaderAge; n < bm->maxInvaderAge; n++) {
                            den = FunctGroupArray[bm->InvaderIndex].NumsTracers[n];
                            bm->boxes[b].tr[k][den] *= this_scalar;
                        }
                    } else {
                        /* Invading species is an invertebrate so scale biomass in first cell
                         and spill it to adjacent cells through time */
                        bm->boxes[b].tr[k][bm->InvaderPID] *= this_scalar;
                    }
                }
            }
        }

        break;
	case complex_invader: /* More complex invading species */
		quit("No such code for this invader case - only simple case (flaginvade = 1) coded to date\n");
		break;
	default:
		quit("No such code for this invader case - only simple case (flaginvade = 1) coded to date\n");
		break;
	}

	return;
}

/**
 * \brief Calculate the larvaldistrib values for the given species.
 *
 * These are used in vertebrate_reproduction to calculate the num_recruits.
 */
int Invade_Spread(MSEBoxModel *bm, int sp, FILE *llogfp, int b, int nb, int k, double *dist ) {
    int temp_sensitive_sp = (int)(FunctGroupArray[sp].speciesParams[flagtempsensitive_id]);
    int salt_sensitive_sp = (int)(FunctGroupArray[sp].speciesParams[flagSaltSensitive_id]);
    double min_temp_sp = FunctGroupArray[sp].speciesParams[min_move_temp_id];
    double max_temp_sp = FunctGroupArray[sp].speciesParams[max_move_temp_id];
    double min_salt_sp = FunctGroupArray[sp].speciesParams[min_move_salt_id];
    double max_salt_sp = FunctGroupArray[sp].speciesParams[max_move_salt_id];
    double min_O2_sp = FunctGroupArray[sp].speciesParams[min_O2_id];
    double there_temp = bm->boxes[nb].tr[k][Temp_i];
    double there_salt = bm->boxes[nb].tr[k][Salinity_i];
    double there_o2 = bm->boxes[nb].tr[k][Oxygen_i];
    int go_there = 0;
    double current_enviro;

    double xdiff = bm->boxes[b].inside.x - bm->boxes[nb].inside.x;
    double ydiff = bm->boxes[b].inside.y - bm->boxes[nb].inside.y;
    *dist = sqrt(xdiff * xdiff + ydiff * ydiff);
    
    if ((!temp_sensitive_sp) && (!salt_sensitive_sp) && (!bm->flagO2depend))
        go_there = 1;
    
    if (temp_sensitive_sp) {
        if ( (min_temp_sp < there_temp ) || (max_temp_sp > there_temp ))
            go_there = 0;
        else
            go_there = 1;
    }
    
    if (salt_sensitive_sp) {
        if ( (min_salt_sp < there_salt ) || (max_salt_sp > there_salt ))
            go_there = 0;
        else
            go_there = 1;
    }

    if (bm->flagO2depend) {
        if (there_o2 > min_O2_sp )
            go_there = 1;
        else
            go_there = 0;
    }
    
    /* Noise and light pollution avoidance */
    if (FunctGroupArray[sp].isLightEffected) {
        current_enviro = bm->boxes[nb].tr[k][Light_Pollution_i];
        if (current_enviro > 0) {
            go_there = ceil(FunctGroupArray[sp].speciesParams[light_coefft_id] / (current_enviro + small_num));
        }
    }
    
    if (FunctGroupArray[sp].isNoiseEffected) {
        current_enviro = bm->boxes[nb].tr[k][Noise_Pollution_i];
        if (current_enviro > 0) {
            go_there = ceil(FunctGroupArray[sp].speciesParams[noise_coefft_id] / (current_enviro + small_num));
        }
    }
    
    
    return go_there;
    
}

/**
 * \brief Calculate the larvaldistrib values for the given species.
 *
 * These are used in vertebrate_reproduction to calculate the num_recruits.
 */
int Larval_Dispersal(MSEBoxModel *bm, int sp, FILE *llogfp) {

	int ngene;
	int ij;
	int year = (int)((bm->t / 86400.0) / 365.0);
	double totlarvae = 0;
	int recipientbox, donorbox;
	ij = 0;

//	fprintf(llogfp, "Larval_Dispersal - year = %d\n", year);
//	fprintf(logfp, "bm->larvalYears = %d\n", bm->larvalYears);
//	fprintf(llogfp, "bm->larval_rewind = %d\n", bm->larval_rewind);

	if (year >= bm->larvalYears) {
		if (bm->larval_rewind == TRUE)
			year = 0;
		else
			year = bm->larvalYears;

	}

	//fprintf(llogfp, "updated - year = %d\n", year);

	// Do the matrix multiplication of connectivity matrx * adults
    if (!bm->larvae_connect_only) {
        for (recipientbox = 0; recipientbox < bm->nbox; recipientbox++) {
            bm->larvaldistrib[recipientbox][sp] = 0;
            if (bm->boxes[recipientbox].type != BOUNDARY) {
                for (donorbox = 0; donorbox < bm->nbox; donorbox++) {
                    for( ngene = 0; ngene < FunctGroupArray[sp].numGeneTypes; ngene++){
                        bm->larvaldistrib[recipientbox][sp] += bm->recruit_hdistrib[ngene][donorbox][sp] * bm->connectivitymatrix[sp][year][donorbox][recipientbox];
                    }
                }
                totlarvae += bm->larvaldistrib[recipientbox][sp]; // Moved from within the donorbox loop
            }
        }
    } else {
        for (recipientbox = 0; recipientbox < bm->nbox; recipientbox++) {
            bm->larvaldistrib[recipientbox][sp] = 0;
            if (bm->boxes[recipientbox].type != BOUNDARY) {
                for (donorbox = 0; donorbox < bm->nbox; donorbox++) {
                    bm->larvaldistrib[recipientbox][sp] += bm->connectivitymatrix[sp][year][donorbox][recipientbox];
                }
                totlarvae += bm->larvaldistrib[recipientbox][sp];
            }
        }
	}

	/* Normalize if appropriate */
    if(bm->norm_larval_distrib) {
        for (recipientbox = 0; recipientbox < bm->nbox; recipientbox++) {
            bm->larvaldistrib[recipientbox][sp] = bm->larvaldistrib[recipientbox][sp] / (totlarvae + small_num);
        }
	}

	/* Print the proportional spatial dist of larvae and adults*/
	if (bm->newmonth)  {
         fprintf(llogfp, "Species: %s , For each box, Prop of Adults (column 1) and Prop of Recruits Settling (column 2) \n", FunctGroupArray[sp].groupCode);
         for (ij = 0; ij < bm->nbox; ij++) {
             for( ngene = 0; ngene < FunctGroupArray[sp].numGeneTypes; ngene++){
                 fprintf(llogfp, " %e  %e  \n", bm->recruit_hdistrib[ngene][ij][sp], bm->larvaldistrib[ij][sp]);
             }
         }
	}

	return 0;
}

/**************************************************************************************************************************************************/

/*
 * \brief Helper routine to determines vertical position in the water column - for age-structured groups (i.e. "vertebrates")
 *
 */

void Get_Vertical_Distribution(MSEBoxModel *bm, int ij, int species, double ****currentden, int enviro_depend, int day_part, int cohort, FILE *llogfp){

	int layerk, diffdeep, k, tracker_id;
	int flagdem = (int) (FunctGroupArray[species].speciesParams[flagdem_id]);
	int maxdeep = bm->wcnz;
	double sumnzj1, sumnza1, sumnzj2, sumnza2, current_enviro;
	//double min_temp_sp = FunctGroupArray[species].speciesParams[min_move_temp_id];
	//double max_temp_sp = FunctGroupArray[species].speciesParams[max_move_temp_id];
	//double min_salt_sp = FunctGroupArray[species].speciesParams[min_move_salt_id];
	//double max_salt_sp = FunctGroupArray[species].speciesParams[max_move_salt_id];
	//double min_O2_sp = FunctGroupArray[species].speciesParams[min_O2_id];
	int totaldeep, first_id, second_id, stage;
	int age_mat = (int) (FunctGroupArray[species].speciesParams[age_mat_id]);
	int do_debug = 0;
	if ((species == bm->which_check) && (bm->dayt >= bm->checkstart) && (bm->debug == debug_move))
		do_debug = 1;

    //do_debug = 1;

	if(cohort <= -1){
		// Doing adults and juveniles in bulk
		tracker_id = adult_id;
	} else {
		// Doing a specific cohort
		stage = FunctGroupArray[species].cohort_stage[cohort];
		tracker_id = stage;
	}


	// Initialise (just in case)
	for (k = 0; k < bm->wcnz; k++) {
		tempdistrib[k][juv_id] = 0.0;
		tempdistrib[k][adult_id] = 0.0;
	}

	/* Load in overwintering or normal vertical distributions */
	if(FunctGroupArray[species].isMobile){

		for (k = 0; k < bm->wcnz; k++) {
			step1distrib[k][juv_id] = FunctGroupArray[species].distrib_VERTICAL[day_part][k][juv_id];
			step1distrib[k][tracker_id] = FunctGroupArray[species].distrib_VERTICAL[day_part][k][tracker_id];

			if (FunctGroupArray[species].speciesParams[overwintering_id] > 0) {
				step1distrib[k][juv_id] = FunctGroupArray[species].distrib_OVERWINTER[k][juv_id];
				step1distrib[k][tracker_id] = FunctGroupArray[species].distrib_OVERWINTER[k][tracker_id];
			}
		}
	} else {
		if(cohort == -1){
			first_id = juv_id;
			second_id = adult_id;
		}else{
			if(cohort < age_mat){
				first_id = cohort;
				second_id = age_mat;
			} else {
				first_id = juv_id;
				second_id = cohort;
			}
		}

		for (k = 0; k < bm->wcnz; k++) {
			step1distrib[k][juv_id] = currentden[species][first_id][k][ij];
			step1distrib[k][tracker_id] = currentden[species][second_id][k][ij];
		}
	}

	if(do_debug){
		for (k = 0; k < bm->wcnz; k++) {
			fprintf(llogfp,"Time: %e %s box %d-%d day_part: %d, step1-juv: %e (%e), step1-tracker: %e (%e), step1-adult: %e (%e) \n",
				bm->dayt, FunctGroupArray[species].groupCode, ij, k, day_part, step1distrib[k][juv_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][juv_id],
				 step1distrib[k][tracker_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][tracker_id],
				   step1distrib[k][adult_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][adult_id]);
		}
	}



	/* If considering a vertebrate group in an area that is too shallow to have
	 all the water column layers present rescale */
	/* Calculate vertical depth contribution - start with ideal distribution */
	totaldeep = bm->boxes[ij].nz;

	if (totaldeep < maxdeep) {
		/* If considering a vertebrate group in an area that is too
		 shallow to have all the water column layers present rescale */
		diffdeep = maxdeep - totaldeep;
		sumnzj1 = 0.0;
		sumnza1 = 0.0;
		sumnzj2 = 0.0;
		sumnza2 = 0.0;
		for (k = 0; k < bm->boxes[ij].nz; k++) {
			layerk = k + diffdeep;

			if(cohort <= -1){
				// Doing adults and juveniles in bulk - so make sure do juvenile case, adult done under tracker_id and store_id
				sumnzj1 += step1distrib[layerk][juv_id];
				sumnzj2 += step1distrib[k][juv_id];
			} else {
				// Doing a specific cohort - done under tracker id and store_id
			}
			sumnza1 += step1distrib[layerk][tracker_id];
			sumnza2 += step1distrib[k][tracker_id];

		}

		if (sumnzj1 < sumnzj2) {
			for (k = 0; k < bm->boxes[ij].nz; k++) {
				tempdistrib[k][juv_id] = step1distrib[k][juv_id] / sumnzj2;
			}

		} else if (!sumnzj1) {
			for (k = 0; k < bm->boxes[ij].nz; k++) {
				tempdistrib[k][juv_id] = 0;
			}

			if (!flagdem) {
				/* If pelagic */
				k = bm->boxes[ij].nz - 1;
				tempdistrib[k][juv_id] = 1;
			} else {
				/* If demersal */
				k = 0;
				tempdistrib[k][juv_id] = 1;
			}
		} else {
			for (k = 0; k < bm->boxes[ij].nz; k++) {
				layerk = k + diffdeep;
				tempdistrib[k][0] = step1distrib[layerk][juv_id] / sumnzj1;
			}
		}
		if (sumnza1 < sumnza2) {
			for (k = 0; k < bm->boxes[ij].nz; k++) {
				tempdistrib[k][tracker_id] = step1distrib[k][tracker_id] / sumnza2;
			}
		} else if (!sumnza1) {
			for (k = 0; k < bm->boxes[ij].nz; k++) {
				tempdistrib[k][tracker_id] = 0;
			}

			if (!flagdem) {
				/* If pelagic */
				k = bm->boxes[ij].nz - 1;
				tempdistrib[k][tracker_id] = 1;
			} else {
				/* If demersal */
				k = 0;
				tempdistrib[k][tracker_id] = 1;
			}
		} else {
			for (k = 0; k < bm->boxes[ij].nz; k++) {
				layerk = k + diffdeep;
				tempdistrib[k][tracker_id] = step1distrib[layerk][tracker_id] / sumnza1;
			}
		}

	} else {
		for (k = 0; k < bm->boxes[ij].nz; k++) {
			tempdistrib[k][juv_id] = step1distrib[k][juv_id];
			tempdistrib[k][tracker_id] = step1distrib[k][tracker_id];
		}
	}


	if(do_debug){
		for (k = 0; k < bm->wcnz; k++) {
			fprintf(llogfp,"Time: %e %s box %d-%d day_part: %d, temp-juv: %e (%e), temp-tracker: %e (%e), temp-adult: %e (%e) \n",
				bm->dayt, FunctGroupArray[species].groupCode, ij, k, day_part, tempdistrib[k][juv_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][juv_id],
					tempdistrib[k][tracker_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][tracker_id],
					tempdistrib[k][adult_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][adult_id]);
		}
	}

	/* Correct for any environmental constraintts */
	if (enviro_depend) {
		for (k = 0; k < bm->boxes[ij].nz; k++) {
            /* Noise and light pollution avoidance */
            if (FunctGroupArray[species].isLightEffected) {
                current_enviro = bm->boxes[ij].tr[k][Light_Pollution_i];
                if (current_enviro > 0) {
                    tempdistrib[k][juv_id] *= (FunctGroupArray[species].speciesParams[light_coefft_id] / (current_enviro + small_num));
                    tempdistrib[k][adult_id] *= (FunctGroupArray[species].speciesParams[light_coefft_id] / (current_enviro + small_num));
                }
            }
            
            if (FunctGroupArray[species].isNoiseEffected) {
                current_enviro = bm->boxes[ij].tr[k][Noise_Pollution_i];
                if (current_enviro > 0) {
                    tempdistrib[k][juv_id] *= (FunctGroupArray[species].speciesParams[noise_coefft_id] / (current_enviro + small_num));
                    tempdistrib[k][adult_id] *= (FunctGroupArray[species].speciesParams[noise_coefft_id] / (current_enviro + small_num));
                }
            }
            
            // TODO: May need to allow for renormalisation of layers so end up sandwiched into non-zero layers rather than drain them away
            // TODO: Allow for deepening of distribution as environment changes
            /* Ignore following code as handled in main movement routine with an enviro check there
			if (bm->flagtempdepend) {
				current_enviro = bm->boxes[ij].tr[k][Temp_i];
				if ((current_enviro < min_temp_sp) || (current_enviro > max_temp_sp)) {
					tempdistrib[k][juv_id] = 0.0;
					tempdistrib[k][adult_id] = 0.0;

					if(do_debug){
						fprintf(llogfp,"WARNING Time: %e %s box %d-%d day_part: %d, temp-juv: %e (%e), temp-tracker: %e (%e), temp-adult: %e (%e) current_enviro: %e, min_temp: %e, max_temp: %e\n",
							bm->dayt, FunctGroupArray[species].groupCode, ij, k, day_part, tempdistrib[k][juv_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][juv_id],
								tempdistrib[k][tracker_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][tracker_id],
								tempdistrib[k][adult_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][adult_id],
								current_enviro, min_temp_sp, max_temp_sp);
					}
				}
			}
			if (bm->flagsaltdepend) {
				current_enviro = bm->boxes[ij].tr[k][Salinity_i];
				if ((current_enviro < min_salt_sp) || (current_enviro > max_salt_sp)) {
					tempdistrib[k][juv_id] = 0.0;
					tempdistrib[k][adult_id] = 0.0;

					if(do_debug){
						fprintf(llogfp,"WARNING Time: %e %s box %d-%d day_part: %d, temp-juv: %e (%e), temp-tracker: %e (%e), temp-adult: %e (%e) current_enviro: %e, min_salt: %e, max_salt: %e\n",
							bm->dayt, FunctGroupArray[species].groupCode, ij, k, day_part, tempdistrib[k][juv_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][juv_id],
								tempdistrib[k][tracker_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][tracker_id],
								tempdistrib[k][adult_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][adult_id],
								current_enviro, min_salt_sp, max_salt_sp);
					}

				}
			}
			if (bm->flagO2depend) {
				current_enviro = bm->boxes[ij].tr[k][Oxygen_i];
				if (current_enviro < min_O2_sp) {
					tempdistrib[k][juv_id] = 0.0;
					tempdistrib[k][adult_id] = 0.0;

					if(do_debug){
						fprintf(llogfp,"WARNING Time: %e %s box %d-%d day_part: %d, temp-juv: %e (%e), temp-tracker: %e (%e), temp-adult: %e (%e) current_enviro: %e, min_O2: %e\n",
							bm->dayt, FunctGroupArray[species].groupCode, ij, k, day_part, tempdistrib[k][juv_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][juv_id],
								tempdistrib[k][tracker_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][tracker_id],
								tempdistrib[k][adult_id], FunctGroupArray[species].distrib_VERTICAL[day_part][k][adult_id],
								current_enviro, min_O2_sp);
					}

				}
			}
             */
		}
	}
}
